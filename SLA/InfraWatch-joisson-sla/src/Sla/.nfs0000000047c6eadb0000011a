import { ServiceType, Status } from '@prisma/client';
import { SLIIntegration, MonitoringResult } from './sli.integration';

//FunÃ§Ã£o utilitÃ¡ria para integrar com o sistema de monitoramento existente
export async function integrateWithMonitoring(serviceId: string, serviceType: ServiceType, monitoringResult: any) {
    const normalizedResult: MonitoringResult = {
        status: monitoringResult.status || Status.DOWN,
        responseMs: monitoringResult.responseMs,
        totalMs: monitoringResult.totalMs,
        avgMs: monitoringResult.avgMs,
        httpStatus: monitoringResult.httpStatus,
        lossPercent: monitoringResult.lossPercent,
        sysName: monitoringResult.sysName,
        sysDescr: monitoringResult.sysDescr
    };

    await SLIIntegration.processMonitoringResult(serviceId, serviceType, normalizedResult);
}

//FunÃ§Ã£o para configurar integraÃ§Ã£o automÃ¡tica
export function enableAutoSLIGeneration() {
    console.log('ðŸ”— IntegraÃ§Ã£o automÃ¡tica de SLI habilitada');
}

export async function generateBatchSLIs(prisma: any) {
  try {
    console.log('ðŸ”„ Gerando SLIs em lote...');
    
    const services = await prisma.service.findMany();
    console.log(`ðŸ“Š Processando ${services.length} serviÃ§os...`);

    let successCount = 0;
    let errorCount = 0;

    for (const service of services) {
      try {
        const simulatedResult: MonitoringResult = {
          status: service.status,
          responseMs: service.lastResponseMs || undefined
        };

        await SLIIntegration.processMonitoringResult(service.id, service.type, simulatedResult);
        successCount++;
      } catch (error) {
        console.error(`Erro ao processar serviÃ§o ${service.name}:`, error);
        errorCount++;
      }
    }

    console.log(`âœ… SLIs gerados: ${successCount} sucessos, ${errorCount} erros`);
    return { successCount, errorCount };
  } catch (error) {
    console.error('Erro na geraÃ§Ã£o de SLIs em lote:', error);
    throw error;
  }
}
