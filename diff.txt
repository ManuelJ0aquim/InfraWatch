
diff --git a/.env b/.env
index e81c684..3952d5d 100644
--- a/.env
+++ b/.env
@@ -5,6 +5,7 @@ INFLUX_BUCKET=InfraWatch
 
 DATABASE_URL=postgresql://neondb_owner:npg_rfhAN9ZLQOK2@ep-odd-sea-a17w4to9-pooler.ap-southeast-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require
 
+
 EMAIL_USER=filipejoaquim828@gmail.com
 EMAIL_PASS=blbdztjcfjqynrzh
 
@@ -13,21 +14,22 @@ TWILIO_AUTH_TOKEN=008a7bb6e7ad2e20bc80e9efd7d60886
 TWILIO_PHONE_NUMBER=+17343982210
 
 REDIS_URL="rediss://default:AfJVAAIncDE2MWY2NTFmZTNiM2Q0MWFlYjZhOGMyMDE5OGUwYzZmMHAxNjIwMzc@up-firefly-62037.upstash.io:6379"
-
 SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
 
 PORT=3002
 NGROK_AUTH_TOKEN='2v8skkXFCKqVX4quPddeIFsAnDN_5TGSQyrDG7i55Kv7V5Tuy'
 
+<<<<<<< HEAD
+
 GLPI_URL=http://localhost:8080/apirest.php
-GLPI_APP_TOKEN=tmDDtjtMFyiV18RESgAOq59vad13mPGmjHqpguGE
-GLPI_USER_TOKEN=jmFsDQAu2KH9uRNrEkgIfO5dcK49jUUx6zO8wvqR
+GLPI_APP_TOKEN="tmDDtjtMFyiV18RESgAOq59vad13mPGmjHqpguGE"
+GLPI_USER_TOKEN="jmFsDQAu2KH9uRNrEkgIfO5dcK49jUUx6zO8wvqR"
 GLPI_INVENTORY_URL=http://localhost:8080/front/inventory.php
-GLPI_AGENT_TOKEN=jmFsDQAu2KH9uRNrEkgIfO5dcK49jUUx6zO8wvqR
+GLPI_AGENT_TOKEN="jmFsDQAu2KH9uRNrEkgIfO5dcK49jUUx6zO8wvqR"
 GLPI_ENTITY_ID=0
 GLPI_API_URL=http://localhost:8080/apirest.php
 
+#API:  ekTa9gMsrjATdvTyun2AmmAK3tS9Kdd3Y5T3EyIN
+#USER:  tGFGw77xjKGRfAETo0MVS9kNqJl2BlRw5xk5p1Xr
 
-PORT1=3000
-LOCALTUNNEL_SUBDOMAIN=infrawatch
 
diff --git a/.gitignore b/.gitignore
index 0b1d9f5..5f5088c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,4 @@ node_modules
 /src/generated/prisma
 
 # Apenas para desenvolvimento, nao sou ingenuo ne!
-# .env 
-
-./dist
\ No newline at end of file
+# .env 
\ No newline at end of file
diff --git a/dist/Analyzers/HttpIssueAnalyzer.js b/dist/Analyzers/HttpIssueAnalyzer.js
deleted file mode 100644
index 6ed0e39..0000000
--- a/dist/Analyzers/HttpIssueAnalyzer.js
+++ /dev/null
@@ -1,77 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.analyzeHttpIssue = analyzeHttpIssue;
-function analyzeHttpIssue(service, result) {
-    const timestamp = new Date().toISOString();
-    if (!result) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "HTTP",
-            value: 0,
-            status: "DOWN",
-            severity: "CRITICAL",
-            priority: 1,
-            description: "Sem resposta HTTP — destino inacessível.",
-            recommendation: "Verifique se o servidor web está ativo e acessível.",
-            timestamp,
-        };
-    }
-    if (result.status !== "UP") {
-        if (result.httpStatus && result.httpStatus >= 500) {
-            return {
-                serviceId: service.id,
-                serviceName: service.name,
-                metric: "HTTP",
-                value: result.httpStatus,
-                status: "DOWN",
-                severity: "CRITICAL",
-                priority: 1,
-                description: `Erro de servidor HTTP ${result.httpStatus}.`,
-                recommendation: "Verifique logs do servidor e dependências da aplicação.",
-                timestamp,
-            };
-        }
-        if (result.httpStatus && result.httpStatus >= 400) {
-            return {
-                serviceId: service.id,
-                serviceName: service.name,
-                metric: "HTTP",
-                value: result.httpStatus,
-                status: "DOWN",
-                severity: "HIGH",
-                priority: 2,
-                description: `Erro de cliente HTTP ${result.httpStatus}.`,
-                recommendation: "Verifique configuração de autenticação ou endpoint.",
-                timestamp,
-            };
-        }
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "HTTP",
-            value: result.httpStatus ?? 0,
-            status: "DOWN",
-            severity: "WARNING",
-            priority: 3,
-            description: "Resposta HTTP inesperada ou inválida.",
-            recommendation: "Verifique compatibilidade do protocolo ou restrições de acesso.",
-            timestamp,
-        };
-    }
-    if (result.totalMs && result.totalMs > 8000) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "HTTP",
-            value: result.totalMs,
-            status: "UP",
-            severity: "WARNING",
-            priority: 3,
-            description: `Tempo de resposta alto (${result.totalMs}ms).`,
-            recommendation: "Monitorar performance do servidor e verificar gargalos de rede.",
-            timestamp,
-        };
-    }
-    return null;
-}
diff --git a/dist/Analyzers/PingIssueAnalyzer.js b/dist/Analyzers/PingIssueAnalyzer.js
deleted file mode 100644
index e1e7173..0000000
--- a/dist/Analyzers/PingIssueAnalyzer.js
+++ /dev/null
@@ -1,84 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.analyzePingIssue = analyzePingIssue;
-function analyzePingIssue(service, result) {
-    const timestamp = new Date().toISOString();
-    if (!result) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "PING",
-            value: 0,
-            status: "DOWN",
-            severity: "CRITICAL",
-            priority: 1,
-            description: "Sem resposta — pode ser firewall ou host inexistente.",
-            recommendation: "Verifique conectividade de rede e se o host existe.",
-            timestamp,
-        };
-    }
-    if (result.lossPercent === 100) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "PING",
-            value: 100,
-            status: "DOWN",
-            severity: "CRITICAL",
-            priority: 1,
-            description: "Indisponibilidade total — 100% de perda de pacotes.",
-            technicalDetails: formatTechnical(result),
-            recommendation: "Verifique se o host está ativo e se há bloqueio ICMP no firewall.",
-            timestamp,
-        };
-    }
-    if (result.lossPercent >= 50) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "PING",
-            value: result.lossPercent,
-            status: "DOWN",
-            severity: "HIGH",
-            priority: 2,
-            description: "Alta perda de pacotes — rede instável ou congestionada.",
-            technicalDetails: formatTechnical(result),
-            recommendation: "Verifique qualidade do link e possíveis falhas de roteamento.",
-            timestamp,
-        };
-    }
-    if (result.avgMs && result.avgMs > 200) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "PING",
-            value: result.avgMs,
-            status: "DOWN",
-            severity: "HIGH",
-            priority: 2,
-            description: `Latência crítica (${result.avgMs}ms).`,
-            technicalDetails: formatTechnical(result),
-            recommendation: "Verifique saturação de banda ou problemas no provedor.",
-            timestamp,
-        };
-    }
-    if (result.status !== "UP") {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "PING",
-            value: result.lossPercent,
-            status: "DOWN",
-            severity: "WARNING",
-            priority: 3,
-            description: "Host respondeu de forma inesperada ao PING.",
-            technicalDetails: formatTechnical(result),
-            recommendation: "Verifique configuração IPv4/IPv6 ou regras de firewall.",
-            timestamp,
-        };
-    }
-    return null;
-}
-function formatTechnical(result) {
-    return `Status: ${result.status}, perda: ${result.lossPercent}%, min/avg/max/mdev: ${result.minMs}/${result.avgMs}/${result.maxMs}/${result.mdevMs}`;
-}
diff --git a/dist/Analyzers/analyzeSnmpIssue.js b/dist/Analyzers/analyzeSnmpIssue.js
deleted file mode 100644
index e247b9d..0000000
--- a/dist/Analyzers/analyzeSnmpIssue.js
+++ /dev/null
@@ -1,135 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.analyzeSnmpIssue = analyzeSnmpIssue;
-const redis_1 = require("./redis");
-async function analyzeSnmpIssue(service, result) {
-    const timestamp = new Date().toISOString();
-    if (!result) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: 0,
-            status: "DOWN",
-            severity: "CRITICAL",
-            priority: 1,
-            description: "Sem resposta SNMP — dispositivo inacessível.",
-            recommendation: "Verifique conectividade de rede, versão SNMP e credenciais de acesso.",
-            timestamp,
-        };
-    }
-    if (result.error) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: 0,
-            status: "DOWN",
-            severity: "HIGH",
-            priority: 2,
-            description: `Erro SNMP: ${result.error}`,
-            recommendation: "Verifique a configuração SNMP no dispositivo e permissões da comunidade/usuário.",
-            timestamp,
-        };
-    }
-    if (!result.sysName) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: 0,
-            status: "DOWN",
-            severity: "CRITICAL",
-            priority: 1,
-            description: "SNMP respondeu mas não retornou informações básicas.",
-            recommendation: "Verifique OIDs consultados e compatibilidade com o dispositivo.",
-            timestamp,
-        };
-    }
-    if (result.uptime && result.uptime < 300) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: result.uptime,
-            status: "UP",
-            severity: "WARNING",
-            priority: 3,
-            description: `Dispositivo SNMP foi reiniciado recentemente (uptime: ${result.uptime}s).`,
-            recommendation: "Verifique logs do dispositivo para entender causa do reboot.",
-            timestamp,
-        };
-    }
-    if (result.cpuLoad5min && parseFloat(result.cpuLoad5min) > 80) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: parseFloat(result.cpuLoad5min),
-            status: "UP",
-            severity: "HIGH",
-            priority: 2,
-            description: `Uso de CPU elevado: ${result.cpuLoad5min}% nos últimos 5 minutos.`,
-            recommendation: "Verifique processos e carga no dispositivo.",
-            timestamp,
-        };
-    }
-    if (result.memFree && parseFloat(result.memFree) < 50) {
-        return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: parseFloat(result.memFree),
-            status: "UP",
-            severity: "HIGH",
-            priority: 2,
-            description: `Memória livre baixa: ${result.memFree} MB.`,
-            recommendation: "Considere aumentar a memória ou reduzir a carga no dispositivo.",
-            timestamp,
-        };
-    }
-    if (result.interfaces) {
-        for (const iface of result.interfaces) {
-            if (!iface.ip)
-                continue;
-            if (["Vlan", "Loopback", "Test", "Dummy"].some((p) => iface.name.startsWith(p))) {
-                continue;
-            }
-            const key = `interfaceStatus:${service.id}:${iface.name}`;
-            const prevStatus = await redis_1.redis.get(key);
-            const currentStatus = iface.operStatus;
-            if (prevStatus !== currentStatus) {
-                await redis_1.redis.set(key, currentStatus, "EX", 60 * 60 * 24);
-                if (currentStatus === "down") {
-                    return {
-                        serviceId: service.id,
-                        serviceName: service.name,
-                        metric: "SNMP",
-                        value: 0,
-                        status: "DOWN",
-                        severity: "CRITICAL",
-                        priority: 1,
-                        description: `Interface ${iface.name} caiu (estava UP antes).`,
-                        recommendation: "Verifique cabeamento ou configuração.",
-                        timestamp,
-                    };
-                }
-                else if (currentStatus === "up" && prevStatus === "down") {
-                    return {
-                        serviceId: service.id,
-                        serviceName: service.name,
-                        metric: "SNMP",
-                        value: 1,
-                        status: "UP",
-                        severity: "INFO",
-                        priority: 4,
-                        description: `Interface ${iface.name} voltou para UP.`,
-                        recommendation: "Normalizado.",
-                        timestamp,
-                    };
-                }
-            }
-        }
-    }
-    return null;
-}
diff --git a/dist/Analyzers/redis.js b/dist/Analyzers/redis.js
deleted file mode 100644
index c1f0081..0000000
--- a/dist/Analyzers/redis.js
+++ /dev/null
@@ -1,12 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.redis = void 0;
-const redis_1 = require("../Monitoring/Queue/redis");
-const ioredis_1 = __importDefault(require("ioredis"));
-if (!redis_1.redisConnection.url) {
-    throw new Error("Redis connection URL is not defined");
-}
-exports.redis = new ioredis_1.default(redis_1.redisConnection.url);
diff --git a/dist/Controllers/APIs/addServices.js b/dist/Controllers/APIs/addServices.js
deleted file mode 100644
index 4038006..0000000
--- a/dist/Controllers/APIs/addServices.js
+++ /dev/null
@@ -1,46 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.addService = addService;
-const client_1 = require("@prisma/client");
-async function addService(request, reply) {
-    const { ownerId } = request.params;
-    const { name, type, target } = request.body;
-    console.log(ownerId);
-    const service = await request.server.prisma.service.create({
-        data: { name, type, target, ownerId }
-    });
-    await createDefaultSLIsForService(service.id, type, request.server.prisma);
-    return reply.code(201).send(service);
-}
-async function createDefaultSLIsForService(serviceId, type, prisma) {
-    const defaultSLIs = [];
-    switch (type) {
-        case client_1.ServiceType.PING:
-            defaultSLIs.push({
-                serviceId,
-                metric: 'PING',
-                threshold: 98,
-                comparison: 'gte',
-            });
-            break;
-        case client_1.ServiceType.HTTP:
-            defaultSLIs.push({
-                serviceId,
-                metric: 'HTTP',
-                threshold: 98,
-                comparison: 'gte',
-            });
-            break;
-        case client_1.ServiceType.SNMP:
-            defaultSLIs.push({
-                serviceId,
-                metric: 'SNMP',
-                threshold: 95,
-                comparison: 'gte',
-            });
-            break;
-    }
-    for (const sli of defaultSLIs) {
-        await prisma.sliTarget.create({ data: sli });
-    }
-}
diff --git a/dist/Controllers/APIs/alertContact.js b/dist/Controllers/APIs/alertContact.js
deleted file mode 100644
index 39a6693..0000000
--- a/dist/Controllers/APIs/alertContact.js
+++ /dev/null
@@ -1,64 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.AlertContactController = void 0;
-const client_1 = require("@prisma/client");
-const prisma = new client_1.PrismaClient();
-class AlertContactController {
-    async create(req, reply) {
-        const { serviceId, channel, to } = req.body;
-        if (!serviceId || !channel || !to) {
-            return reply.status(400).send({ message: 'Campos obrigatórios ausentes.' });
-        }
-        try {
-            const contact = await prisma.alertContact.create({
-                data: { serviceId, channel, to },
-            });
-            return reply.status(201).send(contact);
-        }
-        catch (err) {
-            console.error(err);
-            return reply.status(500).send({ message: 'Erro ao criar contato.' });
-        }
-    }
-    async list(req, reply) {
-        const { serviceId } = req.params;
-        try {
-            const contacts = await prisma.alertContact.findMany({
-                where: { serviceId },
-            });
-            return reply.send(contacts);
-        }
-        catch (err) {
-            console.error(err);
-            return reply.status(500).send({ message: 'Erro ao buscar contatos.' });
-        }
-    }
-    // Atualizar um contato
-    async update(req, reply) {
-        const { id } = req.params;
-        const { channel, to, active } = req.body;
-        try {
-            const contact = await prisma.alertContact.update({
-                where: { id },
-                data: { channel, to, active },
-            });
-            return reply.send(contact);
-        }
-        catch (err) {
-            console.error(err);
-            return reply.status(500).send({ message: 'Erro ao atualizar contato.' });
-        }
-    }
-    async delete(req, reply) {
-        const { id } = req.params;
-        try {
-            await prisma.alertContact.delete({ where: { id } });
-            return reply.send({ message: 'Contato removido com sucesso.' });
-        }
-        catch (err) {
-            console.error(err);
-            return reply.status(500).send({ message: 'Erro ao remover contato.' });
-        }
-    }
-}
-exports.AlertContactController = AlertContactController;
diff --git a/dist/Controllers/APIs/deleteServices.js b/dist/Controllers/APIs/deleteServices.js
deleted file mode 100644
index ca76d72..0000000
--- a/dist/Controllers/APIs/deleteServices.js
+++ /dev/null
@@ -1,26 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.deleteService = deleteService;
-async function deleteService(request, reply) {
-    const { ownerId, serviceId } = request.params;
-    try {
-        const existingService = await request.server.prisma.service.findUnique({
-            where: { id: serviceId },
-        });
-        if (!existingService || existingService.ownerId !== ownerId) {
-            return reply
-                .code(404)
-                .send({ message: 'Serviço não encontrado ou não pertence a este usuário.' });
-        }
-        const deletedService = await request.server.prisma.service.delete({
-            where: { id: serviceId },
-        });
-        return reply.code(200).send(deletedService);
-    }
-    catch (error) {
-        console.error('Erro ao deletar serviço:', error);
-        return reply.code(500).send({
-            message: 'Erro interno ao tentar deletar o serviço.',
-        });
-    }
-}
diff --git a/dist/Controllers/APIs/serviceMetrics.js b/dist/Controllers/APIs/serviceMetrics.js
deleted file mode 100644
index 3bb1ca8..0000000
--- a/dist/Controllers/APIs/serviceMetrics.js
+++ /dev/null
@@ -1,184 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.queryMetrics = queryMetrics;
-exports.getPingMetrics = getPingMetrics;
-exports.getSnmpMetrics = getSnmpMetrics;
-exports.getHttpMetrics = getHttpMetrics;
-exports.getWebhookMetrics = getWebhookMetrics;
-const influxdb_1 = require("../../Influxdb/influxdb");
-async function queryMetrics(serviceId, measurement) {
-    const query = `
-    from(bucket: "${process.env.INFLUX_BUCKET}")
-      |> range(start: -1m)
-      |> filter(fn: (r) => r._measurement == "${measurement}" and r.serviceId == "${serviceId}")
-      |> pivot(rowKey:["_time"], columnKey: ["_field"], valueColumn: "_value")
-      |> sort(columns: ["_time"])
-  `;
-    try {
-        const rows = await influxdb_1.queryApi.collectRows(query);
-        return rows;
-    }
-    catch (error) {
-        throw new Error(`Erro na consulta InfluxDB: ${error.message}`);
-    }
-}
-async function getPingMetrics(serviceId) {
-    try {
-        const rows = await queryMetrics(serviceId, 'ping_metrics');
-        return rows.map((row) => {
-            const transmitted = row.packets_transmitted || 0;
-            const received = row.packets_received || 0;
-            const loss = row.percent_packet_loss || 0;
-            const min = row.minimum_response_ms || 0;
-            const max = row.maximum_response_ms || 0;
-            const avg = row.average_response_ms || 0;
-            const mdev = row.standard_deviation_ms || 0;
-            const status = row.status || (received > 0 ? 'UP' : 'DOWN');
-            return {
-                time: row._time,
-                serviceId,
-                packets_transmitted: transmitted,
-                packets_received: received,
-                percent_packet_loss: loss,
-                minimum_response_ms: min,
-                maximum_response_ms: max,
-                average_response_ms: avg,
-                standard_deviation_ms: mdev,
-                ttl: row.ttl || null,
-                status,
-            };
-        });
-    }
-    catch (error) {
-        throw error;
-    }
-}
-async function getSnmpMetrics(serviceId) {
-    try {
-        const systemRows = await queryMetrics(serviceId, "snmp_system");
-        const system = systemRows.map((row) => ({
-            time: row._time,
-            sysName: row.sysName || "unknown",
-            sysDescr: row.sysDescr || "N/A",
-            sysUpTime: row.sysUpTime || "N/A",
-            cpuLoad5sec: row.cpuLoad5sec || 0,
-            cpuLoad5min: row.cpuLoad5min || 0,
-            memFreeBytes: row.memFreeBytes || 0,
-            memTotalBytes: row.memTotalBytes || 0,
-            memUsedPercent: row.memUsedPercent || 0,
-        }));
-        const ifaceRows = await queryMetrics(serviceId, "snmp_interface");
-        const interfaces = ifaceRows.map((row) => ({
-            time: row._time,
-            ifIndex: row.ifIndex,
-            ifName: row.ifName,
-            ifType: row.ifType,
-            adminStatus: row.adminStatus,
-            operStatus: row.operStatus,
-            mac: row.mac,
-            speedBps: row.speedBps || 0,
-            inBytes: row.inBytes || 0,
-            outBytes: row.outBytes || 0,
-            inErrors: row.inErrors || 0,
-            outErrors: row.outErrors || 0,
-            ip: row.ipAddress || null,
-        }));
-        const summaryRows = await queryMetrics(serviceId, "snmp_summary");
-        const summary = summaryRows.map((row) => ({
-            time: row._time,
-            totalInterfaces: row.totalInterfaces || 0,
-            interfacesUp: row.interfacesUp || 0,
-            interfacesDown: row.interfacesDown || 0,
-            totalInBytes: row.totalInBytes || 0,
-            totalOutBytes: row.totalOutBytes || 0,
-            totalErrors: row.totalErrors || 0,
-        }));
-        const sensorRows = await queryMetrics(serviceId, "snmp_sensor");
-        const sensors = {
-            temperature: [],
-            fanStatus: [],
-            psuStatus: [],
-            powerDraw: [],
-        };
-        for (const row of sensorRows) {
-            switch (row.type) {
-                case "temperature":
-                    sensors.temperature.push({
-                        time: row._time,
-                        index: row.index,
-                        value: row.value,
-                    });
-                    break;
-                case "fan":
-                    sensors.fanStatus.push({
-                        time: row._time,
-                        index: row.index,
-                        status: row.status,
-                    });
-                    break;
-                case "psu":
-                    sensors.psuStatus.push({
-                        time: row._time,
-                        index: row.index,
-                        status: row.status,
-                    });
-                    break;
-                case "power":
-                    sensors.powerDraw.push({
-                        time: row._time,
-                        index: row.index,
-                        watts: row.watts,
-                    });
-                    break;
-            }
-        }
-        return { system, interfaces, summary, sensors };
-    }
-    catch (error) {
-        throw error;
-    }
-}
-async function getHttpMetrics(serviceId) {
-    try {
-        const rows = await queryMetrics(serviceId, 'http_metrics');
-        return rows.map((row) => ({
-            time: row._time,
-            status: row.status || 'unknown',
-            httpStatus: row.httpStatus || 0,
-            ip: row.ip || '',
-            sizeBytes: row.sizeBytes || 0,
-            dnsMs: row.dnsMs || 0,
-            connectAndDownloadMs: row.connectAndDownloadMs || 0,
-            totalMs: row.totalMs || 0,
-            headers: row.headers
-                ? (typeof row.headers === 'string'
-                    ? JSON.parse(row.headers)
-                    : row.headers)
-                : {},
-        }));
-    }
-    catch (error) {
-        throw new Error(`Erro ao buscar métricas HTTP: ${error.message}`);
-    }
-}
-async function getWebhookMetrics(serviceId) {
-    try {
-        const rows = await queryMetrics(serviceId, 'webhook_metrics');
-        return rows.map((row) => ({
-            time: row._time,
-            status: row.status || 'unknown',
-            httpStatus: row.httpStatus || 0,
-            ip: row.ip || null,
-            sizeBytes: row.sizeBytes || 0,
-            dnsMs: row.dnsMs || 0,
-            connectAndDownloadMs: row.connectAndDownloadMs || 0,
-            totalMs: row.totalMs || 0,
-            headers: row.headers || {},
-            payloadSent: row.payloadSent || null,
-            responseBody: row.responseBody || null,
-        }));
-    }
-    catch (error) {
-        throw error;
-    }
-}
diff --git a/dist/Controllers/APIs/services.js b/dist/Controllers/APIs/services.js
deleted file mode 100644
index e5afa5b..0000000
--- a/dist/Controllers/APIs/services.js
+++ /dev/null
@@ -1,10 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.getAllServices = getAllServices;
-const client_1 = require("@prisma/client");
-const prisma = new client_1.PrismaClient();
-async function getAllServices() {
-    return prisma.service.findMany({
-        select: { id: true, name: true, type: true, target: true, }
-    });
-}
diff --git a/dist/Influxdb/WriteMetrics/WriteHttpMetrics.js b/dist/Influxdb/WriteMetrics/WriteHttpMetrics.js
deleted file mode 100644
index ecd75b7..0000000
--- a/dist/Influxdb/WriteMetrics/WriteHttpMetrics.js
+++ /dev/null
@@ -1,29 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.writeHttpMetrics = writeHttpMetrics;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const influxdb_1 = require("../influxdb");
-function writeHttpMetrics(serviceId, data) {
-    const point = new influxdb_client_1.Point("http_metrics")
-        .tag("serviceId", serviceId)
-        .stringField("status", data.status ?? "")
-        .intField("httpStatus", data.httpStatus ?? 0)
-        .stringField("ip", data.ip ?? "")
-        .intField("sizeBytes", data.sizeBytes ?? 0)
-        .floatField("dnsMs", data.dnsMs ?? 0)
-        .floatField("connectAndDownloadMs", data.connectAndDownloadMs ?? 0)
-        .floatField("totalMs", data.totalMs ?? 0)
-        .timestamp(new Date());
-    if (data.headers) {
-        Object.entries(data.headers).forEach(([key, value]) => {
-            const headerPoint = new influxdb_client_1.Point("service_http_header")
-                .tag("serviceId", serviceId)
-                .tag("header", key)
-                .stringField("value", String(value))
-                .timestamp(new Date());
-            influxdb_1.writeApi.writePoint(headerPoint);
-        });
-    }
-    influxdb_1.writeApi.writePoint(point);
-    influxdb_1.writeApi.flush();
-}
diff --git a/dist/Influxdb/WriteMetrics/WriteMetric.js b/dist/Influxdb/WriteMetrics/WriteMetric.js
deleted file mode 100644
index fcc5fb2..0000000
--- a/dist/Influxdb/WriteMetrics/WriteMetric.js
+++ /dev/null
@@ -1,13 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.writeMetric = writeMetric;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const influxdb_1 = require("../influxdb");
-function writeMetric(serviceId, status) {
-    const point = new influxdb_client_1.Point('service_status')
-        .tag('serviceId', serviceId)
-        .stringField('status', status)
-        .timestamp(new Date());
-    influxdb_1.writeApi.writePoint(point);
-    influxdb_1.writeApi.flush();
-}
diff --git a/dist/Influxdb/WriteMetrics/WritePingMetrics.js b/dist/Influxdb/WriteMetrics/WritePingMetrics.js
deleted file mode 100644
index a775129..0000000
--- a/dist/Influxdb/WriteMetrics/WritePingMetrics.js
+++ /dev/null
@@ -1,21 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.writePingMetrics = writePingMetrics;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const influxdb_1 = require("../influxdb");
-function writePingMetrics(serviceId, metrics) {
-    const point = new influxdb_client_1.Point('ping_metrics')
-        .tag('serviceId', serviceId)
-        .floatField('percent_packet_loss', metrics.percent_packet_loss)
-        .floatField('minimum_response_ms', metrics.minimum_response_ms)
-        .floatField('maximum_response_ms', metrics.maximum_response_ms)
-        .floatField('average_response_ms', metrics.average_response_ms)
-        .floatField('standard_deviation_ms', metrics.standard_deviation_ms)
-        .intField('packets_transmitted', metrics.packets_transmitted)
-        .intField('packets_received', metrics.packets_received)
-        .intField('result_code', metrics.result_code ?? 0)
-        .intField('ttl', metrics.ttl ?? 0)
-        .stringField('status', metrics.status);
-    influxdb_1.writeApi.writePoint(point);
-    influxdb_1.writeApi.flush();
-}
diff --git a/dist/Influxdb/WriteMetrics/WriteServiceStatus.js b/dist/Influxdb/WriteMetrics/WriteServiceStatus.js
deleted file mode 100644
index 64bc483..0000000
--- a/dist/Influxdb/WriteMetrics/WriteServiceStatus.js
+++ /dev/null
@@ -1,48 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.writeServiceStatus = writeServiceStatus;
-exports.countRecentUps = countRecentUps;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const influxdb_1 = require("../../Influxdb/influxdb");
-const influxdb_2 = require("../influxdb");
-async function writeServiceStatus(params) {
-    const { serviceId, status, latency } = params;
-    influxdb_2.writeApi.useDefaultTags({ serviceId });
-    const point = new influxdb_client_1.Point("service_status")
-        .tag("serviceId", serviceId)
-        .stringField("status", status)
-        .booleanField("isUp", status === "UP")
-        .timestamp(new Date());
-    if (latency !== undefined) {
-        point.floatField("latency_ms", latency);
-    }
-    influxdb_2.writeApi.writePoint(point);
-    try {
-        await influxdb_2.writeApi.flush();
-    }
-    catch (err) {
-        console.error("Erro ao gravar status no Influx:", err);
-    }
-}
-async function countRecentUps(serviceId, minutes) {
-    const fluxQuery = `
-    from(bucket: "${process.env.INFLUX_BUCKET}")
-      |> range(start: -${minutes}m)
-      |> filter(fn: (r) => r._measurement == "service_status")
-      |> filter(fn: (r) => r.serviceId == "${serviceId}")
-      |> filter(fn: (r) => r._field == "isUp")
-      |> filter(fn: (r) => r._value == true)
-      |> count()
-  `;
-    return new Promise((resolve, reject) => {
-        let count = 0;
-        influxdb_1.queryApi.queryRows(fluxQuery, {
-            next: (row, tableMeta) => {
-                const o = tableMeta.toObject(row);
-                count = o._value;
-            },
-            error: reject,
-            complete: () => resolve(count),
-        });
-    });
-}
diff --git a/dist/Influxdb/WriteMetrics/WriteSlaRecord.js b/dist/Influxdb/WriteMetrics/WriteSlaRecord.js
deleted file mode 100644
index 3a81a32..0000000
--- a/dist/Influxdb/WriteMetrics/WriteSlaRecord.js
+++ /dev/null
@@ -1,17 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.writeSlaRecordToInflux = writeSlaRecordToInflux;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const influxdb_1 = require("../influxdb");
-async function writeSlaRecordToInflux(slaRecord) {
-    const point = new influxdb_client_1.Point('sla_records')
-        .tag('serviceId', slaRecord.serviceId)
-        .tag('serviceName', slaRecord.serviceName)
-        .tag('metric', slaRecord.metric)
-        .tag('criticality', slaRecord.criticality)
-        .floatField('value', slaRecord.value)
-        .intField('status', slaRecord.status ? 1 : 0)
-        .timestamp(new Date());
-    influxdb_1.writeApi.writePoint(point);
-    await influxdb_1.writeApi.flush();
-}
diff --git a/dist/Influxdb/WriteMetrics/WriteSnmpMetrics.js b/dist/Influxdb/WriteMetrics/WriteSnmpMetrics.js
deleted file mode 100644
index b6575ad..0000000
--- a/dist/Influxdb/WriteMetrics/WriteSnmpMetrics.js
+++ /dev/null
@@ -1,249 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.writeSnmpMetrics = writeSnmpMetrics;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const influxdb_1 = require("../influxdb");
-async function writeSnmpMetrics(serviceId, data) {
-    const points = [];
-    const systemPoint = new influxdb_client_1.Point("snmp_system")
-        .tag("serviceId", serviceId)
-        .tag("ip", data.ip)
-        .tag("sysName", data.sysName || "unknown")
-        .stringField("sysDescr", data.metrics.sysDescr || "N/A")
-        .stringField("sysUpTime", data.metrics.sysUpTime || "N/A");
-    if (data.metrics.cpuLoad5min && data.metrics.cpuLoad5min !== "N/A") {
-        const cpuValue = parseFloat(data.metrics.cpuLoad5min);
-        if (!isNaN(cpuValue)) {
-            systemPoint.floatField("cpuLoad5min", cpuValue);
-        }
-    }
-    if (data.metrics.memFree && data.metrics.memFree !== "N/A") {
-        systemPoint.stringField("memFree", data.metrics.memFree);
-        const memFreeMatch = data.metrics.memFree.match(/^([\d.]+)\s*(\w+)/);
-        if (memFreeMatch) {
-            const value = parseFloat(memFreeMatch[1]);
-            const unit = memFreeMatch[2];
-            const bytesValue = convertToBytes(value, unit);
-            if (bytesValue !== null) {
-                systemPoint.intField("memFreeBytes", bytesValue);
-            }
-        }
-    }
-    if (data.metrics.memTotal && data.metrics.memTotal !== "N/A") {
-        systemPoint.stringField("memTotal", data.metrics.memTotal);
-        const memTotalMatch = data.metrics.memTotal.match(/^([\d.]+)\s*(\w+)/);
-        if (memTotalMatch) {
-            const value = parseFloat(memTotalMatch[1]);
-            const unit = memTotalMatch[2];
-            const bytesValue = convertToBytes(value, unit);
-            if (bytesValue !== null) {
-                systemPoint.intField("memTotalBytes", bytesValue);
-                const memFreeBytes = systemPoint.fields["memFreeBytes"];
-                if (memFreeBytes && typeof memFreeBytes === "number") {
-                    const usedPercent = ((bytesValue - memFreeBytes) / bytesValue) * 100;
-                    systemPoint.floatField("memUsedPercent", usedPercent);
-                }
-            }
-        }
-    }
-    systemPoint.timestamp(new Date(data.timestamp));
-    points.push(systemPoint);
-    if (data.interfaces && Array.isArray(data.interfaces)) {
-        for (const iface of data.interfaces) {
-            const ifacePoint = new influxdb_client_1.Point("snmp_interface")
-                .tag("serviceId", serviceId)
-                .tag("ip", data.ip)
-                .tag("sysName", data.sysName || "unknown")
-                .tag("ifIndex", String(iface.index))
-                .tag("ifName", iface.name || "unknown")
-                .tag("ifType", iface.type || "unknown")
-                .tag("adminStatus", iface.adminStatus || "unknown")
-                .tag("operStatus", iface.operStatus || "unknown");
-            if (iface.mac && iface.mac !== "N/A") {
-                ifacePoint.stringField("mac", iface.mac);
-            }
-            if (iface.ip) {
-                ifacePoint.stringField("ipAddress", iface.ip);
-            }
-            if (iface.speed && iface.speed !== "N/A") {
-                ifacePoint.stringField("speed", iface.speed);
-                const speedBps = parseSpeed(iface.speed);
-                if (speedBps !== null) {
-                    ifacePoint.intField("speedBps", speedBps);
-                }
-            }
-            if (iface.inOctets && iface.inOctets !== "N/A") {
-                ifacePoint.stringField("inOctets", iface.inOctets);
-                const inBytes = parseBytes(iface.inOctets);
-                if (inBytes !== null) {
-                    ifacePoint.intField("inBytes", inBytes);
-                }
-            }
-            if (iface.outOctets && iface.outOctets !== "N/A") {
-                ifacePoint.stringField("outOctets", iface.outOctets);
-                const outBytes = parseBytes(iface.outOctets);
-                if (outBytes !== null) {
-                    ifacePoint.intField("outBytes", outBytes);
-                }
-            }
-            if (iface.inErrors && iface.inErrors !== "N/A") {
-                const inErrors = parseInt(iface.inErrors);
-                if (!isNaN(inErrors)) {
-                    ifacePoint.intField("inErrors", inErrors);
-                }
-            }
-            if (iface.outErrors && iface.outErrors !== "N/A") {
-                const outErrors = parseInt(iface.outErrors);
-                if (!isNaN(outErrors)) {
-                    ifacePoint.intField("outErrors", outErrors);
-                }
-            }
-            ifacePoint.timestamp(new Date(data.timestamp));
-            points.push(ifacePoint);
-        }
-    }
-    const summaryPoint = new influxdb_client_1.Point("snmp_summary")
-        .tag("serviceId", serviceId)
-        .tag("ip", data.ip)
-        .tag("sysName", data.sysName || "unknown")
-        .intField("totalInterfaces", data.interfaces?.length || 0)
-        .intField("interfacesUp", data.interfaces?.filter((i) => i.operStatus === "up").length || 0)
-        .intField("interfacesDown", data.interfaces?.filter((i) => i.operStatus === "down").length || 0)
-        .timestamp(new Date(data.timestamp));
-    if (data.interfaces && Array.isArray(data.interfaces)) {
-        let totalInBytes = 0;
-        let totalOutBytes = 0;
-        let totalErrors = 0;
-        for (const iface of data.interfaces) {
-            if (iface.operStatus === "up") {
-                const inBytes = parseBytes(iface.inOctets);
-                const outBytes = parseBytes(iface.outOctets);
-                if (inBytes !== null)
-                    totalInBytes += inBytes;
-                if (outBytes !== null)
-                    totalOutBytes += outBytes;
-                if (iface.inErrors && iface.inErrors !== "N/A") {
-                    totalErrors += parseInt(iface.inErrors) || 0;
-                }
-                if (iface.outErrors && iface.outErrors !== "N/A") {
-                    totalErrors += parseInt(iface.outErrors) || 0;
-                }
-            }
-        }
-        summaryPoint
-            .intField("totalInBytes", totalInBytes)
-            .intField("totalOutBytes", totalOutBytes)
-            .intField("totalErrors", totalErrors);
-    }
-    points.push(summaryPoint);
-    if (Array.isArray(data.metrics.temperature)) {
-        data.metrics.temperature.forEach((temp, idx) => {
-            const value = parseFloat(temp);
-            if (!isNaN(value)) {
-                points.push(new influxdb_client_1.Point("snmp_sensor")
-                    .tag("serviceId", serviceId)
-                    .tag("ip", data.ip)
-                    .tag("sysName", data.sysName || "unknown")
-                    .tag("type", "temperature")
-                    .tag("index", String(idx))
-                    .floatField("value", value)
-                    .timestamp(new Date(data.timestamp)));
-            }
-        });
-    }
-    if (Array.isArray(data.metrics.fanStatus)) {
-        data.metrics.fanStatus.forEach((status, idx) => {
-            points.push(new influxdb_client_1.Point("snmp_sensor")
-                .tag("serviceId", serviceId)
-                .tag("ip", data.ip)
-                .tag("sysName", data.sysName || "unknown")
-                .tag("type", "fan")
-                .tag("index", String(idx))
-                .stringField("status", status)
-                .timestamp(new Date(data.timestamp)));
-        });
-    }
-    if (Array.isArray(data.metrics.psuStatus)) {
-        data.metrics.psuStatus.forEach((status, idx) => {
-            points.push(new influxdb_client_1.Point("snmp_sensor")
-                .tag("serviceId", serviceId)
-                .tag("ip", data.ip)
-                .tag("sysName", data.sysName || "unknown")
-                .tag("type", "psu")
-                .tag("index", String(idx))
-                .stringField("status", status)
-                .timestamp(new Date(data.timestamp)));
-        });
-    }
-    if (Array.isArray(data.metrics.powerDraw)) {
-        data.metrics.powerDraw.forEach((pwr, idx) => {
-            const match = pwr.match(/^([\d.]+)\s*W/i);
-            const value = match ? parseFloat(match[1]) : null;
-            if (value !== null && !isNaN(value)) {
-                points.push(new influxdb_client_1.Point("snmp_sensor")
-                    .tag("serviceId", serviceId)
-                    .tag("ip", data.ip)
-                    .tag("sysName", data.sysName || "unknown")
-                    .tag("type", "power")
-                    .tag("index", String(idx))
-                    .floatField("watts", value)
-                    .timestamp(new Date(data.timestamp)));
-            }
-        });
-    }
-    for (const point of points) {
-        influxdb_1.writeApi.writePoint(point);
-    }
-    await influxdb_1.writeApi.flush();
-}
-function convertToBytes(value, unit) {
-    const units = {
-        B: 1,
-        KB: 1024,
-        MB: 1024 * 1024,
-        GB: 1024 * 1024 * 1024,
-        TB: 1024 * 1024 * 1024 * 1024,
-    };
-    const multiplier = units[unit.toUpperCase()];
-    if (multiplier) {
-        return Math.round(value * multiplier);
-    }
-    return null;
-}
-function parseBytes(bytesStr) {
-    if (!bytesStr || bytesStr === "N/A")
-        return null;
-    const directParse = parseInt(bytesStr);
-    if (!isNaN(directParse))
-        return directParse;
-    const match = bytesStr.match(/^([\d.]+)\s*(\w+)/);
-    if (match) {
-        const value = parseFloat(match[1]);
-        const unit = match[2];
-        return convertToBytes(value, unit);
-    }
-    return null;
-}
-function parseSpeed(speedStr) {
-    if (!speedStr || speedStr === "N/A")
-        return null;
-    const directParse = parseInt(speedStr);
-    if (!isNaN(directParse))
-        return directParse;
-    const match = speedStr.match(/^([\d.]+)\s*(\w+)/);
-    if (match) {
-        const value = parseFloat(match[1]);
-        const unit = match[2].toLowerCase();
-        const multipliers = {
-            bps: 1,
-            kbps: 1000,
-            mbps: 1000000,
-            gbps: 1000000000,
-        };
-        const multiplier = multipliers[unit];
-        if (multiplier) {
-            return Math.round(value * multiplier);
-        }
-    }
-    return null;
-}
diff --git a/dist/Influxdb/influxdb.js b/dist/Influxdb/influxdb.js
deleted file mode 100644
index b19ef28..0000000
--- a/dist/Influxdb/influxdb.js
+++ /dev/null
@@ -1,11 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.queryApi = exports.writeApi = exports.influxDB = exports.org = void 0;
-const influxdb_client_1 = require("@influxdata/influxdb-client");
-const url = process.env.INFLUX_URL;
-const token = process.env.INFLUX_TOKEN;
-exports.org = process.env.INFLUX_ORG;
-const bucket = process.env.INFLUX_BUCKET;
-exports.influxDB = new influxdb_client_1.InfluxDB({ url, token });
-exports.writeApi = exports.influxDB.getWriteApi(exports.org, bucket, 'ms');
-exports.queryApi = exports.influxDB.getQueryApi(exports.org);
diff --git a/dist/Monitoring/Incidents/incidentManager.js b/dist/Monitoring/Incidents/incidentManager.js
deleted file mode 100644
index 833de64..0000000
--- a/dist/Monitoring/Incidents/incidentManager.js
+++ /dev/null
@@ -1,42 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.findOrOpenIncident = findOrOpenIncident;
-exports.closeIncidentIfRecovered = closeIncidentIfRecovered;
-exports.updateIncidentNotification = updateIncidentNotification;
-const client_1 = require("@prisma/client");
-const WriteServiceStatus_1 = require("../../Influxdb/WriteMetrics/WriteServiceStatus");
-const prisma = new client_1.PrismaClient();
-async function findOrOpenIncident(serviceId, reason) {
-    let incident = await prisma.incident.findFirst({
-        where: { serviceId, closedAt: null },
-    });
-    if (!incident) {
-        incident = await prisma.incident.create({
-            data: { serviceId, reason: reason ?? "auto-open" },
-        });
-    }
-    return incident;
-}
-async function closeIncidentIfRecovered(serviceId, recoveryConfirmations) {
-    try {
-        const ups = await (0, WriteServiceStatus_1.countRecentUps)(serviceId, 5);
-        const openIncidents = await prisma.incident.findMany({
-            where: { serviceId, closedAt: null },
-        });
-        if (openIncidents.length > 0 && ups >= recoveryConfirmations) {
-            await prisma.incident.updateMany({
-                where: { serviceId, closedAt: null },
-                data: { closedAt: new Date(), reason: "auto-recovery" },
-            });
-        }
-    }
-    catch (err) {
-        console.error(`Erro ao verificar recuperação do serviço ${serviceId}:`, err);
-    }
-}
-async function updateIncidentNotification(incidentId, retryCount) {
-    await prisma.incident.update({
-        where: { id: incidentId },
-        data: { lastNotificationAt: new Date(), retryCount },
-    });
-}
diff --git a/dist/Monitoring/Queue/jobQueue.js b/dist/Monitoring/Queue/jobQueue.js
deleted file mode 100644
index c0dbd7d..0000000
--- a/dist/Monitoring/Queue/jobQueue.js
+++ /dev/null
@@ -1,15 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.monitoringQueue = void 0;
-exports.enqueueServiceCheck = enqueueServiceCheck;
-const bullmq_1 = require("bullmq");
-const redis_1 = require("./redis");
-exports.monitoringQueue = new bullmq_1.Queue('monitoring', { connection: redis_1.redisConnection });
-async function enqueueServiceCheck(serviceId) {
-    await exports.monitoringQueue.add('check', { serviceId }, {
-        removeOnComplete: 1000,
-        removeOnFail: 500,
-        attempts: 3,
-        backoff: { type: 'exponential', delay: 2000 },
-    });
-}
diff --git a/dist/Monitoring/Queue/monitoringWorker.js b/dist/Monitoring/Queue/monitoringWorker.js
deleted file mode 100644
index c48d4d1..0000000
--- a/dist/Monitoring/Queue/monitoringWorker.js
+++ /dev/null
@@ -1,21 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.monitoringWorker = void 0;
-const bullmq_1 = require("bullmq");
-const redis_1 = require("./redis");
-const slaWorker_1 = require("../Workers/slaWorker");
-exports.monitoringWorker = new bullmq_1.Worker('monitoring', async (job) => {
-    const { serviceId } = job.data;
-    const service = await slaWorker_1.prisma.service.findUnique({
-        where: { id: serviceId },
-        select: { name: true },
-    });
-    await (0, slaWorker_1.processSlaAndAlerts)(serviceId);
-    return { serviceName: service?.name ?? serviceId };
-}, { connection: redis_1.redisConnection, concurrency: 5 });
-exports.monitoringWorker.on('completed', (job, result) => {
-    console.log(`Job ${job.id} concluído para serviço ${result?.serviceName}`);
-});
-exports.monitoringWorker.on('failed', (job, err) => {
-    console.error(`Job ${job?.id} falhou para serviço ${job?.data?.serviceId}:`, err?.message);
-});
diff --git a/dist/Monitoring/Queue/redis.js b/dist/Monitoring/Queue/redis.js
deleted file mode 100644
index 2b9ce5e..0000000
--- a/dist/Monitoring/Queue/redis.js
+++ /dev/null
@@ -1,6 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.redisConnection = void 0;
-exports.redisConnection = {
-    url: process.env.REDIS_URL || 'redis://127.0.0.1:6379',
-};
diff --git a/dist/Monitoring/Queue/scheduler.js b/dist/Monitoring/Queue/scheduler.js
deleted file mode 100644
index 4e2b517..0000000
--- a/dist/Monitoring/Queue/scheduler.js
+++ /dev/null
@@ -1,15 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.startQueueScheduler = startQueueScheduler;
-const client_1 = require("@prisma/client");
-const jobQueue_1 = require("./jobQueue");
-const prisma = new client_1.PrismaClient();
-async function startQueueScheduler() {
-    console.log('Agendador de monitoramento iniciado...');
-    await enqueueAll();
-    setInterval(enqueueAll, 60 * 1000);
-}
-async function enqueueAll() {
-    const services = await prisma.service.findMany({ select: { id: true } });
-    await Promise.all(services.map(s => (0, jobQueue_1.enqueueServiceCheck)(s.id)));
-}
diff --git a/dist/Monitoring/SlaTracking/slaCalculator.js b/dist/Monitoring/SlaTracking/slaCalculator.js
deleted file mode 100644
index 1c78895..0000000
--- a/dist/Monitoring/SlaTracking/slaCalculator.js
+++ /dev/null
@@ -1,149 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.SlaCalculator = void 0;
-exports.inferSampleIntervalMs = inferSampleIntervalMs;
-exports.computeDurations = computeDurations;
-const influxdb_1 = require("../../Influxdb/influxdb");
-function assertEnvBucket() {
-    const bucket = process.env.INFLUX_BUCKET?.trim();
-    if (!bucket)
-        throw new Error("INFLUX_BUCKET não definido.");
-    return bucket;
-}
-function sanitizeServiceId(id) {
-    return id.replace(/"/g, '\\"');
-}
-function isUpValue(v) {
-    if (typeof v === "string") {
-        const s = v.trim().toLowerCase();
-        if (s === "up" || s === "1" || s === "true")
-            return true;
-        if (s === "down" || s === "0" || s === "false")
-            return false;
-        return false;
-    }
-    if (typeof v === "number")
-        return v === 1;
-    if (typeof v === "boolean")
-        return v;
-    return false;
-}
-async function queryRows(flux) {
-    return new Promise((resolve, reject) => {
-        const rows = [];
-        influxdb_1.queryApi.queryRows(flux, {
-            next: (row, tableMeta) => { rows.push(tableMeta.toObject(row)); },
-            error: reject,
-            complete: () => resolve(rows),
-        });
-    });
-}
-function inferSampleIntervalMs(points) {
-    if (points.length < 2)
-        return 300000;
-    const deltas = [];
-    for (let i = 1; i < points.length; i++)
-        deltas.push(points[i].getTime() - points[i - 1].getTime());
-    deltas.sort((a, b) => a - b);
-    const mid = Math.floor(deltas.length / 2);
-    return deltas.length % 2 ? deltas[mid] : Math.floor((deltas[mid - 1] + deltas[mid]) / 2);
-}
-function computeDurations(start, end, rows, lastBefore, inferredMs) {
-    const maxGap = 3 * inferredMs;
-    let upMs = 0, downMs = 0, unknownMs = 0;
-    let prevTime = start;
-    let currState = lastBefore ? lastBefore.state : "UNKNOWN";
-    const addSpan = (ms) => {
-        if (currState === "UP")
-            upMs += ms;
-        else if (currState === "DOWN")
-            downMs += ms;
-        else
-            unknownMs += ms;
-    };
-    for (const r of rows) {
-        const t = r.time;
-        if (t <= prevTime) {
-            currState = r.state;
-            continue;
-        }
-        const dt = t.getTime() - prevTime.getTime();
-        if (dt <= maxGap)
-            addSpan(dt);
-        else {
-            addSpan(maxGap);
-            unknownMs += dt - maxGap;
-        }
-        prevTime = t;
-        currState = r.state;
-    }
-    if (end > prevTime) {
-        const dt = end.getTime() - prevTime.getTime();
-        if (dt <= maxGap)
-            addSpan(dt);
-        else {
-            addSpan(maxGap);
-            unknownMs += dt - maxGap;
-        }
-    }
-    const denom = upMs + downMs;
-    const pctByTime = denom > 0 ? (upMs / denom) * 100 : null;
-    return { upDurationMs: upMs, downDurationMs: downMs, unknownDurationMs: unknownMs, uptimePercentageByTime: pctByTime };
-}
-class SlaCalculator {
-    static async calculate(serviceId, start, end) {
-        if (!(start instanceof Date) || isNaN(start.getTime()))
-            throw new Error("Parâmetro 'start' inválido.");
-        if (!(end instanceof Date) || isNaN(end.getTime()))
-            throw new Error("Parâmetro 'end' inválido.");
-        if (start >= end)
-            throw new Error("Intervalo inválido: 'start' deve ser anterior a 'end'.");
-        const bucket = assertEnvBucket();
-        const sid = sanitizeServiceId(serviceId);
-        const startIso = start.toISOString();
-        const endIso = end.toISOString();
-        const fluxRange = `
-      from(bucket: "${bucket}")
-        |> range(start: ${startIso}, stop: ${endIso})
-        |> filter(fn: (r) => r._measurement == "service_status")
-        |> filter(fn: (r) => r._field == "status")
-        |> filter(fn: (r) => r.serviceId == "${sid}")
-        |> keep(columns: ["_time", "_value"])
-        |> sort(columns: ["_time"], desc: false)
-    `;
-        const rowsRange = await queryRows(fluxRange);
-        const points = rowsRange.map(r => ({ time: new Date(r._time), state: isUpValue(r._value) ? "UP" : "DOWN" }));
-        const fluxLastBefore = `
-      from(bucket: "${bucket}")
-        |> range(start: ${new Date(0).toISOString()}, stop: ${startIso})
-        |> filter(fn: (r) => r._measurement == "service_status")
-        |> filter(fn: (r) => r._field == "status")
-        |> filter(fn: (r) => r.serviceId == "${sid}")
-        |> keep(columns: ["_time", "_value"])
-        |> last()
-    `;
-        const lastRows = await queryRows(fluxLastBefore);
-        const lastBefore = lastRows.length ? { time: new Date(lastRows[0]._time), state: isUpValue(lastRows[0]._value) ? "UP" : "DOWN" } : null;
-        const totalChecks = rowsRange.length;
-        const upChecks = rowsRange.filter(r => isUpValue(r._value)).length;
-        const downChecks = totalChecks - upChecks;
-        const uptimePercentage = totalChecks > 0 ? (upChecks / totalChecks) * 100 : null;
-        const inferredSampleIntervalMs = inferSampleIntervalMs(points.map(p => p.time));
-        const byTime = computeDurations(start, end, points, lastBefore, inferredSampleIntervalMs);
-        return {
-            serviceId,
-            start,
-            end,
-            totalChecks,
-            upChecks,
-            downChecks,
-            uptimePercentage,
-            upDurationMs: byTime.upDurationMs,
-            downDurationMs: byTime.downDurationMs,
-            unknownDurationMs: byTime.unknownDurationMs,
-            uptimePercentageByTime: byTime.uptimePercentageByTime,
-            inferredSampleIntervalMs,
-        };
-    }
-}
-exports.SlaCalculator = SlaCalculator;
diff --git a/dist/Monitoring/SlaTracking/slaReportGenerator.js b/dist/Monitoring/SlaTracking/slaReportGenerator.js
deleted file mode 100644
index 908e1d2..0000000
--- a/dist/Monitoring/SlaTracking/slaReportGenerator.js
+++ /dev/null
@@ -1,50 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.SlaReportGenerator = void 0;
-const pdfkit_1 = __importDefault(require("pdfkit"));
-class SlaReportGenerator {
-    static async generatePDF(serviceName, sla, start, end) {
-        return new Promise((resolve, reject) => {
-            const doc = new pdfkit_1.default({ margin: 50 });
-            const buffers = [];
-            doc.on("data", buffers.push.bind(buffers));
-            doc.on("end", () => resolve(Buffer.concat(buffers)));
-            doc.on("error", reject);
-            doc.fontSize(20).text(`Relatório de SLA - ${serviceName}`, { align: "center" });
-            doc.moveDown();
-            doc.fontSize(12).text(`Período: ${start.toISOString()}  —  ${end.toISOString()} (UTC)`);
-            doc.moveDown();
-            const uptimeSamples = sla.uptimePercentage == null ? "Sem dados" : `${sla.uptimePercentage.toFixed(2)}%`;
-            doc.fontSize(12).list([
-                `Total de checks: ${sla.totalChecks}`,
-                `Checks UP: ${sla.upChecks}`,
-                `Checks DOWN: ${sla.downChecks}`,
-                `Uptime (por amostras): ${uptimeSamples}`,
-            ]);
-            doc.moveDown();
-            if (typeof sla.uptimePercentageByTime === "number") {
-                doc.fontSize(11).text(`Uptime (por tempo, excl. "desconhecido"): ${sla.uptimePercentageByTime.toFixed(2)}%`);
-                doc.moveDown(0.5);
-            }
-            if (typeof sla.upDurationMs === "number" &&
-                typeof sla.downDurationMs === "number" &&
-                typeof sla.unknownDurationMs === "number") {
-                const fmt = (ms) => {
-                    const s = Math.floor(ms / 1000);
-                    const h = Math.floor(s / 3600);
-                    const m = Math.floor((s % 3600) / 60);
-                    const ss = s % 60;
-                    return `${h}h ${m}m ${ss}s`;
-                };
-                doc.fontSize(10).fillColor("gray").text(`Duração UP: ${fmt(sla.upDurationMs)}  •  Duração DOWN: ${fmt(sla.downDurationMs)}  •  Desconhecido: ${fmt(sla.unknownDurationMs)}`);
-                doc.moveDown();
-            }
-            doc.fontSize(10).fillColor("gray").text("Gerado automaticamente pelo sistema de monitorização.");
-            doc.end();
-        });
-    }
-}
-exports.SlaReportGenerator = SlaReportGenerator;
diff --git a/dist/Monitoring/SlaTracking/slaService.js b/dist/Monitoring/SlaTracking/slaService.js
deleted file mode 100644
index 3a98045..0000000
--- a/dist/Monitoring/SlaTracking/slaService.js
+++ /dev/null
@@ -1,114 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.SlaService = void 0;
-const slaCalculator_1 = require("./slaCalculator");
-function subtractComposite(now, parts) {
-    let t = new Date(now);
-    for (const { value, unit } of parts) {
-        if (value <= 0)
-            continue;
-        switch (unit) {
-            case "y": {
-                const d = new Date(t);
-                d.setFullYear(d.getFullYear() - value);
-                t = d;
-                break;
-            }
-            case "mo": {
-                const d = new Date(t);
-                d.setMonth(d.getMonth() - value);
-                t = d;
-                break;
-            }
-            case "w":
-                t = new Date(t.getTime() - value * 604800000);
-                break;
-            case "d":
-                t = new Date(t.getTime() - value * 86400000);
-                break;
-            case "h":
-                t = new Date(t.getTime() - value * 3600000);
-                break;
-            case "m":
-                t = new Date(t.getTime() - value * 60000);
-                break;
-        }
-    }
-    return t;
-}
-function parseCompositePeriodString(period) {
-    if (typeof period !== "string" || !period.trim())
-        throw new Error("Período inválido: vazio.");
-    const p = period.trim().toLowerCase();
-    const re = /(\d+)\s*(mo|y|w|d|h|m)\b/gi;
-    const parts = [];
-    let match;
-    while ((match = re.exec(p)) !== null) {
-        const value = parseInt(match[1], 10);
-        const unit = match[2];
-        if (!Number.isFinite(value) || value <= 0)
-            throw new Error("Período inválido: valores devem ser inteiros positivos.");
-        parts.push({ value, unit });
-    }
-    if (parts.length === 0) {
-        throw new Error("Período inválido. Exemplos: 15m, 6h, 7d, 2mo, 1h30m, 2w3d, 1y2mo.");
-    }
-    const cleaned = p.replace(re, "").trim();
-    if (cleaned.length > 0) {
-        throw new Error(`Período inválido: token não reconhecido perto de "${cleaned}".`);
-    }
-    return parts;
-}
-class SlaService {
-    /**
-     * Recebe um período e devolve { start, end }.
-     * Formatos aceites:
-     *  - Composite: "15m", "6h", "7d", "2w3d", "1h30m", "1y2mo", etc.
-     *  - Prefixados legacy: "last-7d", "last-24h", etc. (equivalente a remover "last-").
-     *  - Mês específico: YYYY-MM (ex: 2025-01) => mês civil inteiro.
-     *  - Dia específico: YYYY-MM-DD => dia civil inteiro.
-     */
-    static parsePeriod(period) {
-        if (typeof period !== 'string')
-            throw new Error('Período inválido.');
-        let p = period.trim();
-        if (!p)
-            throw new Error('Período vazio.');
-        // legacy prefix "last-"
-        if (p.startsWith('last-'))
-            p = p.substring(5);
-        // YYYY-MM (mês)
-        if (/^\d{4}-\d{2}$/.test(p)) {
-            const [y, m] = p.split('-').map(Number);
-            const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0, 0));
-            const end = new Date(Date.UTC(y, m, 1, 0, 0, 0, 0));
-            return { start, end };
-        }
-        // YYYY-MM-DD (dia)
-        if (/^\d{4}-\d{2}-\d{2}$/.test(p)) {
-            const [y, m, d] = p.split('-').map(Number);
-            const start = new Date(Date.UTC(y, m - 1, d, 0, 0, 0, 0));
-            const end = new Date(Date.UTC(y, m - 1, d + 1, 0, 0, 0, 0));
-            return { start, end };
-        }
-        // composite relativo
-        const parts = parseCompositePeriodString(p);
-        const now = new Date();
-        const start = subtractComposite(now, parts);
-        if (start >= now)
-            throw new Error('Período inválido: início no futuro.');
-        return { start, end: now };
-    }
-    static async getSlaReport(serviceId, start, end) {
-        const now = new Date();
-        const safeEnd = end > now ? now : end;
-        if (start >= safeEnd)
-            throw new Error("Intervalo inválido: 'start' deve ser anterior a 'end'.");
-        return await slaCalculator_1.SlaCalculator.calculate(serviceId, start, safeEnd);
-    }
-    static async getSlaReportByPeriod(serviceId, period) {
-        const { start, end } = this.parsePeriod(period);
-        return await this.getSlaReport(serviceId, start, end);
-    }
-}
-exports.SlaService = SlaService;
diff --git a/dist/Monitoring/Workers/slaWorker.js b/dist/Monitoring/Workers/slaWorker.js
deleted file mode 100644
index 77da20a..0000000
--- a/dist/Monitoring/Workers/slaWorker.js
+++ /dev/null
@@ -1,69 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.prisma = void 0;
-exports.processSlaAndAlerts = processSlaAndAlerts;
-const client_1 = require("@prisma/client");
-const socket_1 = require("../../socket");
-const WriteSlaRecord_1 = require("../../Influxdb/WriteMetrics/WriteSlaRecord");
-const WriteServiceStatus_1 = require("../../Influxdb/WriteMetrics/WriteServiceStatus");
-const Notification_1 = require("../../Notifications/Notification");
-const notificationPolicyRepo_1 = require("../../Repositories/notificationPolicyRepo");
-const incidentManager_1 = require("../Incidents/incidentManager");
-exports.prisma = new client_1.PrismaClient();
-function minutesAgo(date, minutes) {
-    return new Date(Date.now() - minutes * 60 * 1000) > date;
-}
-async function notifyContacts(serviceId, message, channels) {
-    const contacts = await exports.prisma.alertContact.findMany({
-        where: { serviceId, active: true },
-    });
-    for (const c of contacts) {
-        if (channels.length === 0 || channels.includes(c.channel)) {
-            await (0, Notification_1.sendAlert)(c.channel, c.to, message);
-        }
-    }
-}
-async function processSlaAndAlerts(serviceId, issues = []) {
-    const io = (0, socket_1.getIO)();
-    const downNow = issues.length > 0;
-    if (downNow) {
-        for (const issue of issues) {
-            await (0, WriteServiceStatus_1.writeServiceStatus)({
-                serviceId: issue.serviceId,
-                status: "DOWN",
-            });
-            const policy = await notificationPolicyRepo_1.NotificationPolicyRepo.getEffectivePolicy(issue.serviceId);
-            const incident = await (0, incidentManager_1.findOrOpenIncident)(issue.serviceId);
-            if (!incident) {
-                console.error(`Falha ao criar ou obter incidente para serviço ${issue.serviceId}`);
-                continue;
-            }
-            await (0, WriteSlaRecord_1.writeSlaRecordToInflux)({
-                serviceId: issue.serviceId,
-                serviceName: issue.serviceName,
-                metric: "availability",
-                value: 0,
-                status: false,
-                criticality: issue.severity,
-            });
-            const canNotify = !incident.lastNotificationAt ||
-                minutesAgo(incident.lastNotificationAt, policy.cooldownMinutes);
-            if (canNotify) {
-                const nextRetry = (incident.retryCount ?? 0) + 1;
-                await notifyContacts(issue.serviceId, `ALERTA ${issue.severity.toUpperCase()}: ${issue.serviceName} - ${issue.description} (retry ${nextRetry}/${policy.maxRetries})`, policy.channels);
-                await (0, incidentManager_1.updateIncidentNotification)(incident.id, nextRetry);
-            }
-            io.emit("slaViolation", {
-                serviceId: issue.serviceId,
-                serviceName: issue.serviceName,
-                description: issue.description,
-                severity: issue.severity,
-            });
-        }
-    }
-    else {
-        await (0, WriteServiceStatus_1.writeServiceStatus)({ serviceId, status: "UP" });
-        const policy = await notificationPolicyRepo_1.NotificationPolicyRepo.getEffectivePolicy(serviceId);
-        await (0, incidentManager_1.closeIncidentIfRecovered)(serviceId, policy.recoveryConfirmations);
-    }
-}
diff --git a/dist/Monitoring/Workers/worker.js b/dist/Monitoring/Workers/worker.js
deleted file mode 100644
index 22fdb92..0000000
--- a/dist/Monitoring/Workers/worker.js
+++ /dev/null
@@ -1,9 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.startMonitoring = startMonitoring;
-const scheduler_1 = require("../Queue/scheduler");
-require("../Queue/monitoringWorker");
-async function startMonitoring() {
-    console.log('InfraWatch Em Acção...');
-    await (0, scheduler_1.startQueueScheduler)();
-}
diff --git a/dist/Monitoring/Workers/worker2.js b/dist/Monitoring/Workers/worker2.js
deleted file mode 100644
index fd3f1f1..0000000
--- a/dist/Monitoring/Workers/worker2.js
+++ /dev/null
@@ -1,67 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.processProxyData = processProxyData;
-const socket_1 = require("../../socket");
-const PingIssueAnalyzer_1 = require("../../Analyzers/PingIssueAnalyzer");
-const HttpIssueAnalyzer_1 = require("../../Analyzers/HttpIssueAnalyzer");
-const analyzeSnmpIssue_1 = require("../../Analyzers/analyzeSnmpIssue");
-const WriteSnmpMetrics_1 = require("../../Influxdb/WriteMetrics/WriteSnmpMetrics");
-const WritePingMetrics_1 = require("../../Influxdb/WriteMetrics/WritePingMetrics");
-const WriteHttpMetrics_1 = require("../../Influxdb/WriteMetrics/WriteHttpMetrics");
-async function processProxyData(data) {
-    const io = (0, socket_1.getIO)();
-    const problems = [];
-    console.log(data);
-    if (!data || !data.type) {
-        problems.push({
-            serviceId: data?.id || "unknown",
-            serviceName: data?.target || "unknown",
-            metric: "unknown",
-            value: 0,
-            status: "UNKNOWN",
-            description: "Dados inválidos recebidos do proxy",
-            recommendation: "Verifique se o proxy está enviando os dados corretamente",
-            priority: 2,
-            severity: "WARNING",
-            timestamp: new Date().toISOString(),
-        });
-        return problems;
-    }
-    switch (data.type) {
-        case "SNMP":
-            io.emit("snmpService", data);
-            await (0, WriteSnmpMetrics_1.writeSnmpMetrics)(data.serviceId, data);
-            const snmpAnalysis = await (0, analyzeSnmpIssue_1.analyzeSnmpIssue)({ id: data.serviceId, name: data.target }, data);
-            if (snmpAnalysis)
-                problems.push(snmpAnalysis);
-            break;
-        case "PING":
-            io.emit("pingService", data);
-            await (0, WritePingMetrics_1.writePingMetrics)(data.serviceId, data);
-            const pingAnalysis = (0, PingIssueAnalyzer_1.analyzePingIssue)({ id: data.serviceId, name: data.target }, data);
-            if (pingAnalysis)
-                problems.push(pingAnalysis);
-            break;
-        case "HTTP":
-            io.emit("httpService", data);
-            await (0, WriteHttpMetrics_1.writeHttpMetrics)(data.serviceId, data);
-            const httpAnalysis = (0, HttpIssueAnalyzer_1.analyzeHttpIssue)({ id: data.serviceId, name: data.target }, data);
-            if (httpAnalysis)
-                problems.push(httpAnalysis);
-            break;
-        default:
-            problems.push({
-                serviceId: data.serviceId,
-                serviceName: data.target,
-                metric: "unknown",
-                value: 0,
-                status: "UNKNOWN",
-                description: `Tipo de serviço desconhecido: ${data.type}`,
-                recommendation: "Verifique a configuração do proxy",
-                priority: 2,
-                severity: "WARNING",
-                timestamp: new Date().toISOString(),
-            });
-    }
-    return problems;
-}
diff --git a/dist/Notifications/Email/EmailProvider.js b/dist/Notifications/Email/EmailProvider.js
deleted file mode 100644
index 0268c84..0000000
--- a/dist/Notifications/Email/EmailProvider.js
+++ /dev/null
@@ -1,50 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.EmailProvider = void 0;
-/// <reference types="node" />
-const nodemailer_1 = __importDefault(require("nodemailer"));
-const alertTemplate_1 = require("../HTML/alertTemplate");
-const resetCodeTemplate_1 = require("../HTML/resetCodeTemplate");
-class EmailProvider {
-    constructor() {
-        const user = process.env.EMAIL_USER;
-        const pass = process.env.EMAIL_PASS;
-        if (!user || !pass) {
-            console.warn('[EmailProvider] Variáveis EMAIL_USER / EMAIL_PASS ausentes. Envios irão falhar.');
-        }
-        this.transporter = nodemailer_1.default.createTransport({
-            service: process.env.EMAIL_SERVICE || 'gmail',
-            host: process.env.EMAIL_HOST,
-            port: process.env.EMAIL_PORT ? Number(process.env.EMAIL_PORT) : undefined,
-            secure: process.env.EMAIL_SECURE === 'true',
-            auth: user && pass ? { user, pass } : undefined,
-        });
-    }
-    async sendNotification(to, message, options) {
-        if (!to || !/\S+@\S+\.\S+/.test(to)) {
-            throw new Error('Email inválido');
-        }
-        if (!this.transporter) {
-            throw new Error('Transporter de email não inicializado');
-        }
-        const templateType = options?.metadata?.templateType || 'alert';
-        const subject = templateType === 'reset-code'
-            ? 'InfraWatch - Código de Redefinição de Senha'
-            : (options?.metadata?.subject || 'InfraWatch - Alerta');
-        const html = templateType === 'reset-code'
-            ? (0, resetCodeTemplate_1.buildResetCodeEmailHtml)(message)
-            : (0, alertTemplate_1.buildAlertEmailHtml)(message);
-        const info = await this.transporter.sendMail({
-            from: process.env.EMAIL_FROM || process.env.EMAIL_USER,
-            to,
-            subject,
-            text: message,
-            html,
-        });
-        return info?.messageId;
-    }
-}
-exports.EmailProvider = EmailProvider;
diff --git a/dist/Notifications/HTML/alertTemplate.js b/dist/Notifications/HTML/alertTemplate.js
deleted file mode 100644
index 3e8f2a9..0000000
--- a/dist/Notifications/HTML/alertTemplate.js
+++ /dev/null
@@ -1,27 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.buildAlertEmailHtml = buildAlertEmailHtml;
-function buildAlertEmailHtml(message) {
-    return `
-  <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
-    <div style="background-color: #0056b3; padding: 20px; text-align: center;">
-      <img src="https://cdn-icons-png.flaticon.com/512/565/565547.png" alt="InfraWatch Logo" width="60" style="display: block; margin: 0 auto 10px auto;" />
-      <h1 style="color: white; margin: 0; font-size: 24px;">InfraWatch</h1>
-    </div>
-
-    <div style="padding: 20px; color: #333;">
-      <h2 style="color: #0056b3;">🚨 Alerta Importante</h2>
-      <p style="font-size: 16px; line-height: 1.5;">
-        ${message}
-      </p>
-
-      <a href="#" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background-color: #0056b3; color: white; text-decoration: none; border-radius: 5px; font-weight: 600;">
-        Ver detalhes
-      </a>
-    </div>
-
-    <div style="background-color: #f5f5f5; padding: 15px; font-size: 12px; color: #777; text-align: center;">
-      <p>Este é um alerta automático enviado pelo sistema InfraWatch. Por favor, não responda este e-mail.</p>
-    </div>
-  </div>`;
-}
diff --git a/dist/Notifications/HTML/resetCodeTemplate.js b/dist/Notifications/HTML/resetCodeTemplate.js
deleted file mode 100644
index 247d8cd..0000000
--- a/dist/Notifications/HTML/resetCodeTemplate.js
+++ /dev/null
@@ -1,29 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.buildResetCodeEmailHtml = buildResetCodeEmailHtml;
-function buildResetCodeEmailHtml(code) {
-    return `
-  <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
-    <div style="background-color: #0056b3; padding: 20px; text-align: center;">
-      <img src="https://cdn-icons-png.flaticon.com/512/565/565547.png" alt="InfraWatch Logo" width="60" style="display: block; margin: 0 auto 10px auto;" />
-      <h1 style="color: white; margin: 0; font-size: 24px;">InfraWatch</h1>
-    </div>
-
-    <div style="padding: 20px; color: #333;">
-      <h2 style="color: #0056b3;">🔒 Código de Redefinição de Senha</h2>
-      <p style="font-size: 16px; line-height: 1.5;">
-        Você solicitou a redefinição de senha. Use o código abaixo para continuar:
-      </p>
-      <p style="font-size: 24px; font-weight: bold; color: #e63946; text-align: center; margin: 20px 0;">
-        ${code}
-      </p>
-      <p style="font-size: 14px; color: #555;">
-        Este código é válido por 15 minutos. Se você não solicitou essa alteração, ignore este e-mail.
-      </p>
-    </div>
-
-    <div style="background-color: #f5f5f5; padding: 15px; font-size: 12px; color: #777; text-align: center;">
-      <p>Este é um e-mail automático enviado pelo sistema InfraWatch. Por favor, não responda este e-mail.</p>
-    </div>
-  </div>`;
-}
diff --git a/dist/Notifications/INotificationProvider.js b/dist/Notifications/INotificationProvider.js
deleted file mode 100644
index c8ad2e5..0000000
--- a/dist/Notifications/INotificationProvider.js
+++ /dev/null
@@ -1,2 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/dist/Notifications/Notification.js b/dist/Notifications/Notification.js
deleted file mode 100644
index c232ef3..0000000
--- a/dist/Notifications/Notification.js
+++ /dev/null
@@ -1,105 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.notificationController = exports.NotificationController = void 0;
-exports.sendAlert = sendAlert;
-const EmailProvider_1 = require("./Email/EmailProvider");
-const SlackProvider_1 = require("./Slack/SlackProvider");
-const TelegramProvider_1 = require("./Telegram/TelegramProvider");
-const TwilioProvider_1 = require("./Twilio/TwilioProvider");
-class NotificationController {
-    constructor() {
-        this.providers = {};
-        this.factories = {
-            email: () => new EmailProvider_1.EmailProvider(),
-            slack: () => new SlackProvider_1.SlackProvider(),
-            telegram: () => new TelegramProvider_1.TelegramProvider(),
-            twilio: () => new TwilioProvider_1.TwilioProvider(),
-        };
-        this.metrics = {
-            email: { sent: 0, failed: 0 },
-            slack: { sent: 0, failed: 0 },
-            telegram: { sent: 0, failed: 0 },
-            twilio: { sent: 0, failed: 0 },
-        };
-    }
-    getProvider(channel) {
-        if (!this.providers[channel]) {
-            this.providers[channel] = this.factories[channel]();
-        }
-        return this.providers[channel];
-    }
-    updateSuccess(channel) {
-        const now = new Date().toISOString();
-        this.metrics[channel].sent += 1;
-        this.metrics[channel].lastSuccess = now;
-    }
-    updateFailure(channel, err) {
-        const now = new Date().toISOString();
-        this.metrics[channel].failed += 1;
-        this.metrics[channel].lastFailure = now;
-        this.metrics[channel].lastError = err.message;
-    }
-    async send(channel, to, message, options = {}) {
-        const provider = this.getProvider(channel);
-        const retry = Math.max(0, options.retry ?? 0);
-        const timeoutMs = options.timeout && options.timeout > 0 ? options.timeout : undefined;
-        const attemptOnce = async () => {
-            if (!timeoutMs)
-                return provider.sendNotification(to, message, options);
-            return await Promise.race([
-                provider.sendNotification(to, message, options),
-                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout ao enviar notificação')), timeoutMs)),
-            ]);
-        };
-        let lastError;
-        for (let attempt = 0; attempt <= retry; attempt++) {
-            try {
-                const messageId = await attemptOnce();
-                this.updateSuccess(channel);
-                return { channel, to, success: true, messageId, timestamp: new Date().toISOString() };
-            }
-            catch (err) {
-                lastError = err;
-                if (attempt < retry)
-                    await new Promise((r) => setTimeout(r, 200 * (attempt + 1)));
-            }
-        }
-        this.updateFailure(channel, lastError ?? new Error('Falha desconhecida'));
-        return { channel, to, success: false, error: lastError, timestamp: new Date().toISOString() };
-    }
-    async sendWithFallback(channels, to, message, options) {
-        const results = [];
-        for (const channel of channels) {
-            const destination = typeof to === 'string' ? to : (to[channel] ?? '');
-            if (!destination) {
-                results.push({ channel, to: destination, success: false, error: new Error('Destino não fornecido'), timestamp: new Date().toISOString() });
-                continue;
-            }
-            const result = await this.send(channel, destination, message, options);
-            results.push(result);
-            if (result.success)
-                break;
-        }
-        return results;
-    }
-    getMetrics() { return this.metrics; }
-    reset() {
-        Object.keys(this.metrics).forEach((c) => {
-            this.metrics[c] = { sent: 0, failed: 0 };
-        });
-    }
-}
-exports.NotificationController = NotificationController;
-exports.notificationController = new NotificationController();
-async function sendAlert(channel, to, message) {
-    try {
-        const result = await exports.notificationController.send(channel, to, message);
-        if (result.success)
-            console.log(`Alerta enviado via ${channel} para ${to}`);
-        else
-            console.error(`Falha ao enviar alerta via ${channel} para ${to}: ${result.error?.message}`);
-    }
-    catch (error) {
-        console.error(`Erro ao enviar alerta via ${channel} para ${to}:`, error);
-    }
-}
diff --git a/dist/Notifications/Slack/SlackProvider.js b/dist/Notifications/Slack/SlackProvider.js
deleted file mode 100644
index 4b16413..0000000
--- a/dist/Notifications/Slack/SlackProvider.js
+++ /dev/null
@@ -1,34 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.SlackProvider = void 0;
-const axios_1 = __importDefault(require("axios"));
-class SlackProvider {
-    constructor() {
-        this.enabled = false;
-        this.webhookUrl = process.env.SLACK_WEBHOOK_URL;
-        if (!this.webhookUrl) {
-            console.warn('[SlackProvider] SLACK_WEBHOOK_URL ausente: Slack desabilitado.');
-        }
-        else {
-            this.enabled = true;
-        }
-    }
-    async sendNotification(to, message, _options) {
-        if (!this.enabled || !this.webhookUrl) {
-            throw new Error('Slack não configurado');
-        }
-        if (!to || !to.startsWith('#')) {
-            // Permite também canal direto? Poderia validar @user, aqui exigimos canal #
-            console.warn('[SlackProvider] Destino não começa com #, prosseguindo mesmo assim.');
-        }
-        await axios_1.default.post(this.webhookUrl, {
-            channel: to,
-            text: message,
-        });
-        return undefined;
-    }
-}
-exports.SlackProvider = SlackProvider;
diff --git a/dist/Notifications/Telegram/TelegramProvider.js b/dist/Notifications/Telegram/TelegramProvider.js
deleted file mode 100644
index 7773ca8..0000000
--- a/dist/Notifications/Telegram/TelegramProvider.js
+++ /dev/null
@@ -1,35 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.TelegramProvider = void 0;
-const axios_1 = __importDefault(require("axios"));
-class TelegramProvider {
-    constructor() {
-        this.enabled = false;
-        this.botToken = process.env.TELEGRAM_BOT_TOKEN;
-        if (!this.botToken) {
-            console.warn('[TelegramProvider] TELEGRAM_BOT_TOKEN ausente: Telegram desabilitado.');
-        }
-        else {
-            this.enabled = true;
-        }
-    }
-    async sendNotification(to, message, options) {
-        if (!this.enabled || !this.botToken) {
-            throw new Error('Telegram não configurado');
-        }
-        if (!to) {
-            throw new Error('Chat ID vazio');
-        }
-        const url = `https://api.telegram.org/bot${this.botToken}/sendMessage`;
-        const res = await axios_1.default.post(url, {
-            chat_id: to,
-            text: message,
-            parse_mode: options?.metadata?.parseMode,
-        });
-        return res?.data?.result?.message_id?.toString();
-    }
-}
-exports.TelegramProvider = TelegramProvider;
diff --git a/dist/Notifications/Twilio/TwilioProvider.js b/dist/Notifications/Twilio/TwilioProvider.js
deleted file mode 100644
index 09204b9..0000000
--- a/dist/Notifications/Twilio/TwilioProvider.js
+++ /dev/null
@@ -1,38 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.TwilioProvider = void 0;
-const twilio_1 = require("twilio");
-class TwilioProvider {
-    constructor() {
-        this.fromNumber = '';
-        this.enabled = false;
-        const accountSid = process.env.TWILIO_SID;
-        const authToken = process.env.TWILIO_AUTH_TOKEN;
-        const from = process.env.TWILIO_PHONE_NUMBER;
-        if (accountSid && authToken && from) {
-            this.client = new twilio_1.Twilio(accountSid, authToken);
-            this.fromNumber = from;
-            this.enabled = true;
-        }
-        else {
-            console.warn('[TwilioProvider] Credenciais ausentes: SMS desabilitado.');
-        }
-    }
-    async sendNotification(to, message, options) {
-        if (!this.enabled || !this.client) {
-            throw new Error('Twilio não configurado');
-        }
-        if (!/^\+?[1-9]\d{6,14}$/.test(to)) {
-            throw new Error('Número de telefone inválido (esperado formato E.164)');
-        }
-        const statusCallback = process.env.TWILIO_STATUS_CALLBACK || options?.metadata?.statusCallback;
-        const res = await this.client.messages.create({
-            body: message,
-            from: this.fromNumber,
-            to,
-            statusCallback,
-        });
-        return res?.sid;
-    }
-}
-exports.TwilioProvider = TwilioProvider;
diff --git a/dist/RegisterRoutes/RegisterRoutes.js b/dist/RegisterRoutes/RegisterRoutes.js
deleted file mode 100644
index caa0269..0000000
--- a/dist/RegisterRoutes/RegisterRoutes.js
+++ /dev/null
@@ -1,28 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.RegisterAllRoutes = RegisterAllRoutes;
-const jwt_1 = __importDefault(require("../plugins/jwt"));
-const prisma_js_1 = __importDefault(require("../plugins/prisma.js"));
-const servicesRoutes_1 = require("../routes/APIs/servicesRoutes");
-const notificationRoutes_1 = require("../routes/APIs/notificationRoutes");
-const serviceMetricsRoutes_1 = require("../routes/APIs/serviceMetricsRoutes");
-const alertContactRoutes_1 = require("../routes/APIs/alertContactRoutes");
-const notificationPolicy_1 = require("../routes/APIs/notificationPolicy");
-const IncidentsRoutes_1 = require("../routes/APIs/IncidentsRoutes");
-const slaRoutes_1 = require("../routes/APIs/slaRoutes");
-const proxyReceiverRoutes_1 = require("../routes/APIs/proxyReceiverRoutes");
-async function RegisterAllRoutes(app) {
-    app.register(prisma_js_1.default);
-    app.register(jwt_1.default);
-    app.register(proxyReceiverRoutes_1.proxyReceiverRoutes);
-    app.register(slaRoutes_1.slaRoutes, { prefix: "/api" });
-    app.register(servicesRoutes_1.servicesRoutes);
-    app.register(alertContactRoutes_1.alertContactRoutes);
-    app.register(notificationRoutes_1.notificationRoutes);
-    app.register(serviceMetricsRoutes_1.serviceMetricsRoutes);
-    app.register(notificationPolicy_1.notificationPolicyRoutes);
-    app.register(IncidentsRoutes_1.incidentRoutes, { prefix: '/api/incidents' });
-}
diff --git a/dist/Repositories/notificationPolicyRepo.js b/dist/Repositories/notificationPolicyRepo.js
deleted file mode 100644
index d0b9178..0000000
--- a/dist/Repositories/notificationPolicyRepo.js
+++ /dev/null
@@ -1,45 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.NotificationPolicyRepo = void 0;
-const client_1 = require("@prisma/client");
-const prisma = new client_1.PrismaClient();
-const FALLBACK = {
-    maxRetries: 3,
-    retryIntervalMinutes: 2,
-    escalateAfterMinutes: 10,
-    cooldownMinutes: 15,
-    recoveryConfirmations: 2,
-    channels: ['email'],
-    active: true,
-};
-class NotificationPolicyRepo {
-    static async getEffectivePolicy(serviceId) {
-        const specific = await prisma.notificationPolicy.findFirst({
-            where: { serviceId, active: true },
-            orderBy: { updatedAt: 'desc' }
-        });
-        if (specific)
-            return specific;
-        const globalDefault = await prisma.notificationPolicy.findFirst({
-            where: { isDefault: true, active: true },
-            orderBy: { updatedAt: 'desc' }
-        });
-        if (globalDefault)
-            return globalDefault;
-        return {
-            id: 'fallback',
-            serviceId: null,
-            isDefault: false,
-            active: true,
-            channels: FALLBACK.channels,
-            maxRetries: FALLBACK.maxRetries,
-            retryIntervalMinutes: FALLBACK.retryIntervalMinutes,
-            escalateAfterMinutes: FALLBACK.escalateAfterMinutes,
-            cooldownMinutes: FALLBACK.cooldownMinutes,
-            recoveryConfirmations: FALLBACK.recoveryConfirmations,
-            createdAt: new Date(),
-            updatedAt: new Date()
-        };
-    }
-}
-exports.NotificationPolicyRepo = NotificationPolicyRepo;
diff --git a/dist/plugins/jwt.js b/dist/plugins/jwt.js
deleted file mode 100644
index ea76fde..0000000
--- a/dist/plugins/jwt.js
+++ /dev/null
@@ -1,52 +0,0 @@
-"use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    var desc = Object.getOwnPropertyDescriptor(m, k);
-    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
-      desc = { enumerable: true, get: function() { return m[k]; } };
-    }
-    Object.defineProperty(o, k2, desc);
-}) : (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    o[k2] = m[k];
-}));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
-    Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
-    o["default"] = v;
-});
-var __importStar = (this && this.__importStar) || (function () {
-    var ownKeys = function(o) {
-        ownKeys = Object.getOwnPropertyNames || function (o) {
-            var ar = [];
-            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
-            return ar;
-        };
-        return ownKeys(o);
-    };
-    return function (mod) {
-        if (mod && mod.__esModule) return mod;
-        var result = {};
-        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
-        __setModuleDefault(result, mod);
-        return result;
-    };
-})();
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-const fastify_plugin_1 = __importDefault(require("fastify-plugin"));
-exports.default = (0, fastify_plugin_1.default)(async (fastify) => {
-    fastify.register(Promise.resolve().then(() => __importStar(require('fastify-jwt'))), {
-        secret: process.env.JWT_SECRET || 'supersecret',
-    });
-    fastify.decorate('authenticate', async function (request, reply) {
-        try {
-            await request.jwtVerify();
-        }
-        catch (err) {
-            reply.code(401).send({ message: 'Unauthorized' });
-        }
-    });
-});
diff --git a/dist/plugins/prisma.js b/dist/plugins/prisma.js
deleted file mode 100644
index b342b7a..0000000
--- a/dist/plugins/prisma.js
+++ /dev/null
@@ -1,15 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-const fastify_plugin_1 = __importDefault(require("fastify-plugin"));
-const client_1 = require("@prisma/client");
-exports.default = (0, fastify_plugin_1.default)(async (fastify) => {
-    const prisma = new client_1.PrismaClient();
-    await prisma.$connect();
-    fastify.decorate('prisma', prisma);
-    fastify.addHook('onClose', async (app) => {
-        await app.prisma.$disconnect();
-    });
-});
diff --git a/dist/routes/APIs/IncidentsRoutes.js b/dist/routes/APIs/IncidentsRoutes.js
deleted file mode 100644
index f04c1fc..0000000
--- a/dist/routes/APIs/IncidentsRoutes.js
+++ /dev/null
@@ -1,87 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.incidentRoutes = incidentRoutes;
-const client_1 = require("@prisma/client");
-const prisma = new client_1.PrismaClient();
-const incidentSchema = {
-    type: 'object',
-    properties: {
-        id: { type: 'string' },
-        serviceId: { type: 'string' },
-        openedAt: { type: 'string', format: 'date-time' },
-        closedAt: { type: 'string', format: 'date-time', nullable: true },
-        reason: { type: 'string', nullable: true },
-        service: {
-            type: 'object',
-            properties: {
-                id: { type: 'string' },
-                name: { type: 'string' },
-            },
-        },
-    },
-};
-async function incidentRoutes(app) {
-    app.get('/open', {
-        schema: {
-            tags: ['Incidents'],
-            summary: 'Listar incidentes abertos',
-            response: {
-                200: { type: 'array', items: incidentSchema },
-            },
-        },
-        handler: async () => {
-            return prisma.incident.findMany({
-                where: { closedAt: null },
-                orderBy: { openedAt: 'desc' },
-                include: { service: true },
-            });
-        },
-    });
-    app.get('/history', {
-        schema: {
-            tags: ['Incidents'],
-            summary: 'Histórico de incidentes',
-            querystring: {
-                type: 'object',
-                properties: {
-                    serviceId: { type: 'string' },
-                },
-            },
-            response: {
-                200: { type: 'array', items: incidentSchema },
-            },
-        },
-        handler: async (req) => {
-            const { serviceId } = req.query;
-            return prisma.incident.findMany({
-                where: { serviceId: serviceId || undefined },
-                orderBy: { openedAt: 'desc' },
-                include: { service: true },
-            });
-        },
-    });
-    app.post('/:id/close', {
-        schema: {
-            tags: ['Incidents'],
-            summary: 'Fechar incidente manualmente',
-            params: {
-                type: 'object',
-                properties: {
-                    id: { type: 'string' },
-                },
-                required: ['id'],
-            },
-            response: {
-                200: incidentSchema,
-            },
-        },
-        handler: async (req) => {
-            const { id } = req.params;
-            return prisma.incident.update({
-                where: { id },
-                data: { closedAt: new Date(), reason: 'manual-close' },
-                include: { service: true },
-            });
-        },
-    });
-}
diff --git a/dist/routes/APIs/alertContactRoutes.js b/dist/routes/APIs/alertContactRoutes.js
deleted file mode 100644
index 28ea209..0000000
--- a/dist/routes/APIs/alertContactRoutes.js
+++ /dev/null
@@ -1,95 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.alertContactRoutes = alertContactRoutes;
-const alertContact_1 = require("../../Controllers/APIs/alertContact");
-async function alertContactRoutes(fastify) {
-    const controller = new alertContact_1.AlertContactController();
-    fastify.post('/api/alert-contact', {
-        schema: {
-            description: 'Criar um novo contato de alerta para um serviço',
-            tags: ['AlertContact'],
-            body: {
-                type: 'object',
-                required: ['serviceId', 'channel', 'to'],
-                properties: {
-                    serviceId: { type: 'string' },
-                    channel: { type: 'string', enum: ['email', 'slack', 'telegram', 'twilio'] },
-                    to: { type: 'string' },
-                },
-            },
-        },
-    }, async (request, reply) => {
-        try {
-            return await controller.create(request, reply);
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao criar contato' });
-        }
-    });
-    fastify.get('/api/alert-contact/:serviceId', {
-        schema: {
-            description: 'Listar todos os contatos de alerta de um serviço',
-            tags: ['AlertContact'],
-            params: {
-                type: 'object',
-                properties: { serviceId: { type: 'string' } },
-                required: ['serviceId'],
-            },
-        },
-    }, async (request, reply) => {
-        try {
-            return await controller.list(request, reply);
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao buscar contatos' });
-        }
-    });
-    fastify.put('/api/alert-contact/:id', {
-        schema: {
-            description: 'Atualizar um contato de alerta',
-            tags: ['AlertContact'],
-            params: {
-                type: 'object',
-                properties: { id: { type: 'string' } },
-                required: ['id'],
-            },
-            body: {
-                type: 'object',
-                properties: {
-                    channel: { type: 'string', enum: ['email', 'slack', 'telegram', 'twilio'] },
-                    to: { type: 'string' },
-                    active: { type: 'boolean' },
-                },
-            },
-        },
-    }, async (request, reply) => {
-        try {
-            return await controller.update(request, reply);
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao atualizar contato' });
-        }
-    });
-    fastify.delete('/api/alert-contact/:id', {
-        schema: {
-            description: 'Deletar um contato de alerta',
-            tags: ['AlertContact'],
-            params: {
-                type: 'object',
-                properties: { id: { type: 'string' } },
-                required: ['id'],
-            },
-        },
-    }, async (request, reply) => {
-        try {
-            return await controller.delete(request, reply);
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao remover contato' });
-        }
-    });
-}
diff --git a/dist/routes/APIs/notificationPolicy.js b/dist/routes/APIs/notificationPolicy.js
deleted file mode 100644
index 3e869dd..0000000
--- a/dist/routes/APIs/notificationPolicy.js
+++ /dev/null
@@ -1,190 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.notificationPolicyRoutes = notificationPolicyRoutes;
-const client_1 = require("@prisma/client");
-const prisma = new client_1.PrismaClient();
-async function notificationPolicyRoutes(app) {
-    // 🔹 Prefixo fixo em todas as rotas
-    const routePrefix = '/api/policies';
-    app.get(`${routePrefix}/:serviceId/effective`, {
-        schema: {
-            tags: ['NotificationPolicy'],
-            summary: 'Buscar política efetiva para um serviço',
-            params: {
-                type: 'object',
-                properties: {
-                    serviceId: { type: 'string' },
-                },
-                required: ['serviceId'],
-            },
-            response: {
-                200: {
-                    type: 'object',
-                    properties: {
-                        id: { type: 'string' },
-                        serviceId: { type: 'string', nullable: true },
-                        isDefault: { type: 'boolean' },
-                        active: { type: 'boolean' },
-                        channels: { type: 'array', items: { type: 'string' } },
-                        maxRetries: { type: 'integer' },
-                        retryIntervalMinutes: { type: 'integer' },
-                        escalateAfterMinutes: { type: 'integer' },
-                        cooldownMinutes: { type: 'integer' },
-                        recoveryConfirmations: { type: 'integer' },
-                    },
-                },
-            },
-        },
-        handler: async (req) => {
-            const { serviceId } = req.params;
-            const specific = await prisma.notificationPolicy.findFirst({
-                where: { serviceId, active: true },
-            });
-            if (specific)
-                return specific;
-            const def = await prisma.notificationPolicy.findFirst({
-                where: { isDefault: true, active: true },
-            });
-            return (def ?? {
-                channels: ['email'],
-                maxRetries: 3,
-                retryIntervalMinutes: 2,
-                escalateAfterMinutes: 10,
-                cooldownMinutes: 15,
-                recoveryConfirmations: 2,
-            });
-        },
-    });
-    app.get(`${routePrefix}/default`, {
-        schema: {
-            tags: ['NotificationPolicy'],
-            summary: 'Buscar política padrão',
-            response: {
-                200: {
-                    type: 'object',
-                    nullable: true,
-                },
-            },
-        },
-        handler: async () => {
-            return prisma.notificationPolicy.findFirst({
-                where: { isDefault: true, active: true },
-            });
-        },
-    });
-    app.post(`${routePrefix}`, {
-        schema: {
-            tags: ['NotificationPolicy'],
-            summary: 'Criar nova política de notificação',
-            body: {
-                type: 'object',
-                properties: {
-                    serviceId: { type: 'string', nullable: true },
-                    isDefault: { type: 'boolean' },
-                    active: { type: 'boolean' },
-                    channels: { type: 'array', items: { type: 'string' } },
-                    maxRetries: { type: 'integer' },
-                    retryIntervalMinutes: { type: 'integer' },
-                    escalateAfterMinutes: { type: 'integer' },
-                    cooldownMinutes: { type: 'integer' },
-                    recoveryConfirmations: { type: 'integer' },
-                },
-                required: ['channels', 'maxRetries', 'retryIntervalMinutes'],
-            },
-            response: {
-                200: {
-                    type: 'object',
-                    properties: {
-                        id: { type: 'string' },
-                        serviceId: { type: 'string', nullable: true },
-                        isDefault: { type: 'boolean' },
-                        active: { type: 'boolean' },
-                        channels: { type: 'array', items: { type: 'string' } },
-                        maxRetries: { type: 'integer' },
-                        retryIntervalMinutes: { type: 'integer' },
-                        escalateAfterMinutes: { type: 'integer' },
-                        cooldownMinutes: { type: 'integer' },
-                        recoveryConfirmations: { type: 'integer' },
-                    },
-                },
-            },
-        },
-        handler: async (req) => {
-            const body = req.body;
-            return prisma.notificationPolicy.create({ data: body });
-        },
-    });
-    app.put(`${routePrefix}/:id`, {
-        schema: {
-            tags: ['NotificationPolicy'],
-            summary: 'Atualizar uma política existente',
-            params: {
-                type: 'object',
-                properties: {
-                    id: { type: 'string' },
-                },
-                required: ['id'],
-            },
-            body: {
-                type: 'object',
-                properties: {
-                    serviceId: { type: 'string', nullable: true },
-                    isDefault: { type: 'boolean' },
-                    active: { type: 'boolean' },
-                    channels: { type: 'array', items: { type: 'string' } },
-                    maxRetries: { type: 'integer' },
-                    retryIntervalMinutes: { type: 'integer' },
-                    escalateAfterMinutes: { type: 'integer' },
-                    cooldownMinutes: { type: 'integer' },
-                    recoveryConfirmations: { type: 'integer' },
-                },
-            },
-            response: {
-                200: {
-                    type: 'object',
-                    properties: {
-                        id: { type: 'string' },
-                        serviceId: { type: 'string', nullable: true },
-                        isDefault: { type: 'boolean' },
-                        active: { type: 'boolean' },
-                        channels: { type: 'array', items: { type: 'string' } },
-                        maxRetries: { type: 'integer' },
-                        retryIntervalMinutes: { type: 'integer' },
-                        escalateAfterMinutes: { type: 'integer' },
-                        cooldownMinutes: { type: 'integer' },
-                        recoveryConfirmations: { type: 'integer' },
-                    },
-                },
-            },
-        },
-        handler: async (req) => {
-            const { id } = req.params;
-            const body = req.body;
-            return prisma.notificationPolicy.update({ where: { id }, data: body });
-        },
-    });
-    app.delete(`${routePrefix}/:id`, {
-        schema: {
-            tags: ['NotificationPolicy'],
-            summary: 'Excluir uma política de notificação',
-            params: {
-                type: 'object',
-                properties: {
-                    id: { type: 'string' },
-                },
-                required: ['id'],
-            },
-            response: {
-                200: {
-                    type: 'object',
-                    properties: { ok: { type: 'boolean' } },
-                },
-            },
-        },
-        handler: async (req) => {
-            const { id } = req.params;
-            await prisma.notificationPolicy.delete({ where: { id } });
-            return { ok: true };
-        },
-    });
-}
diff --git a/dist/routes/APIs/notificationRoutes.js b/dist/routes/APIs/notificationRoutes.js
deleted file mode 100644
index f1ddb35..0000000
--- a/dist/routes/APIs/notificationRoutes.js
+++ /dev/null
@@ -1,40 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.notificationRoutes = notificationRoutes;
-const Notification_1 = require("../../Notifications/Notification");
-const controller = new Notification_1.NotificationController();
-async function notificationRoutes(fastify) {
-    fastify.post('/api/notifications/send', {
-        schema: {
-            description: 'Enviar notificação por canal',
-            tags: ['Notifications'],
-            body: {
-                type: 'object',
-                required: ['channel', 'to', 'message'],
-                properties: {
-                    channel: { type: 'string', enum: ['email', 'slack', 'telegram', 'twilio'] },
-                    to: { type: 'string' },
-                    message: { type: 'string' }
-                }
-            },
-            response: {
-                200: {
-                    type: 'object',
-                    properties: {
-                        success: { type: 'boolean' }
-                    }
-                }
-            }
-        }
-    }, async (request, reply) => {
-        try {
-            const { channel, to, message } = request.body;
-            await controller.send(channel, to, message);
-            return { success: true };
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao enviar notificação' });
-        }
-    });
-}
diff --git a/dist/routes/APIs/proxyReceiverRoutes.js b/dist/routes/APIs/proxyReceiverRoutes.js
deleted file mode 100644
index 2c56382..0000000
--- a/dist/routes/APIs/proxyReceiverRoutes.js
+++ /dev/null
@@ -1,21 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.proxyReceiverRoutes = proxyReceiverRoutes;
-const worker2_1 = require("../../Monitoring/Workers/worker2");
-const slaWorker_1 = require("../../Monitoring/Workers/slaWorker");
-async function proxyReceiverRoutes(fastify) {
-    fastify.post("/proxy-data", async (request, reply) => {
-        try {
-            const data = request.body;
-            const issues = await (0, worker2_1.processProxyData)(data);
-            for (const issue of issues) {
-                await (0, slaWorker_1.processSlaAndAlerts)(data.serviceId, [issue]);
-            }
-            return { status: "ok", issues };
-        }
-        catch (error) {
-            request.log.error(error);
-            return reply.status(500).send({ status: "error", message: error.message });
-        }
-    });
-}
diff --git a/dist/routes/APIs/serviceMetricsRoutes.js b/dist/routes/APIs/serviceMetricsRoutes.js
deleted file mode 100644
index 6a69290..0000000
--- a/dist/routes/APIs/serviceMetricsRoutes.js
+++ /dev/null
@@ -1,88 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.serviceMetricsRoutes = serviceMetricsRoutes;
-const serviceMetrics_1 = require("../../Controllers/APIs/serviceMetrics");
-async function serviceMetricsRoutes(fastify) {
-    fastify.get('/api/services/:id/metrics/snmp', {
-        schema: {
-            description: 'Obter métricas SNMP do serviço (última hora: system, interfaces, summary e sensores)',
-            tags: ['Services'],
-            params: {
-                type: 'object',
-                properties: { id: { type: 'string' } },
-                required: ['id']
-            }
-        }
-    }, async (request, reply) => {
-        try {
-            const { id } = request.params;
-            const metrics = await (0, serviceMetrics_1.getSnmpMetrics)(id);
-            return reply.send(metrics);
-        }
-        catch (error) {
-            request.log.error(error);
-            return reply.status(500).send({ error: 'Erro ao buscar métricas SNMP' });
-        }
-    });
-    fastify.get('/api/services/:id/metrics/http', {
-        schema: {
-            description: 'Obter métricas HTTP do serviço pela última hora',
-            tags: ['Services'],
-            params: {
-                type: 'object',
-                properties: { id: { type: 'string' } },
-                required: ['id']
-            }
-        }
-    }, async (request, reply) => {
-        try {
-            const { id } = request.params;
-            return await (0, serviceMetrics_1.getHttpMetrics)(id);
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao buscar métricas HTTP' });
-        }
-    });
-    fastify.get('/api/services/:id/metrics/webhook', {
-        schema: {
-            description: 'Obter métricas Webhook do serviço pela última hora',
-            tags: ['Services'],
-            params: {
-                type: 'object',
-                properties: { id: { type: 'string' } },
-                required: ['id']
-            }
-        }
-    }, async (request, reply) => {
-        try {
-            const { id } = request.params;
-            return await (0, serviceMetrics_1.getWebhookMetrics)(id);
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao buscar métricas Webhook' });
-        }
-    });
-    fastify.get('/api/services/:id/metrics/ping', {
-        schema: {
-            description: 'Obter métricas de PING do serviço pela última hora',
-            tags: ['Services'],
-            params: {
-                type: 'object',
-                properties: { id: { type: 'string' } },
-                required: ['id']
-            }
-        }
-    }, async (request, reply) => {
-        try {
-            const { id } = request.params;
-            const metrics = await (0, serviceMetrics_1.getPingMetrics)(id);
-            return metrics;
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao buscar métricas PING' });
-        }
-    });
-}
diff --git a/dist/routes/APIs/servicesRoutes.js b/dist/routes/APIs/servicesRoutes.js
deleted file mode 100644
index cabf4d0..0000000
--- a/dist/routes/APIs/servicesRoutes.js
+++ /dev/null
@@ -1,131 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.servicesRoutes = servicesRoutes;
-const services_1 = require("../../Controllers/APIs/services");
-const addServices_1 = require("../../Controllers/APIs/addServices");
-const deleteServices_1 = require("../../Controllers/APIs/deleteServices");
-async function servicesRoutes(fastify) {
-    // 📌 ROTA: GET /api/services - Listar todos os serviços
-    fastify.get('/api/services', {
-        schema: {
-            description: 'Lista todos os serviços',
-            tags: ['Services'],
-            response: {
-                200: {
-                    type: 'array',
-                    items: {
-                        type: 'object',
-                        properties: {
-                            id: { type: 'string' },
-                            name: { type: 'string' },
-                            type: { type: 'string' },
-                            target: { type: 'string' },
-                        }
-                    }
-                }
-            }
-        }
-    }, async (request, reply) => {
-        try {
-            const services = await (0, services_1.getAllServices)();
-            return services;
-        }
-        catch (error) {
-            request.log.error(error);
-            reply.status(500).send({ error: 'Erro ao listar serviços' });
-        }
-    });
-    // 📌 ROTA: POST /api/addServices/:ownerId - Criar novo serviço
-    fastify.post('/api/addServices/:ownerId', {
-        schema: {
-            description: 'Adicionar novo serviço',
-            tags: ['Services'],
-            params: {
-                type: 'object',
-                properties: {
-                    ownerId: { type: 'string', description: 'ID do usuário dono do serviço' }
-                },
-                required: ['ownerId']
-            },
-            body: {
-                type: 'object',
-                required: ['name', 'type', 'target'],
-                properties: {
-                    name: { type: 'string', description: 'Nome do serviço' },
-                    type: {
-                        type: 'string',
-                        enum: ['HTTP', 'PING', 'SNMP', 'WEBHOOK'],
-                        description: 'Tipo de serviço a ser monitorado'
-                    },
-                    target: { type: 'string', description: 'Endereço ou destino do serviço' }
-                }
-            },
-            response: {
-                201: {
-                    description: 'Serviço criado com sucesso',
-                    type: 'object',
-                    properties: {
-                        id: { type: 'string' },
-                        name: { type: 'string' },
-                        type: { type: 'string' },
-                        target: { type: 'string' },
-                        ownerId: { type: 'string' },
-                        createdAt: { type: 'string', format: 'date-time' },
-                        updatedAt: { type: 'string', format: 'date-time' },
-                    }
-                },
-                400: {
-                    description: 'Erro ao criar serviço',
-                    type: 'object',
-                    properties: {
-                        message: { type: 'string' }
-                    }
-                }
-            }
-        }
-    }, addServices_1.addService);
-    // 📌 ROTA: DELETE /api/deleteService/:ownerId/:serviceId - Deletar um serviço
-    fastify.delete('/api/deleteService/:ownerId/:serviceId', {
-        schema: {
-            description: 'Deleta um serviço pertencente a um usuário',
-            tags: ['Services'],
-            params: {
-                type: 'object',
-                required: ['ownerId', 'serviceId'],
-                properties: {
-                    ownerId: { type: 'string', description: 'ID do dono do serviço' },
-                    serviceId: { type: 'string', description: 'ID do serviço a ser deletado' }
-                }
-            },
-            response: {
-                200: {
-                    description: 'Serviço deletado com sucesso',
-                    type: 'object',
-                    properties: {
-                        id: { type: 'string' },
-                        name: { type: 'string' },
-                        type: { type: 'string' },
-                        target: { type: 'string' },
-                        ownerId: { type: 'string' },
-                        createdAt: { type: 'string', format: 'date-time' },
-                        updatedAt: { type: 'string', format: 'date-time' }
-                    }
-                },
-                404: {
-                    description: 'Serviço não encontrado ou não pertence ao usuário',
-                    type: 'object',
-                    properties: {
-                        message: { type: 'string' }
-                    }
-                },
-                500: {
-                    description: 'Erro interno ao tentar deletar o serviço',
-                    type: 'object',
-                    properties: {
-                        message: { type: 'string' }
-                    }
-                }
-            }
-        }
-    }, deleteServices_1.deleteService);
-}
diff --git a/dist/routes/APIs/slaRoutes.js b/dist/routes/APIs/slaRoutes.js
deleted file mode 100644
index dca4237..0000000
--- a/dist/routes/APIs/slaRoutes.js
+++ /dev/null
@@ -1,76 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.slaRoutes = slaRoutes;
-const slaService_1 = require("../../Monitoring/SlaTracking/slaService");
-const slaReportGenerator_1 = require("../../Monitoring/SlaTracking/slaReportGenerator");
-const client_1 = require("@prisma/client");
-const prisma = new client_1.PrismaClient();
-async function slaRoutes(app) {
-    app.get("/sla/:serviceId/:period", {
-        schema: {
-            tags: ["SLA"],
-            summary: "Gerar relatório de SLA de um serviço",
-            params: {
-                type: "object",
-                properties: {
-                    serviceId: { type: "string" },
-                    period: {
-                        type: "string",
-                        description: "Período (ex: 'last-7d', 'last-30d', '2025-01')"
-                    },
-                },
-                required: ["serviceId", "period"],
-            },
-            querystring: {
-                type: "object",
-                properties: {
-                    format: {
-                        type: "string",
-                        enum: ["json", "pdf"],
-                        default: "json"
-                    },
-                },
-            },
-            response: {
-                200: {
-                    oneOf: [
-                        {
-                            type: "object",
-                            properties: {
-                                service: { type: "string" },
-                                period: { type: "string" },
-                                sla: {
-                                    type: "object",
-                                    properties: {
-                                        uptimePercentage: { type: "number" },
-                                        downtimeMinutes: { type: "number" },
-                                        incidents: { type: "array", items: { type: "object" } },
-                                    },
-                                },
-                            },
-                        },
-                        { type: "string", description: "PDF stream" },
-                    ],
-                },
-            },
-        },
-        handler: async (req, reply) => {
-            const { serviceId, period } = req.params;
-            const { format } = req.query;
-            // Buscar serviço
-            const service = await prisma.service.findUnique({ where: { id: serviceId } });
-            if (!service)
-                return reply.status(404).send({ error: "Serviço não encontrado" });
-            // Calcular período e gerar SLA
-            const { start, end } = slaService_1.SlaService.parsePeriod(period);
-            const sla = await slaService_1.SlaService.getSlaReport(serviceId, start, end);
-            if (format === "pdf") {
-                const pdfBuffer = await slaReportGenerator_1.SlaReportGenerator.generatePDF(service.name, sla, start, end);
-                reply.header("Content-Type", "application/pdf");
-                reply.header("Content-Disposition", `attachment; filename="sla-${service.name}-${period}.pdf"`);
-                return reply.send(pdfBuffer);
-            }
-            return { service: service.name, period, sla };
-        },
-    });
-}
diff --git a/dist/server.js b/dist/server.js
deleted file mode 100644
index a39f8db..0000000
--- a/dist/server.js
+++ /dev/null
@@ -1,46 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-const fastify_1 = __importDefault(require("fastify"));
-const localtunnel_1 = __importDefault(require("localtunnel"));
-const socket_1 = require("./socket");
-const fastify_swagger_1 = __importDefault(require("fastify-swagger"));
-const worker_1 = require("./Monitoring/Workers/worker");
-const RegisterRoutes_1 = require("./RegisterRoutes/RegisterRoutes");
-const PORT = Number(process.env.PORT) || 3000;
-const SUBDOMAIN = process.env.LOCALTUNNEL_SUBDOMAIN;
-const server = (0, fastify_1.default)({ logger: false });
-server.register(fastify_swagger_1.default, {
-    routePrefix: '/docs',
-    swagger: {
-        info: { title: 'InfraWatch API', description: 'API do InfraWatch', version: '0.1.0' },
-        host: `localhost:${PORT}`,
-        schemes: ['http'],
-        consumes: ['application/json'],
-        produces: ['application/json'],
-    },
-    exposeRoute: true,
-});
-const start = async () => {
-    try {
-        (0, RegisterRoutes_1.RegisterAllRoutes)(server);
-        (0, socket_1.initSocket)(server.server);
-        await (0, worker_1.startMonitoring)();
-        await server.listen(PORT, '0.0.0.0');
-        console.log(`Servidor Fastify rodando em http://localhost:${PORT}`);
-        console.log(`Documentação disponível em http://localhost:${PORT}/docs`);
-        const tunnel = await (0, localtunnel_1.default)({ port: PORT, subdomain: SUBDOMAIN });
-        console.log(`Servidor exposto publicamente em ${tunnel.url}`);
-        console.log(`Documentação disponível em ${tunnel.url}/docs`);
-        tunnel.on('close', () => {
-            console.log('Túnel Localtunnel fechado');
-        });
-    }
-    catch (err) {
-        server.log.error(err);
-        process.exit(1);
-    }
-};
-start();
diff --git a/dist/socket.js b/dist/socket.js
deleted file mode 100644
index 7c780b3..0000000
--- a/dist/socket.js
+++ /dev/null
@@ -1,27 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.initSocket = initSocket;
-exports.getIO = getIO;
-const socket_io_1 = require("socket.io");
-let io = null;
-function initSocket(server) {
-    io = new socket_io_1.Server(server, {
-        cors: {
-            origin: '*',
-        },
-    });
-    io.on('connection', (socket) => {
-        console.log(`Cliente conectado: ${socket.id}`);
-        socket.emit("teste", "ok");
-        socket.on('disconnect', () => {
-            console.log(`Cliente desconectado: ${socket.id}`);
-        });
-    });
-    return io;
-}
-function getIO() {
-    if (!io) {
-        throw new Error("Socket.io não foi inicializado ainda!");
-    }
-    return io;
-}
diff --git a/dist/types/Problem.js b/dist/types/Problem.js
deleted file mode 100644
index c8ad2e5..0000000
--- a/dist/types/Problem.js
+++ /dev/null
@@ -1,2 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/dist/types/ProxyData.js b/dist/types/ProxyData.js
deleted file mode 100644
index c8ad2e5..0000000
--- a/dist/types/ProxyData.js
+++ /dev/null
@@ -1,2 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/merge1.txt b/merge1.txt
new file mode 100644
index 0000000..ace2054
--- /dev/null
+++ b/merge1.txt
@@ -0,0 +1,236 @@
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % npm run dev
+
+> infrawatch@1.0.0 dev
+> tsx watch src/server.ts
+
+InfraWatch Em Acção...
+Agendador de monitoramento iniciado...
+Servidor Fastify rodando em http://localhost:3002
+Documentação disponível em http://localhost:3002/docs
+Servidor Fastify exposto publicamente em https://infrawatch.loca.lt
+Documentação disponível em https://infrawatch.loca.lt/docs
+Job 1852 concluído para serviço Google
+Job 1851 concluído para serviço NeonDB
+Job 1853 concluído para serviço Router
+Job 1848 concluído para serviço NeonDB
+Job 1849 concluído para serviço Google
+Job 1850 concluído para serviço Router
+Job 1856 concluído para serviço Router
+Job 1855 concluído para serviço Google
+Job 1854 concluído para serviço NeonDB
+Job 1857 concluído para serviço NeonDB
+Job 1858 concluído para serviço Google
+Job 1859 concluído para serviço Router
+Job 1860 concluído para serviço NeonDB
+Job 1861 concluído para serviço Google
+Job 1862 concluído para serviço Router
+Job 1863 concluído para serviço NeonDB
+Job 1864 concluído para serviço Google
+Job 1865 concluído para serviço Router
+Job 1866 concluído para serviço NeonDB
+Job 1871 concluído para serviço Router
+Job 1873 concluído para serviço Google
+^C1:19:10 PM [tsx] Previous process hasn't exited yet. Force killing...
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % 
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % git checkout GLPI-INIT 
+Branch 'GLPI-INIT' set up to track remote branch 'GLPI-INIT' from 'origin'.
+Switched to a new branch 'GLPI-INIT'
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % git fetch origin
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % git merge origin/main
+Auto-merging src/server.ts
+CONFLICT (content): Merge conflict in src/server.ts
+Auto-merging src/Monitoring/Workers/worker2.ts
+CONFLICT (content): Merge conflict in src/Monitoring/Workers/worker2.ts
+Auto-merging src/Monitoring/Workers/slaWorker.ts
+CONFLICT (content): Merge conflict in src/Monitoring/Workers/slaWorker.ts
+Removing src/Monitoring/Checkers/CheckSNMP.ts
+Removing src/Monitoring/Checkers/CheckHTTP.ts
+Auto-merging src/Controllers/APIs/addServices.ts
+Removing sla_report.pdf
+Auto-merging prisma/schema.prisma
+CONFLICT (content): Merge conflict in prisma/schema.prisma
+Removing prisma/migrations/20250815060430_update/migration.sql
+Removing prisma/migrations/20250815055606_update/migration.sql
+Removing prisma/migrations/20250814230322_merge_user_service_sla/migration.sql
+Removing prisma/migrations/20250814225513_update/migration.sql
+Auto-merging package.json
+CONFLICT (content): Merge conflict in package.json
+Auto-merging package-lock.json
+CONFLICT (content): Merge conflict in package-lock.json
+Removing dist/socket.js
+Removing dist/server.js
+Removing dist/routes/Auth/loginRoutes.js
+Removing dist/routes/Auth/VerifyOTPRoutes.js
+Removing dist/routes/Auth/SolicitarResetPasswordRoutes.js
+Removing dist/routes/Auth/ResetPasswordRoutes.js
+Removing dist/routes/Auth/RegisterRoutes.js
+Removing dist/routes/APIs/servicesRoutes.js
+Removing dist/routes/APIs/serviceMetricsRoutes.js
+Removing dist/routes/APIs/notificationRoutes.js
+Removing dist/plugins/prisma.js
+Removing dist/plugins/jwt.js
+Removing dist/influxdb.js
+Removing dist/Notifications/Twilio/TwilioProvider.js
+Removing dist/Notifications/Telegram/TelegramProvider.js
+Removing dist/Notifications/Slack/SlackProvider.js
+Removing dist/Notifications/INotificationProvider.js
+Removing dist/Notifications/Email/EmailProvider.js
+Removing dist/Monitoring/Workers/worker.js
+Removing dist/Monitoring/Workers/utils_worker2.js
+Removing dist/Monitoring/Workers/utills_worker.js
+Removing dist/Monitoring/Checkers/CheckWEBHOOK.js
+Removing dist/Monitoring/Checkers/CheckSNMP.js
+Removing dist/Monitoring/Checkers/CheckPING.js
+Removing dist/Monitoring/Checkers/CheckHTTP.js
+Removing dist/Controllers/Auth/login.js
+Removing dist/Controllers/Auth/VerifyOTP.js
+Removing dist/Controllers/Auth/SolicitarResetPassword.js
+Removing dist/Controllers/Auth/ResetPassword.js
+Removing dist/Controllers/Auth/Register.js
+Removing dist/Controllers/APIs/services.js
+Removing dist/Controllers/APIs/serviceMetrics.js
+Removing dist/Controllers/APIs/Notification.js
+Removing dist/AllRoutes/RegisterAllRoutes.js
+Removing README.md
+Auto-merging .env
+CONFLICT (content): Merge conflict in .env
+Automatic merge failed; fix conflicts and then commit the result.
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % git status
+On branch GLPI-INIT
+Your branch is up to date with 'origin/GLPI-INIT'.
+
+You have unmerged paths.
+  (fix conflicts and run "git commit")
+  (use "git merge --abort" to abort the merge)
+
+Changes to be committed:
+	deleted:    README.md
+	deleted:    dist/AllRoutes/RegisterAllRoutes.js
+	deleted:    dist/Controllers/APIs/Notification.js
+	deleted:    dist/Controllers/APIs/serviceMetrics.js
+	deleted:    dist/Controllers/APIs/services.js
+	deleted:    dist/Controllers/Auth/Register.js
+	deleted:    dist/Controllers/Auth/ResetPassword.js
+	deleted:    dist/Controllers/Auth/SolicitarResetPassword.js
+	deleted:    dist/Controllers/Auth/VerifyOTP.js
+	deleted:    dist/Controllers/Auth/login.js
+	deleted:    dist/Monitoring/Checkers/CheckHTTP.js
+	deleted:    dist/Monitoring/Checkers/CheckPING.js
+	deleted:    dist/Monitoring/Checkers/CheckSNMP.js
+	deleted:    dist/Monitoring/Checkers/CheckWEBHOOK.js
+	deleted:    dist/Monitoring/Workers/utills_worker.js
+	deleted:    dist/Monitoring/Workers/utils_worker2.js
+	deleted:    dist/Monitoring/Workers/worker.js
+	deleted:    dist/Notifications/Email/EmailProvider.js
+	deleted:    dist/Notifications/INotificationProvider.js
+	deleted:    dist/Notifications/Slack/SlackProvider.js
+	deleted:    dist/Notifications/Telegram/TelegramProvider.js
+	deleted:    dist/Notifications/Twilio/TwilioProvider.js
+	deleted:    dist/influxdb.js
+	deleted:    dist/plugins/jwt.js
+	deleted:    dist/plugins/prisma.js
+	deleted:    dist/routes/APIs/notificationRoutes.js
+	deleted:    dist/routes/APIs/serviceMetricsRoutes.js
+	deleted:    dist/routes/APIs/servicesRoutes.js
+	deleted:    dist/routes/Auth/RegisterRoutes.js
+	deleted:    dist/routes/Auth/ResetPasswordRoutes.js
+	deleted:    dist/routes/Auth/SolicitarResetPasswordRoutes.js
+	deleted:    dist/routes/Auth/VerifyOTPRoutes.js
+	deleted:    dist/routes/Auth/loginRoutes.js
+	deleted:    dist/server.js
+	deleted:    dist/socket.js
+	deleted:    prisma/migrations/20250814225513_update/migration.sql
+	deleted:    prisma/migrations/20250814230322_merge_user_service_sla/migration.sql
+	deleted:    prisma/migrations/20250815055606_update/migration.sql
+	deleted:    prisma/migrations/20250815060430_update/migration.sql
+	new file:   prisma/migrations/20250824205132_update/migration.sql
+	modified:   prisma/migrations/migration_lock.toml
+	deleted:    sla_report.pdf
+	new file:   src/Analyzers/HttpIssueAnalyzer.ts
+	new file:   src/Analyzers/PingIssueAnalyzer.ts
+	new file:   src/Analyzers/analyzeSnmpIssue.ts
+	new file:   src/Analyzers/analyzeWebhookIssue.ts
+	modified:   src/Controllers/APIs/addServices.ts
+	modified:   src/Influxdb/WriteMetrics/WriteSnmpMetrics.ts
+	new file:   src/Influxdb/WriteMetrics/WriteWebhookEvent.ts
+	modified:   src/Influxdb/WriteMetrics/WriteWebhookMetrics.ts
+	renamed:    src/Monitoring/Checkers/CheckPING.ts -> src/Monitoring/Checkers/.nfs00000001c1686fb20000003b
+	deleted:    src/Monitoring/Checkers/CheckHTTP.ts
+	deleted:    src/Monitoring/Checkers/CheckSNMP.ts
+	modified:   src/Monitoring/Checkers/CheckWEBHOOK.ts
+	new file:   "src/Monitoring/Integra\303\247\303\265esExternas/GLPI/GlpiClients.ts"
+	modified:   src/Monitoring/Queue/jobQueue.ts
+	modified:   src/Monitoring/Queue/monitoringWorker.ts
+	modified:   src/Monitoring/SlaTracking/slaReportGenerator.ts
+	modified:   src/RegisterRoutes/RegisterRoutes.ts
+	new file:   src/config/snmpConfig.ts
+	renamed:    src/routes/APIs/incidents.ts -> src/routes/APIs/IncidentsRoutes.ts
+	new file:   src/routes/APIs/proxyReceiverRoutes.ts
+	modified:   src/routes/APIs/slaRoutes.ts
+	modified:   src/routes/APIs/webhookReceiver.ts
+	new file:   src/types/Problem.ts
+	new file:   src/types/ProxyData.ts
+	modified:   src/types/net-snmp.d.ts
+	new file:   src/types/pdfkit.d.ts
+
+Unmerged paths:
+  (use "git add <file>..." to mark resolution)
+	both modified:   .env
+	both modified:   package-lock.json
+	both modified:   package.json
+	both modified:   prisma/schema.prisma
+	both modified:   src/Monitoring/Workers/slaWorker.ts
+	both modified:   src/Monitoring/Workers/worker2.ts
+	both modified:   src/server.ts
+
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % git add .
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % git commit 
+[GLPI-INIT 14f43d5] Merge remote-tracking branch 'origin/main' into GLPI-INIT
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % npm run dev           
+
+> infrawatch@1.0.0 dev
+> tsx watch src/server.ts
+
+node:internal/modules/cjs/loader:1212
+  const err = new Error(message);
+              ^
+
+Error: Cannot find module 'node-cron'
+Require stack:
+- /Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/src/server.ts
+    at Module._resolveFilename (node:internal/modules/cjs/loader:1212:15)
+    at nextResolveSimple (/Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/node_modules/tsx/dist/register-D46fvsV_.cjs:4:1004)
+    at /Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/node_modules/tsx/dist/register-D46fvsV_.cjs:3:2630
+    at /Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/node_modules/tsx/dist/register-D46fvsV_.cjs:3:1542
+    at resolveTsPaths (/Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/node_modules/tsx/dist/register-D46fvsV_.cjs:4:760)
+    at /Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/node_modules/tsx/dist/register-D46fvsV_.cjs:4:1102
+    at m._resolveFilename (file:///Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/node_modules/tsx/dist/register-B7jrtLTO.mjs:1:789)
+    at Module._load (node:internal/modules/cjs/loader:1043:27)
+    at Module.require (node:internal/modules/cjs/loader:1298:19)
+    at require (node:internal/modules/helpers:182:18) {
+  code: 'MODULE_NOT_FOUND',
+  requireStack: [
+    '/Users/nunomendes/Desktop/Desenvolvimento/Hackathon_RCS/InfraWatch/src/server.ts'
+  ]
+}
+
+Node.js v20.19.4
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % 
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % npm install
+
+added 7 packages, and audited 707 packages in 6s
+
+104 packages are looking for funding
+  run `npm fund` for details
+
+9 vulnerabilities (5 low, 2 moderate, 2 high)
+
+To address issues that do not require attention, run:
+  npm audit fix
+
+To address all issues (including breaking changes), run:
+  npm audit fix --force
+
+Run `npm audit` for details.
+nunomendes@MacBook-Pro-de-Nuno InfraWatch % 
+
diff --git a/oQueFoiAtualizado.md b/oQueFoiAtualizado.md
deleted file mode 100644
index 34f7790..0000000
--- a/oQueFoiAtualizado.md
+++ /dev/null
@@ -1,135 +0,0 @@
-InfraWatch → InfraWatch2: Relatório de Mudanças
-
-Resumo das principais alterações entre as pastas `InfraWatch` (antigo) e `InfraWatch2` (atual):
-
-- Foco reduzido e simplificação: autenticação e partes do sistema de escalonamento/SLI foram removidos no `InfraWatch2`.
-- Rotas reorganizadas: adição e remoção de serviços migraram para o módulo de rotas de serviços; rotas de autenticação foram retiradas.
-- Fila (BullMQ) simplificada: apenas enfileiramento de verificação de serviço; remoção de jobs de retry/escalation/SLI e utilitários de limpeza/admin.
-- Métricas Influx simplificadas: campos de escalonamento/SLI removidos; grava apenas `isUp` e `latency_ms` além do `serviceId` tag.
-- Prisma/Schema: remoção de campos e enums (ex.: `escalationLevel`, `escalationChain`, `Role`, `WEBHOOK`), além de redução de tabelas relacionadas a Ticket/Webhook/User.
-- Server/Env: usa `PORT` (antes `PORT1`) e abre LocalTunnel incondicionalmente.
-- Scripts NPM: scripts de banco (`migrate`, `db:push`, `seed`) foram removidos do `InfraWatch2`.
-
-Arquivos e Rotas
-
-- Removido (existia no `InfraWatch`, não existe no `InfraWatch2`):
-  - Rotas de autenticação: `src/routes/Auth/*` e controladores `src/Controllers/Auth/*`.
-  - Rotas: `src/routes/APIs/addServiceRoutes.ts`, `src/routes/APIs/queueAdminRoutes.ts`.
-  - Monitoramento/Incidentes: `src/Monitoring/Incidents/escalationManager.ts`.
-  - SLI: `src/Monitoring/SlaTracking/sliEvaluator.ts`.
-  - Tipos: `src/types/net-snmp.d.ts`.
-  - Utilitários de fila: purga, métricas e enfileiramentos de retry/escalation/SLI em `src/Monitoring/Queue/jobQueue.ts` (removidos no `InfraWatch2`).
-
-- Adicionado/Movido (novo no `InfraWatch2`):
-  - `src/Controllers/APIs/deleteServices.ts` (nova ação de exclusão de serviço).
-  - `src/routes/APIs/servicesRoutes.ts` agora agrega também POST de criação e DELETE de remoção (substitui o antigo `addServiceRoutes.ts`).
-
-- Alterado:
-  - `src/RegisterRoutes/RegisterRoutes.ts`: remoção do registro de rotas de autenticação e de `addServiceRoutes`/`queueAdminRoutes`.
-  - `src/Monitoring/Workers/worker.ts`: remove checagens/flags (ex.: `DISABLE_SCHEDULER`, limpeza de fila e verificação de Redis) e passa a carregar worker e scheduler de forma direta.
-  - `src/Influxdb/WriteMetrics/WriteServiceStatus.ts`: remove campos extra (escalonamento/SLI) e logs; mantém status e latência.
-  - `src/server.ts`:
-    - Usa `PORT` (antes `PORT1`).
-    - Modo de túnel: no `InfraWatch2` o LocalTunnel é aberto sempre (antes dependia de `ENABLE_TUNNEL=true`).
-
-Schema Prisma (Diferenças)
-
-Comparação entre `InfraWatch/prisma/schema.prisma` (antigo) e `InfraWatch2/prisma/schema.prisma` (novo):
-
-- Model `Service`:
-  - Mantidos: `id`, `name`, `type`, `target`, `ownerId`, `createdAt`, `updatedAt`, `glpiId? @unique`, `snmpCommunity?`, `snmpPort? @default(161)` e relações.
-  - Índices se mantêm: `@@index([ownerId])` e `@@index([type])`.
-
-- Model `Incident`:
-  - `InfraWatch` (antigo): possuía `escalationLevel Int @default(0)`, `nextRetryAt DateTime?`, `lastEscalationAt DateTime?`, além de `glpiTicketId?` e `glpiTicketUrl?` via migração.
-  - `InfraWatch2` (novo): removeu os campos de escalonamento e GLPI; ficou apenas com: `id`, `serviceId`, `openedAt`, `closedAt?`, `reason?`, `retryCount @default(0)`, `lastNotificationAt?` e relação.
-
-- Model `NotificationPolicy`:
-  - `InfraWatch` (antigo): incluía `escalationChain Json?`.
-  - `InfraWatch2` (novo): remove `escalationChain`; mantém `maxRetries`, `retryIntervalMinutes`, `escalateAfterMinutes`, `cooldownMinutes`, `recoveryConfirmations`, `channels[]`, `active`, `isDefault`, timestamps e relação opcional com `Service`.
-
-- Enums:
-  - `InfraWatch` (antigo): `enum Role { ADMIN USER }` e `enum ServiceType { HTTP PING SNMP WEBHOOK }`.
-  - `InfraWatch2` (novo): remove `Role` e reduz `ServiceType` para `{ HTTP PING SNMP }` (remove `WEBHOOK`).
-
-- Tabelas colaterais (conforme histórico de migração):
-  - `InfraWatch` removeu tabelas `User`, `Ticket`, `WebhookEvent` e seus enums (`TicketPrioridade`, `TicketStatus`) via migração posterior.
-  - `InfraWatch2` não define esses modelos no schema atual.
-
-Migrações (Prisma)
-
-- `InfraWatch/prisma/migrations`:
-  - `20250824205132_update` (criação inicial – inclui `User`, `Ticket`, `WebhookEvent`, `Role`, `Ticket*`, etc.).
-  - `20250904145544_add_glpi_ticket_id` (remove `User`, `Ticket`, `WebhookEvent` e enums `Ticket*`).
-  - `20250904150000_schema_sync` (sincroniza com o schema: adiciona `snmpCommunity`, `snmpPort`, `glpiId` únicos em `Service`; adiciona `glpiTicketId`, `glpiTicketUrl`, `escalationLevel`, `nextRetryAt`, `lastEscalationAt` em `Incident`; adiciona `escalationChain` em `NotificationPolicy`).
-
-- `InfraWatch2/prisma/migrations`:
-  - Apenas `20250824205132_update` (antigo inicial); o conjunto de migrações não reflete o schema atual simplificado (não há migração que remova `User/Ticket/WebhookEvent` etc.).
-
-Observação: o `InfraWatch2` está com `schema.prisma` simplificado, porém com diretório de migrações desatualizado em relação ao schema. É recomendável gerar novas migrações alinhadas ao schema atual antes de deploy.
-
-Fila de Processamento (BullMQ)
-
-- `InfraWatch` (antigo):
-  - `jobQueue.ts` com múltiplos tipos de job: `check`, `retry`, `escalation`, `sli_evaluation`, utilitários de métricas/limpeza (`getQueueMetrics`, `cleanupOldJobs`, `purgeAllJobs`).
-  - `worker.ts` com flags/robustez: `DISABLE_SCHEDULER`, limpeza condicional da fila (`CLEAR_QUEUE_ON_START`), verificação de Redis.
-
-- `InfraWatch2` (novo):
-  - `jobQueue.ts` reduzido para `enqueueServiceCheck` apenas (sem retry/escalation/SLI).
-  - `worker.ts` sempre inicia o worker e o scheduler, sem as proteções/flags do anterior.
-
-Métricas (InfluxDB)
-
-- `InfraWatch` (antigo): gravava status com campos adicionais (ex.: `escalationLevel`, `incidentId`, `sliStatus`, `violationCount`, `response_time`, `availability`).
-- `InfraWatch2` (novo): grava apenas `isUp` e `latency_ms` (além do tag `serviceId`).
-
-Servidor e Ambiente
-
-- Porta:
-  - `InfraWatch`: `src/server.ts` usava `PORT1` (com fallback 3000).
-  - `InfraWatch2`: `src/server.ts` usa `PORT` (com fallback 3000). Ajustar `.env` para refletir isso; o `InfraWatch2` ainda contém `PORT1`, mas o código lê `PORT`.
-
-- LocalTunnel:
-  - `InfraWatch`: túnel era opcional (dependia de `ENABLE_TUNNEL`).
-  - `InfraWatch2`: túnel é inicializado sempre (subdomínio segue `LOCALTUNNEL_SUBDOMAIN`).
-
-Dependências e Scripts
-
-- `package.json`:
-  - `InfraWatch` tinha scripts de banco: `migrate`, `db:push`, `seed`.
-  - `InfraWatch2` removeu esses scripts; versões de dependências são praticamente equivalentes (pequena variação em `@types/node`).
-
-Impacto Funcional
-
-- Autenticação: rotas de login/cadastro/OTP/reset foram removidas no `InfraWatch2`. O plugin JWT permanece carregado, mas não é exposto por rotas próprias nesta versão.
-- Gestão de incidentes: removidos campos e lógica de escalonamento e próximos retries.
-- Políticas de notificação: removido `escalationChain` e métodos auxiliares associados.
-- Serviços: criação e remoção consolidadas em `servicesRoutes`; nova rota DELETE (`/api/deleteService/:ownerId/:serviceId`).
-
-Listas de Arquivos (diferenças relevantes em `src`)
-
-- Apenas no `InfraWatch2` (novo):
-  - `src/Controllers/APIs/deleteServices.ts`.
-
-- Apenas no `InfraWatch` (antigo):
-  - `src/Controllers/Auth/*` e `src/routes/Auth/*`.
-  - `src/routes/APIs/addServiceRoutes.ts`, `src/routes/APIs/queueAdminRoutes.ts`.
-  - `src/Monitoring/Incidents/escalationManager.ts`.
-  - `src/Monitoring/SlaTracking/sliEvaluator.ts`.
-  - `src/types/net-snmp.d.ts`.
-
-Notas de Migração/Recomendações
-
-- Banco de Dados (Prisma):
-  - No `InfraWatch2`, gerar migrações atualizadas para refletir o schema atual (que remove `User/Ticket/WebhookEvent`, enums correlatos e campos de escalonamento/GLPI em `Incident`).
-  - Atenção: remoções implicam perda de dados desses objetos/colunas. Faça backup antes de aplicar migrações destrutivas.
-
-- Configuração/Env:
-  - Atualizar `.env` para usar `PORT` (o servidor novo ignora `PORT1`).
-  - Decidir se o LocalTunnel deve ser opcional; se sim, reintroduzir flag de controle (ex.: `ENABLE_TUNNEL`).
-
-- Fila/Workers:
-  - Se a estratégia de escalonamento e retries for necessária, considerar reintroduzir os jobs e utilitários removidos ou documentar a nova filosofia operacional (ex.: apenas checagens periódicas sem retries automáticos).
-
-- Observação de segurança: os exemplos de `.env` das pastas contêm credenciais sensíveis. Trate-os como secretos e rotacione-os se tiverem sido expostos.
-
diff --git a/package-lock.json b/package-lock.json
index 1617ade..4425545 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -15,17 +15,18 @@
         "@grpc/proto-loader": "^0.8.0",
         "@influxdata/influxdb-client": "^1.35.0",
         "@prisma/client": "^6.13.0",
-        "@types/localtunnel": "^2.0.4",
         "axios": "^1.11.0",
         "bcrypt": "^6.0.0",
         "bullmq": "^5.58.0",
         "fastify": "^3.29.5",
+        "fastify-env": "^2.1.1",
         "fastify-jwt": "^4.1.3",
         "fastify-swagger": "^5.1.1",
         "install": "^0.13.0",
         "localtunnel": "^2.0.2",
         "net-snmp": "^3.23.0",
         "ngrok": "^5.0.0-beta.2",
+        "node-cron": "^4.2.1",
         "nodemailer": "^7.0.5",
         "pdfkit": "^0.17.1",
         "ping": "^0.4.4",
@@ -38,7 +39,8 @@
         "@types/bcrypt": "^6.0.0",
         "@types/jest": "^30.0.0",
         "@types/jsonwebtoken": "^9.0.10",
-        "@types/node": "^24.3.0",
+        "@types/localtunnel": "^2.0.4",
+        "@types/node": "^24.2.1",
         "@types/nodemailer": "^6.4.17",
         "@types/ping": "^0.4.4",
         "@types/supertest": "^6.0.3",
@@ -2499,6 +2501,7 @@
       "version": "2.0.4",
       "resolved": "https://registry.npmjs.org/@types/localtunnel/-/localtunnel-2.0.4.tgz",
       "integrity": "sha512-7WM5nlEfEKp8MpwthPa2utdy+f/7ZBxMPzu8qw6EijFFTcpzh5CXgt2YoncxWAZNOPNieMofXCKFudtDEY4bag==",
+      "dev": true,
       "license": "MIT",
       "dependencies": {
         "@types/node": "*"
@@ -2519,9 +2522,9 @@
       "license": "MIT"
     },
     "node_modules/@types/node": {
-      "version": "24.3.0",
-      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.3.0.tgz",
-      "integrity": "sha512-aPTXCrfwnDLj4VvXrm+UUCQjNEvJgNA8s5F1cvwQU+3KNltTOkBm1j30uNLyqqPNe7gE3KFzImYoZEfLhp4Yow==",
+      "version": "24.2.1",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.2.1.tgz",
+      "integrity": "sha512-DRh5K+ka5eJic8CjH7td8QpYEV6Zo10gfRkjHCO3weqZHWDtAaSTFtl4+VMqOJ4N5jcuhZ9/l+yy8rVgw7BQeQ==",
       "license": "MIT",
       "dependencies": {
         "undici-types": "~7.10.0"
@@ -4025,6 +4028,12 @@
         "url": "https://dotenvx.com"
       }
     },
+    "node_modules/dotenv-expand": {
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/dotenv-expand/-/dotenv-expand-5.1.0.tgz",
+      "integrity": "sha512-YXQl1DSa4/PQyRfgrv6aoNjhasp/p4qs9FjJ4q4cQk+8m4r6k4ZSiEyytKG8f8W9gi8WsQtIObNmKd+tMzNTmA==",
+      "license": "BSD-2-Clause"
+    },
     "node_modules/dunder-proto": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
@@ -4179,6 +4188,48 @@
         }
       }
     },
+    "node_modules/env-schema": {
+      "version": "3.5.2",
+      "resolved": "https://registry.npmjs.org/env-schema/-/env-schema-3.5.2.tgz",
+      "integrity": "sha512-mSCYvxQLrJ3Z641CpCSvU2UIFPjDNqZ9yUfqWdx2FMXfccWtYrJEa+pR9mc3YyINvmnlXdbmD5fBx1NSlipMfw==",
+      "license": "MIT",
+      "dependencies": {
+        "ajv": "^8.0.0",
+        "dotenv": "^11.0.0",
+        "dotenv-expand": "^5.1.0"
+      }
+    },
+    "node_modules/env-schema/node_modules/ajv": {
+      "version": "8.17.1",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.17.1.tgz",
+      "integrity": "sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==",
+      "license": "MIT",
+      "dependencies": {
+        "fast-deep-equal": "^3.1.3",
+        "fast-uri": "^3.0.1",
+        "json-schema-traverse": "^1.0.0",
+        "require-from-string": "^2.0.2"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/epoberezkin"
+      }
+    },
+    "node_modules/env-schema/node_modules/dotenv": {
+      "version": "11.0.0",
+      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-11.0.0.tgz",
+      "integrity": "sha512-Fp/b504Y5W+e+FpCxTFMUZ7ZEQkQYF0rx+KZtmwixJxGQbLHrhCwo3FjZgNC8vIfrSi29PABNbMoCGD9YoiXbQ==",
+      "license": "BSD-2-Clause",
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/env-schema/node_modules/json-schema-traverse": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
+      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
+      "license": "MIT"
+    },
     "node_modules/error-ex": {
       "version": "1.3.2",
       "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
@@ -4584,6 +4635,16 @@
         "tiny-lru": "^8.0.1"
       }
     },
+    "node_modules/fastify-env": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/fastify-env/-/fastify-env-2.1.1.tgz",
+      "integrity": "sha512-5IyYR+d+0/hwae/PpC6oWb+hlMpBqG1MuWWTEbFR2uzGhDXX/rCp4gdBrodt7SndOyvVlF+Z8QZ0fGlXPWtIOw==",
+      "license": "MIT",
+      "dependencies": {
+        "env-schema": "^3.0.1",
+        "fastify-plugin": "^3.0.0"
+      }
+    },
     "node_modules/fastify-jwt": {
       "version": "4.1.3",
       "resolved": "https://registry.npmjs.org/fastify-jwt/-/fastify-jwt-4.1.3.tgz",
@@ -6936,6 +6997,15 @@
         "node": "^18 || ^20 || >= 21"
       }
     },
+    "node_modules/node-cron": {
+      "version": "4.2.1",
+      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-4.2.1.tgz",
+      "integrity": "sha512-lgimEHPE/QDgFlywTd8yTR61ptugX3Qer29efeyWw2rv259HtGBNn1vZVmp8lB9uo9wC0t/AT4iGqXxia+CJFg==",
+      "license": "ISC",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/node-fetch-native": {
       "version": "1.6.7",
       "resolved": "https://registry.npmjs.org/node-fetch-native/-/node-fetch-native-1.6.7.tgz",
diff --git a/package.json b/package.json
index 36f7ba9..5d4e371 100644
--- a/package.json
+++ b/package.json
@@ -29,16 +29,17 @@
     "@grpc/proto-loader": "^0.8.0",
     "@influxdata/influxdb-client": "^1.35.0",
     "@prisma/client": "^6.13.0",
-    "@types/localtunnel": "^2.0.4",
     "axios": "^1.11.0",
     "bcrypt": "^6.0.0",
     "bullmq": "^5.58.0",
     "fastify": "^3.29.5",
+    "fastify-env": "^2.1.1",
     "fastify-jwt": "^4.1.3",
     "fastify-swagger": "^5.1.1",
     "install": "^0.13.0",
     "localtunnel": "^2.0.2",
     "net-snmp": "^3.23.0",
+    "node-cron": "^4.2.1",
     "ngrok": "^5.0.0-beta.2",
     "nodemailer": "^7.0.5",
     "pdfkit": "^0.17.1",
@@ -52,7 +53,8 @@
     "@types/bcrypt": "^6.0.0",
     "@types/jest": "^30.0.0",
     "@types/jsonwebtoken": "^9.0.10",
-    "@types/node": "^24.3.0",
+    "@types/localtunnel": "^2.0.4",
+    "@types/node": "^24.2.1",
     "@types/nodemailer": "^6.4.17",
     "@types/ping": "^0.4.4",
     "@types/supertest": "^6.0.3",
diff --git a/prisma/schema.prisma b/prisma/schema.prisma
index 0e7d994..5832b06 100644
--- a/prisma/schema.prisma
+++ b/prisma/schema.prisma
@@ -16,18 +16,34 @@ model Service {
   snmpCommunity      String?
   snmpPort           Int?                 @default(161)
   ownerId            String
+  criticality   Criticality? @default(MEDIUM)
+  status             String?
   createdAt          DateTime             @default(now())
   updatedAt          DateTime             @updatedAt
   glpiId             String?              @unique
   AlertContact       AlertContact[]
   Incident           Incident[]
   NotificationPolicy NotificationPolicy[]
+  User               User                 @relation(fields: [ownerId], references: [id], onDelete: Cascade)
   SliTarget          SliTarget[]
 
   @@index([ownerId])
   @@index([type])
 }
 
+model User {
+  id                   String    @id @default(uuid())
+  name                 String
+  email                String    @unique
+  password             String
+  role                 Role      @default(USER)
+  createdAt            DateTime  @default(now())
+  updatedAt            DateTime  @updatedAt
+  passwordResetExpires DateTime?
+  passwordResetToken   String?
+  Service              Service[]
+}
+
 model SliTarget {
   id         String   @id @default(uuid())
   serviceId  String
@@ -88,8 +104,21 @@ model NotificationPolicy {
   @@index([serviceId, active])
 }
 
+enum Role {
+  ADMIN
+  USER
+}
+
 enum ServiceType {
   HTTP
   PING
   SNMP
+  WEBHOOK
+}
+
+enum Criticality {
+  LOW
+  MEDIUM
+  HIGH
+  CRITICAL
 }
diff --git a/reports/sla-Google-1h.pdf b/reports/sla-Google-1h.pdf
new file mode 100644
index 0000000..e13b7cd
Binary files /dev/null and b/reports/sla-Google-1h.pdf differ
diff --git a/reports/sla-Google-24h.pdf b/reports/sla-Google-24h.pdf
new file mode 100644
index 0000000..a066c9c
--- /dev/null
+++ b/reports/sla-Google-24h.pdf
@@ -0,0 +1,108 @@
+%PDF-1.3
+%
+7 0 obj
+<<
+/Type /Page
+/Parent 1 0 R
+/MediaBox [0 0 612 792]
+/Contents 5 0 R
+/Resources 6 0 R
+>>
+endobj
+6 0 obj
+<<
+/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]
+/Font <<
+/F1 8 0 R
+>>
+/ColorSpace <<
+>>
+>>
+endobj
+5 0 obj
+<<
+/Length 612
+/Filter /FlateDecode
+>>
+stream
+xM1++Y+BK?Jd_8Y! [ҫ@
+^R蟻=MKd!"O=~(=uOv(AaLWNN1b}OCa=9i_;Z|8abJ$IIHr:յ@rA\\؎j?Cy5Mrazaӌq\0J[(jrx8JXa}gaȦ7t}w^ JҚM/³t(Ʒ0Tbbܜz+r 0>]ڻpr4brЬ>'8;bQ"\/ENtDlP"3'~fPNͮ@#=MfjqIǪ<r|mU&6wc`:PؙrǲF$BQFUyB=+t\)<IGjN(86L(BB??ǧпt<x2mx~-r9yOӄI\1TG
+\['<D.(.uƮORJJh/
+>h340Q
+endstream
+endobj
+10 0 obj
+(PDFKit)
+endobj
+11 0 obj
+(PDFKit)
+endobj
+12 0 obj
+(D:20250821064437Z)
+endobj
+9 0 obj
+<<
+/Producer 10 0 R
+/Creator 11 0 R
+/CreationDate 12 0 R
+>>
+endobj
+8 0 obj
+<<
+/Type /Font
+/BaseFont /Helvetica
+/Subtype /Type1
+/Encoding /WinAnsiEncoding
+>>
+endobj
+4 0 obj
+<<
+>>
+endobj
+3 0 obj
+<<
+/Type /Catalog
+/Pages 1 0 R
+/Names 2 0 R
+>>
+endobj
+1 0 obj
+<<
+/Type /Pages
+/Count 1
+/Kids [7 0 R]
+>>
+endobj
+2 0 obj
+<<
+/Dests <<
+  /Names [
+]
+>>
+>>
+endobj
+xref
+0 13
+0000000000 65535 f 
+0000001251 00000 n 
+0000001308 00000 n 
+0000001189 00000 n 
+0000001168 00000 n 
+0000000226 00000 n 
+0000000119 00000 n 
+0000000015 00000 n 
+0000001071 00000 n 
+0000000996 00000 n 
+0000000910 00000 n 
+0000000935 00000 n 
+0000000960 00000 n 
+trailer
+<<
+/Size 13
+/Root 3 0 R
+/Info 9 0 R
+/ID [<caf14a1759d4cf751d4bfbd1903d7088> <caf14a1759d4cf751d4bfbd1903d7088>]
+>>
+startxref
+1355
+%%EOF
diff --git a/reports/sla-InfluxData-1h.pdf b/reports/sla-InfluxData-1h.pdf
new file mode 100644
index 0000000..4ee9757
Binary files /dev/null and b/reports/sla-InfluxData-1h.pdf differ
diff --git a/reports/sla-InfluxData-24h.pdf b/reports/sla-InfluxData-24h.pdf
new file mode 100644
index 0000000..115b139
Binary files /dev/null and b/reports/sla-InfluxData-24h.pdf differ
diff --git a/src/Analyzers/analyzeSnmpIssue.ts b/src/Analyzers/analyzeSnmpIssue.ts
index bc01d52..13a27f1 100644
--- a/src/Analyzers/analyzeSnmpIssue.ts
+++ b/src/Analyzers/analyzeSnmpIssue.ts
@@ -1,5 +1,4 @@
 import { Problem } from "../types/Problem";
-import { redis } from "./redis";
 
 export interface SnmpResult {
   sysName?: string;
@@ -22,10 +21,10 @@ export interface SnmpResult {
   }>;
 }
 
-export async function analyzeSnmpIssue(
+export function analyzeSnmpIssue(
   service: { id: string; name: string },
   result: SnmpResult | null
-): Promise<Problem | null> {
+): Problem | null {
   const timestamp = new Date().toISOString();
 
   if (!result) {
@@ -86,8 +85,7 @@ export async function analyzeSnmpIssue(
       severity: "WARNING",
       priority: 3,
       description: `Dispositivo SNMP foi reiniciado recentemente (uptime: ${result.uptime}s).`,
-      recommendation:
-        "Verifique logs do dispositivo para entender causa do reboot.",
+      recommendation: "Verifique logs do dispositivo para entender causa do reboot.",
       timestamp,
     };
   }
@@ -117,54 +115,34 @@ export async function analyzeSnmpIssue(
       severity: "HIGH",
       priority: 2,
       description: `Memória livre baixa: ${result.memFree} MB.`,
-      recommendation:
-        "Considere aumentar a memória ou reduzir a carga no dispositivo.",
+      recommendation: "Considere aumentar a memória ou reduzir a carga no dispositivo.",
       timestamp,
     };
   }
 
   if (result.interfaces) {
-    for (const iface of result.interfaces) {
-      if (!iface.ip) continue;
-      if (["Vlan", "Loopback", "Test", "Dummy"].some((p) => iface.name.startsWith(p))) {
-        continue;
-      }
-
-      const key = `interfaceStatus:${service.id}:${iface.name}`;
-      const prevStatus = await redis.get(key);
-      const currentStatus = iface.operStatus;
+    const downInterfaces = result.interfaces.filter((iface) => {
+      if (iface.operStatus !== "down") return false;
+      if (!iface.ip) return false;
 
-      if (prevStatus !== currentStatus) {
-        await redis.set(key, currentStatus, "EX", 60 * 60 * 24);
+      const ignorePrefixes = ["Vlan", "Loopback", "Test", "Dummy"];
+      return !ignorePrefixes.some((prefix) => iface.name.startsWith(prefix));
+    });
 
-        if (currentStatus === "down") {
-          return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: 0,
-            status: "DOWN",
-            severity: "CRITICAL",
-            priority: 1,
-            description: `Interface ${iface.name} caiu (estava UP antes).`,
-            recommendation: "Verifique cabeamento ou configuração.",
-            timestamp,
-          };
-        } else if (currentStatus === "up" && prevStatus === "down") {
-          return {
-            serviceId: service.id,
-            serviceName: service.name,
-            metric: "SNMP",
-            value: 1,
-            status: "UP",
-            severity: "INFO",
-            priority: 4,
-            description: `Interface ${iface.name} voltou para UP.`,
-            recommendation: "Normalizado.",
-            timestamp,
-          };
-        }
-      }
+    if (downInterfaces.length > 0) {
+      const downInterfaceNames = downInterfaces.map((i) => i.name).join(", ");
+      return {
+        serviceId: service.id,
+        serviceName: service.name,
+        metric: "SNMP",
+        value: 0,
+        status: "DOWN",
+        severity: "CRITICAL",
+        priority: 1,
+        description: `Interfaces de rede estão DOWN: ${downInterfaceNames}.`,
+        recommendation: "Verifique o cabeamento e a configuração da interface.",
+        timestamp,
+      };
     }
   }
 
diff --git a/src/Analyzers/analyzeWebhookIssue.ts b/src/Analyzers/analyzeWebhookIssue.ts
new file mode 100644
index 0000000..bf52980
--- /dev/null
+++ b/src/Analyzers/analyzeWebhookIssue.ts
@@ -0,0 +1,96 @@
+import { Problem } from "../types/Problem";
+
+export interface WebhookResult {
+  status: string;
+  httpStatus?: number;
+  totalMs?: number;
+}
+
+export function analyzeWebhookIssue(
+  service: { id: string; name: string },
+  result: WebhookResult | null
+): Problem | null {
+  const timestamp = new Date().toISOString();
+
+  if (!result) {
+    return {
+      serviceId: service.id,
+      serviceName: service.name,
+      metric: "WEBHOOK",
+      value: 0,
+      status: "DOWN",
+      severity: "CRITICAL",
+      priority: 1,
+      description: "Sem resposta do endpoint Webhook.",
+      recommendation:
+        "Verifique se o servidor do webhook está ativo e acessível.",
+      timestamp,
+    };
+  }
+
+  if (result.status !== "UP") {
+    if (result.httpStatus && result.httpStatus >= 500) {
+      return {
+        serviceId: service.id,
+        serviceName: service.name,
+        metric: "WEBHOOK",
+        value: result.httpStatus,
+        status: "DOWN",
+        severity: "CRITICAL",
+        priority: 1,
+        description: `Falha no webhook. HTTP ${result.httpStatus}`,
+        recommendation:
+          "Verifique logs do servidor que recebe o webhook.",
+        timestamp,
+      };
+    }
+
+    if (result.httpStatus && result.httpStatus >= 400) {
+      return {
+        serviceId: service.id,
+        serviceName: service.name,
+        metric: "WEBHOOK",
+        value: result.httpStatus,
+        status: "DOWN",
+        severity: "HIGH",
+        priority: 2,
+        description: `Falha no webhook. Erro de cliente HTTP ${result.httpStatus}`,
+        recommendation:
+          "Verifique configuração do endpoint, autenticação ou payload enviado.",
+        timestamp,
+      };
+    }
+
+    return {
+      serviceId: service.id,
+      serviceName: service.name,
+      metric: "WEBHOOK",
+      value: result.httpStatus ?? 0,
+      status: "DOWN",
+      severity: "WARNING",
+      priority: 3,
+      description: "Falha no webhook: resposta inesperada ou inválida.",
+      recommendation:
+        "Confirme que o endpoint do webhook responde corretamente ao formato esperado.",
+      timestamp,
+    };
+  }
+
+  if (result.totalMs && result.totalMs > 3000) {
+    return {
+      serviceId: service.id,
+      serviceName: service.name,
+      metric: "WEBHOOK",
+      value: result.totalMs,
+      status: "UP",
+      severity: "WARNING",
+      priority: 3,
+      description: `Webhook respondeu em ${result.totalMs}ms (acima do normal).`,
+      recommendation:
+        "Monitorar latência do endpoint e possíveis gargalos de rede.",
+      timestamp,
+    };
+  }
+
+  return null;
+}
diff --git a/src/Analyzers/redis.ts b/src/Analyzers/redis.ts
deleted file mode 100644
index da66219..0000000
--- a/src/Analyzers/redis.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { redisConnection } from "../Monitoring/Queue/redis";
-import IORedis from "ioredis";
-
-if (!redisConnection.url) {
-	throw new Error("Redis connection URL is not defined");
-}
-export const redis = new IORedis(redisConnection.url);
diff --git a/src/Controllers/APIs/addServices.ts b/src/Controllers/APIs/addServices.ts
index 130b38f..f2a409f 100644
--- a/src/Controllers/APIs/addServices.ts
+++ b/src/Controllers/APIs/addServices.ts
@@ -1,21 +1,82 @@
 import { FastifyRequest, FastifyReply } from 'fastify';
-import { ServiceType } from '@prisma/client';
+import { ServiceType, Criticality } from '@prisma/client';
+import { syncServiceToGLPI } from '../../Integrations/GLPI/syncServices';
 
-export async function addService(request: any, reply: FastifyReply)
+interface AddServiceRequest {
+  name: string;
+  type: ServiceType;
+  target: string;
+  ownerId: string;
+  criticality?: string;
+  status?: string;
+}
+
+// export async function addService(request: FastifyRequest, reply: FastifyReply)
+export async function addService(request: FastifyRequest<{ Body: AddServiceRequest }>, reply: FastifyReply)
 {
-  const {ownerId} = request.params;
+  const { name, type, target, ownerId, criticality, status } = request.body;
+
+  try
+  {
+    const userExists = await request.server.prisma.user.findUnique({ where: { id: ownerId } });
+    if (!userExists)
+    {
+      return reply.code(400).send({ message: 'Owner not found' });
+    }
+    // Validate type
+    const validTypes = ['HTTP', 'PING', 'SNMP', 'WEBHOOK'];
+    if (!validTypes.includes(type)) {
+      return reply.code(400).send({ message: 'Invalid service type. Use: HTTP, PING, SNMP, WEBHOOK' });
+    }
 
-  const { name, type, target } = request.body as { name: string; type: ServiceType; target: string;};
+    // Validate criticality (if provided)
+    const validCriticalities = ['low', 'medium', 'high', 'critical'];
+    let criticalityEnum: Criticality | undefined;
+    if (criticality && !validCriticalities.includes(criticality)) {
+      return reply.code(400).send({ message: 'Invalid criticality. Use: low, medium, high, critical' });
+    }
 
-  console.log(ownerId)
+    // Validar status
+    const validStatuses = ['UP', 'DOWN', 'UNKNOWN'];
+    let serviceStatus = status;
+    if (status && !validStatuses.includes(status)) {
+      return reply.code(400).send({ message: 'Invalid status. Use: UP, DOWN, UNKNOWN' });
+    }
+    if (!serviceStatus) {
+      serviceStatus = 'UNKNOWN'; // Padrão se status não for fornecido
+    }
+    // Mapear string para enum Criticality
+    criticalityEnum = criticality.toUpperCase() as Criticality;
+    const service = await request.server.prisma.service.create({
+      data: { name, type, target, ownerId, criticality: criticalityEnum || Criticality.MEDIUM, status: serviceStatus, }
+    });
 
-  const service = await request.server.prisma.service.create({
-    data: { name, type, target, ownerId }
-  });
+    await createDefaultSLIsForService(service.id, type, request.server.prisma);
 
-  await createDefaultSLIsForService(service.id, type, request.server.prisma);
+    // Sync to GLPI
+    try {
+      await syncServiceToGLPI(service.id);
+    } catch (error) {
+      console.error(`Failed to sync service ${service.id} to GLPI:`, error.message);
+      // Continue to return the service, as GLPI sync failure shouldn't block creation
+    }
 
-  return reply.code(201).send(service);
+    // return reply.code(201).send(service);
+    return reply.code(201).send({
+        id: service.id,
+        name: service.name,
+        type: service.type,
+        target: service.target,
+        ownerId: service.ownerId,
+        criticality: service.criticality,
+        status: service.status,
+        createdAt: service.createdAt.toISOString(),
+        updatedAt: service.updatedAt.toISOString(),
+    });
+  }catch (error) {
+    console.error('Error creating service:', error.message);
+    return reply.code(500).send({ message: 'Failed to create service' });
+}
 }
 
 async function createDefaultSLIsForService(serviceId: string, type: ServiceType, prisma: any)
@@ -44,6 +105,16 @@ async function createDefaultSLIsForService(serviceId: string, type: ServiceType,
       });
       break;
 
+    case ServiceType.WEBHOOK:
+      defaultSLIs.push(
+      {
+        serviceId,
+        metric: 'WEBHOOK',
+        threshold: 98,
+        comparison: 'gte',
+      });
+      break;
+
     case ServiceType.SNMP:
       defaultSLIs.push(
       {
@@ -57,6 +128,11 @@ async function createDefaultSLIsForService(serviceId: string, type: ServiceType,
 
   for (const sli of defaultSLIs)
   {
-    await prisma.sliTarget.create({ data: sli });
+    // await prisma.sliTarget.create({ data: sli });
+    try {
+      await prisma.sliTarget.create({ data: sli });
+    } catch (error) {
+      console.error(`Failed to create SLI for service ${serviceId}, metric ${sli.metric}:`, error.message);
+    }
   }
 }
\ No newline at end of file
diff --git a/src/Controllers/APIs/deleteServices.ts b/src/Controllers/APIs/deleteServices.ts
deleted file mode 100644
index af858b3..0000000
--- a/src/Controllers/APIs/deleteServices.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-import { FastifyRequest, FastifyReply } from 'fastify';
-
-interface DeleteServiceParams {
-  ownerId: string;
-  serviceId: string;
-}
-
-export async function deleteService(
-  request: FastifyRequest<{ Params: DeleteServiceParams }>,
-  reply: FastifyReply
-) {
-  const { ownerId, serviceId } = request.params;
-
-  try {
-    const existingService = await request.server.prisma.service.findUnique({
-      where: { id: serviceId },
-    });
-
-    if (!existingService || existingService.ownerId !== ownerId) {
-      return reply
-        .code(404)
-        .send({ message: 'Serviço não encontrado ou não pertence a este usuário.' });
-    }
-
-    const deletedService = await request.server.prisma.service.delete({
-      where: { id: serviceId },
-    });
-
-    return reply.code(200).send(deletedService);
-  } catch (error) {
-    console.error('Erro ao deletar serviço:', error);
-
-    return reply.code(500).send({
-      message: 'Erro interno ao tentar deletar o serviço.',
-    });
-  }
-}
diff --git a/src/Controllers/APIs/serviceMetrics.ts b/src/Controllers/APIs/serviceMetrics.ts
index 0d77058..5feb98c 100644
--- a/src/Controllers/APIs/serviceMetrics.ts
+++ b/src/Controllers/APIs/serviceMetrics.ts
@@ -1,13 +1,7 @@
 import { queryApi } from '../../Influxdb/influxdb';
-interface MetricRow {
-  _time: string;
-  [key: string]: any;
-}
 
-export async function queryMetrics(
-  serviceId: string,
-  measurement: string
-): Promise<MetricRow[]> {
+export async function queryMetrics(serviceId: string, measurement: string)
+{
   const query = `
     from(bucket: "${process.env.INFLUX_BUCKET}")
       |> range(start: -1m)
@@ -16,10 +10,13 @@ export async function queryMetrics(
       |> sort(columns: ["_time"])
   `;
 
-  try {
-    const rows = await queryApi.collectRows<MetricRow>(query);
+  try
+  {
+    const rows = await queryApi.collectRows(query);
     return rows;
-  } catch (error: any) {
+  }
+  catch (error: any)
+  {
     throw new Error(`Erro na consulta InfluxDB: ${error.message}`);
   }
 }
@@ -28,131 +25,65 @@ export async function getPingMetrics(serviceId: string) {
   try {
     const rows = await queryMetrics(serviceId, 'ping_metrics');
 
-    return rows.map((row) => {
+    const formattedRows = rows.map((row: any) => {
       const transmitted = row.packets_transmitted || 0;
-      const received = row.packets_received || 0;
+      const received = row.packets_received;
       const loss = row.percent_packet_loss || 0;
       const min = row.minimum_response_ms || 0;
-      const max = row.maximum_response_ms || 0;
+      const max = row.maximum_response_msMs || 0;
       const avg = row.average_response_ms || 0;
       const mdev = row.standard_deviation_ms || 0;
       const status = row.status || (received > 0 ? 'UP' : 'DOWN');
-
       return {
         time: row._time,
-        serviceId,
+        serviceId: serviceId,
         packets_transmitted: transmitted,
-        packets_received: received,
+        packets_received: received,        
         percent_packet_loss: loss,
-        minimum_response_ms: min,
-        maximum_response_ms: max,
-        average_response_ms: avg,
-        standard_deviation_ms: mdev,
-        ttl: row.ttl || null,
-        status,
+        minimum_response_ms: min,           
+        average_response_ms: avg,           
+        standard_deviation_ms: mdev,        
+        ttl: null,                         
+        status                     
       };
     });
+
+    return formattedRows;
   } catch (error) {
     throw error;
   }
 }
 
-export async function getSnmpMetrics(serviceId: string) {
-  try {
-    const systemRows = await queryMetrics(serviceId, "snmp_system");
-    const system = systemRows.map((row) => ({
-      time: row._time,
-      sysName: row.sysName || "unknown",
-      sysDescr: row.sysDescr || "N/A",
-      sysUpTime: row.sysUpTime || "N/A",
-      cpuLoad5sec: row.cpuLoad5sec || 0,
-      cpuLoad5min: row.cpuLoad5min || 0,
-      memFreeBytes: row.memFreeBytes || 0,
-      memTotalBytes: row.memTotalBytes || 0,
-      memUsedPercent: row.memUsedPercent || 0,
-    }));
-
-    const ifaceRows = await queryMetrics(serviceId, "snmp_interface");
-    const interfaces = ifaceRows.map((row) => ({
-      time: row._time,
-      ifIndex: row.ifIndex,
-      ifName: row.ifName,
-      ifType: row.ifType,
-      adminStatus: row.adminStatus,
-      operStatus: row.operStatus,
-      mac: row.mac,
-      speedBps: row.speedBps || 0,
-      inBytes: row.inBytes || 0,
-      outBytes: row.outBytes || 0,
-      inErrors: row.inErrors || 0,
-      outErrors: row.outErrors || 0,
-      ip: row.ipAddress || null,
-    }));
-
-    const summaryRows = await queryMetrics(serviceId, "snmp_summary");
-    const summary = summaryRows.map((row) => ({
+export async function getSnmpMetrics(serviceId: string)
+{
+  try
+  {
+    const rows = await queryMetrics(serviceId, 'snmp_metrics');
+    const formattedRows = rows.map((row: any) => ({
       time: row._time,
-      totalInterfaces: row.totalInterfaces || 0,
-      interfacesUp: row.interfacesUp || 0,
-      interfacesDown: row.interfacesDown || 0,
-      totalInBytes: row.totalInBytes || 0,
-      totalOutBytes: row.totalOutBytes || 0,
-      totalErrors: row.totalErrors || 0,
+      sysName: row.sysName || '',
+      sysDescr: row.sysDescr || '',
+      uptime: row.uptime || '',
+      cpuLoad1min: row.cpuLoad1min || 0,
+      memTotalKB: row.memTotalKB || 0,
+      memAvailKB: row.memAvailKB || 0,
+      interfacesCount: row.interfacesCount || 0,
     }));
-
-    const sensorRows = await queryMetrics(serviceId, "snmp_sensor");
-
-    const sensors = {
-      temperature: [] as { time: string; index: string; value: number }[],
-      fanStatus: [] as { time: string; index: string; status: string }[],
-      psuStatus: [] as { time: string; index: string; status: string }[],
-      powerDraw: [] as { time: string; index: string; watts: number }[],
-    };
-
-    for (const row of sensorRows) {
-      switch (row.type) {
-        case "temperature":
-          sensors.temperature.push({
-            time: row._time,
-            index: row.index,
-            value: row.value,
-          });
-          break;
-        case "fan":
-          sensors.fanStatus.push({
-            time: row._time,
-            index: row.index,
-            status: row.status,
-          });
-          break;
-        case "psu":
-          sensors.psuStatus.push({
-            time: row._time,
-            index: row.index,
-            status: row.status,
-          });
-          break;
-        case "power":
-          sensors.powerDraw.push({
-            time: row._time,
-            index: row.index,
-            watts: row.watts,
-          });
-          break;
-      }
-    }
-
-    return { system, interfaces, summary, sensors };
-  } catch (error) {
+    return formattedRows;
+  }
+  catch (error)
+  {
     throw error;
   }
 }
 
-export async function getHttpMetrics(serviceId: string) {
-  try {
+export async function getHttpMetrics(serviceId: string)
+{
+  try
+  {
     const rows = await queryMetrics(serviceId, 'http_metrics');
 
-    return rows.map((row) => ({
+    const formattedRows = rows.map((row: any) => ({
       time: row._time,
       status: row.status || 'unknown',
       httpStatus: row.httpStatus || 0,
@@ -162,12 +93,14 @@ export async function getHttpMetrics(serviceId: string) {
       connectAndDownloadMs: row.connectAndDownloadMs || 0,
       totalMs: row.totalMs || 0,
       headers: row.headers
-        ? (typeof row.headers === 'string'
-            ? JSON.parse(row.headers)
-            : row.headers)
+        ? (typeof row.headers === 'string' ? JSON.parse(row.headers) : row.headers)
         : {},
     }));
-  } catch (error: any) {
+
+    return formattedRows;
+  }
+  catch (error: any)
+  {
     throw new Error(`Erro ao buscar métricas HTTP: ${error.message}`);
   }
 }
@@ -175,8 +108,7 @@ export async function getHttpMetrics(serviceId: string) {
 export async function getWebhookMetrics(serviceId: string) {
   try {
     const rows = await queryMetrics(serviceId, 'webhook_metrics');
-
-    return rows.map((row) => ({
+    const formattedRows = rows.map((row: any) => ({
       time: row._time,
       status: row.status || 'unknown',
       httpStatus: row.httpStatus || 0,
@@ -189,6 +121,7 @@ export async function getWebhookMetrics(serviceId: string) {
       payloadSent: row.payloadSent || null,
       responseBody: row.responseBody || null,
     }));
+    return formattedRows;
   } catch (error) {
     throw error;
   }
diff --git a/src/Controllers/APIs/syncAssets.ts b/src/Controllers/APIs/syncAssets.ts
new file mode 100644
index 0000000..e69de29
diff --git a/src/Controllers/Auth/Register.ts b/src/Controllers/Auth/Register.ts
new file mode 100644
index 0000000..8c04672
--- /dev/null
+++ b/src/Controllers/Auth/Register.ts
@@ -0,0 +1,21 @@
+import { FastifyRequest, FastifyReply } from 'fastify';
+import bcrypt from 'bcrypt';
+
+export async function Register(request: FastifyRequest, reply: FastifyReply)
+{
+  const { name, email, password } = request.body as { name: string; email: string; password: string };
+
+  const existingUser = await (request.server as any).prisma.user.findUnique({ where: { email } });
+  if (existingUser)
+  {
+    return reply.code(400).send({ message: 'Email already in use' });
+  }
+
+  const hashedPassword = await bcrypt.hash(password, 10);
+
+  const user = await (request.server as any).prisma.user.create(
+  {
+    data: { name, email, password: hashedPassword },
+  });
+  return { id: user.id, email: user.email };
+}
diff --git a/src/Controllers/Auth/ResetPassword.ts b/src/Controllers/Auth/ResetPassword.ts
new file mode 100644
index 0000000..561b535
--- /dev/null
+++ b/src/Controllers/Auth/ResetPassword.ts
@@ -0,0 +1,47 @@
+import { FastifyReply, FastifyRequest } from "fastify";
+import bcrypt from "bcrypt";
+
+export async function resetarSenha(req: FastifyRequest, reply: FastifyReply)
+{
+  const { user, token, novaSenha, confirmnovaSenha } = req.body as
+  {
+    user: string;
+    token: string;
+    novaSenha: string;
+    confirmnovaSenha: string;
+  };
+
+  const usuario = await req.server.prisma.user.findFirst(
+  {
+    where: { email: user }
+  });
+
+  if (!usuario || usuario.passwordResetToken !== token)
+  {
+    return reply.status(401).send({ error: "Token inválido ou usuário não encontrado." });
+  }
+
+  if (usuario.passwordResetExpires && new Date(usuario.passwordResetExpires) < new Date())
+  {
+    return reply.status(403).send({ error: "Token expirado." });
+  }
+
+  if (novaSenha !== confirmnovaSenha)
+  {
+    return reply.status(400).send({ error: "Palavras-passe não coincidem." });
+  }
+
+  const hashedPassword = await bcrypt.hash(novaSenha, 10);
+
+  await req.server.prisma.user.update(
+  {
+    where: { id: usuario.id },
+    data: {
+      password: hashedPassword,
+      passwordResetToken: null,
+      passwordResetExpires: null,
+    },
+  });
+
+  return reply.send({ message: "Senha redefinida com sucesso." });
+}
diff --git a/src/Controllers/Auth/SolicitarResetPassword.ts b/src/Controllers/Auth/SolicitarResetPassword.ts
new file mode 100644
index 0000000..635d51b
--- /dev/null
+++ b/src/Controllers/Auth/SolicitarResetPassword.ts
@@ -0,0 +1,46 @@
+import { FastifyReply, FastifyRequest } from "fastify";
+import { EmailProvider } from "../../Notifications/Email/EmailProvider";
+
+export async function solicitarResetSenha(req: FastifyRequest, reply: FastifyReply) {
+  const { user } = req.body as { user: string };
+
+  if (!user)
+  {
+    return reply.status(400).send({ error: "Campo obrigatório não preenchido" });
+  }
+
+  const isEmail = (str: string) => /\S+@\S+\.\S+/.test(str);
+
+  const usuario = await req.server.prisma.user.findFirst(
+  {
+    where: isEmail(user) ? { email: user } : { name: user },
+  });
+
+  if (!usuario)
+  {
+    return reply.status(404).send({ error: "Usuário não encontrado." });
+  }
+
+  const token = Math.floor(1000 + Math.random() * 9000).toString();
+
+  await req.server.prisma.user.update(
+  {
+    where: { id: usuario.id },
+    data:
+    {
+      passwordResetToken   : token,
+      passwordResetExpires: new Date(Date.now() + 10 * 60 * 1000),
+    },
+  });
+
+  if (usuario.email)
+  {
+    const emailProvider = new EmailProvider();
+    await emailProvider.sendNotification2(
+      usuario.email,
+      `${token}`
+    );
+  }
+
+  return reply.send({ message: "Token de redefinição enviado com sucesso." });
+}
diff --git a/src/Controllers/Auth/VerifyOTP.ts b/src/Controllers/Auth/VerifyOTP.ts
new file mode 100644
index 0000000..0253f35
--- /dev/null
+++ b/src/Controllers/Auth/VerifyOTP.ts
@@ -0,0 +1,35 @@
+import { FastifyReply, FastifyRequest } from "fastify";
+
+export async function VerifyOTP(req: FastifyRequest, reply: FastifyReply)
+{
+  const { user, token } = req.body as { user: string; token: string };
+
+  const cleanUser = user.trim().toLowerCase().replace(/[^+\dA-Za-z@.]/g, "");
+  const isEmail = /\S+@\S+\.\S+/.test(cleanUser);
+
+  if (!isEmail)
+  {
+    return reply.status(400).send({ error: "Email inválido." });
+  }
+
+  const usuario = await req.server.prisma.user.findFirst(
+  {
+    where:
+    {
+      email: cleanUser,
+      passwordResetToken: token,
+    },
+  });
+  
+
+  if (!usuario || usuario.passwordResetToken !== token)
+  {
+    return reply.status(401).send({ error: "OTP inválido" });
+  }
+
+  if (usuario.passwordResetExpires && new Date(usuario.passwordResetExpires) < new Date())
+  {
+    return reply.status(403).send({ error: "Token expirado." });
+  }
+  return reply.send({ message: "Token válido" });
+}
diff --git a/src/Controllers/Auth/login.ts b/src/Controllers/Auth/login.ts
new file mode 100644
index 0000000..4b1a974
--- /dev/null
+++ b/src/Controllers/Auth/login.ts
@@ -0,0 +1,22 @@
+import { FastifyRequest, FastifyReply } from 'fastify';
+import bcrypt from 'bcrypt';
+
+export async function Login(request: FastifyRequest, reply: FastifyReply)
+{
+  const { email, password } = request.body as { email: string; password: string };
+
+  const user = await request.server.prisma.user.findUnique({ where: { email } });
+  if (!user)
+  {
+    return reply.code(400).send({ message: 'Invalid credentials' });
+  }
+
+  const isPasswordValid = await bcrypt.compare(password, user.password);
+  if (!isPasswordValid)
+  {
+    return reply.code(400).send({ message: 'Invalid credentials' });
+  }
+
+  const token = request.server.jwt.sign({ id: user.id, email: user.email, role: user.role });
+  return { token };
+}
diff --git a/src/Influxdb/WriteMetrics/WriteSnmpMetrics.ts b/src/Influxdb/WriteMetrics/WriteSnmpMetrics.ts
index 7fdb8ee..465e7e0 100644
--- a/src/Influxdb/WriteMetrics/WriteSnmpMetrics.ts
+++ b/src/Influxdb/WriteMetrics/WriteSnmpMetrics.ts
@@ -1,59 +1,71 @@
 import { Point } from "@influxdata/influxdb-client";
 import { writeApi } from "../influxdb";
 
-export async function writeSnmpMetrics(serviceId: string, data: any) {
+export async function writeSnmpMetrics(serviceId: string, data: any)
+{
   const points: Point[] = [];
-
+  
   const systemPoint = new Point("snmp_system")
     .tag("serviceId", serviceId)
     .tag("ip", data.ip)
     .tag("sysName", data.sysName || "unknown")
     .stringField("sysDescr", data.metrics.sysDescr || "N/A")
     .stringField("sysUpTime", data.metrics.sysUpTime || "N/A");
-
-  if (data.metrics.cpuLoad5min && data.metrics.cpuLoad5min !== "N/A") {
+  
+  if (data.metrics.cpuLoad5min && data.metrics.cpuLoad5min !== "N/A")
+  {
     const cpuValue = parseFloat(data.metrics.cpuLoad5min);
-    if (!isNaN(cpuValue)) {
+    if (!isNaN(cpuValue))
+    {
       systemPoint.floatField("cpuLoad5min", cpuValue);
     }
   }
-
-  if (data.metrics.memFree && data.metrics.memFree !== "N/A") {
+  
+  if (data.metrics.memFree && data.metrics.memFree !== "N/A")
+  {
     systemPoint.stringField("memFree", data.metrics.memFree);
     const memFreeMatch = data.metrics.memFree.match(/^([\d.]+)\s*(\w+)/);
-    if (memFreeMatch) {
+    if (memFreeMatch)
+    {
       const value = parseFloat(memFreeMatch[1]);
       const unit = memFreeMatch[2];
       const bytesValue = convertToBytes(value, unit);
-      if (bytesValue !== null) {
+      if (bytesValue !== null)
+      {
         systemPoint.intField("memFreeBytes", bytesValue);
       }
     }
   }
-
-  if (data.metrics.memTotal && data.metrics.memTotal !== "N/A") {
+  
+  if (data.metrics.memTotal && data.metrics.memTotal !== "N/A")
+  {
     systemPoint.stringField("memTotal", data.metrics.memTotal);
     const memTotalMatch = data.metrics.memTotal.match(/^([\d.]+)\s*(\w+)/);
-    if (memTotalMatch) {
+    if (memTotalMatch)
+    {
       const value = parseFloat(memTotalMatch[1]);
       const unit = memTotalMatch[2];
       const bytesValue = convertToBytes(value, unit);
-      if (bytesValue !== null) {
+      if (bytesValue !== null)
+      {
         systemPoint.intField("memTotalBytes", bytesValue);
         const memFreeBytes = systemPoint.fields["memFreeBytes"];
-        if (memFreeBytes && typeof memFreeBytes === "number") {
+        if (memFreeBytes && typeof memFreeBytes === "number")
+        {
           const usedPercent = ((bytesValue - memFreeBytes) / bytesValue) * 100;
           systemPoint.floatField("memUsedPercent", usedPercent);
         }
       }
     }
   }
-
+  
   systemPoint.timestamp(new Date(data.timestamp));
   points.push(systemPoint);
-
-  if (data.interfaces && Array.isArray(data.interfaces)) {
-    for (const iface of data.interfaces) {
+  
+  if (data.interfaces && Array.isArray(data.interfaces))
+  {
+    for (const iface of data.interfaces)
+    {
       const ifacePoint = new Point("snmp_interface")
         .tag("serviceId", serviceId)
         .tag("ip", data.ip)
@@ -63,200 +75,147 @@ export async function writeSnmpMetrics(serviceId: string, data: any) {
         .tag("ifType", iface.type || "unknown")
         .tag("adminStatus", iface.adminStatus || "unknown")
         .tag("operStatus", iface.operStatus || "unknown");
-
-      if (iface.mac && iface.mac !== "N/A") {
+      
+      if (iface.mac && iface.mac !== "N/A")
+      {
         ifacePoint.stringField("mac", iface.mac);
       }
-
-      if (iface.ip) {
+      
+      if (iface.ip)
+      {
         ifacePoint.stringField("ipAddress", iface.ip);
       }
-
-      if (iface.speed && iface.speed !== "N/A") {
+      
+      if (iface.speed && iface.speed !== "N/A")
+      {
         ifacePoint.stringField("speed", iface.speed);
         const speedBps = parseSpeed(iface.speed);
-        if (speedBps !== null) {
+        if (speedBps !== null)
+        {
           ifacePoint.intField("speedBps", speedBps);
         }
       }
-
-      if (iface.inOctets && iface.inOctets !== "N/A") {
+      
+      if (iface.inOctets && iface.inOctets !== "N/A")
+      {
         ifacePoint.stringField("inOctets", iface.inOctets);
         const inBytes = parseBytes(iface.inOctets);
         if (inBytes !== null) {
           ifacePoint.intField("inBytes", inBytes);
         }
       }
-
-      if (iface.outOctets && iface.outOctets !== "N/A") {
+      
+      if (iface.outOctets && iface.outOctets !== "N/A")
+      {
         ifacePoint.stringField("outOctets", iface.outOctets);
         const outBytes = parseBytes(iface.outOctets);
         if (outBytes !== null) {
           ifacePoint.intField("outBytes", outBytes);
         }
       }
-
-      if (iface.inErrors && iface.inErrors !== "N/A") {
+      
+      if (iface.inErrors && iface.inErrors !== "N/A")
+      {
         const inErrors = parseInt(iface.inErrors);
         if (!isNaN(inErrors)) {
           ifacePoint.intField("inErrors", inErrors);
         }
       }
-
-      if (iface.outErrors && iface.outErrors !== "N/A") {
+      
+      if (iface.outErrors && iface.outErrors !== "N/A")
+      {
         const outErrors = parseInt(iface.outErrors);
         if (!isNaN(outErrors)) {
           ifacePoint.intField("outErrors", outErrors);
         }
       }
-
+      
       ifacePoint.timestamp(new Date(data.timestamp));
       points.push(ifacePoint);
     }
   }
-
+  
   const summaryPoint = new Point("snmp_summary")
     .tag("serviceId", serviceId)
     .tag("ip", data.ip)
     .tag("sysName", data.sysName || "unknown")
     .intField("totalInterfaces", data.interfaces?.length || 0)
-    .intField(
-      "interfacesUp",
-      data.interfaces?.filter((i: any) => i.operStatus === "up").length || 0
-    )
-    .intField(
-      "interfacesDown",
-      data.interfaces?.filter((i: any) => i.operStatus === "down").length || 0
-    )
+    .intField("interfacesUp", data.interfaces?.filter((i: any) => i.operStatus === "up").length || 0)
+    .intField("interfacesDown", data.interfaces?.filter((i: any) => i.operStatus === "down").length || 0)
     .timestamp(new Date(data.timestamp));
-
-  if (data.interfaces && Array.isArray(data.interfaces)) {
+  
+  if (data.interfaces && Array.isArray(data.interfaces))
+  {
     let totalInBytes = 0;
     let totalOutBytes = 0;
     let totalErrors = 0;
-
-    for (const iface of data.interfaces) {
-      if (iface.operStatus === "up") {
+    
+    for (const iface of data.interfaces)
+    {
+      if (iface.operStatus === "up")
+      {
         const inBytes = parseBytes(iface.inOctets);
         const outBytes = parseBytes(iface.outOctets);
-
-        if (inBytes !== null) totalInBytes += inBytes;
-        if (outBytes !== null) totalOutBytes += outBytes;
-
-        if (iface.inErrors && iface.inErrors !== "N/A") {
+        
+        if (inBytes !== null) 
+          totalInBytes += inBytes;
+        if (outBytes !== null) 
+          totalOutBytes += outBytes;
+        
+        if (iface.inErrors && iface.inErrors !== "N/A")
+        {
           totalErrors += parseInt(iface.inErrors) || 0;
         }
-        if (iface.outErrors && iface.outErrors !== "N/A") {
+        if (iface.outErrors && iface.outErrors !== "N/A")
+        {
           totalErrors += parseInt(iface.outErrors) || 0;
         }
       }
     }
-
+    
     summaryPoint
       .intField("totalInBytes", totalInBytes)
       .intField("totalOutBytes", totalOutBytes)
       .intField("totalErrors", totalErrors);
   }
-
+  
   points.push(summaryPoint);
-
-  if (Array.isArray(data.metrics.temperature)) {
-    data.metrics.temperature.forEach((temp: string, idx: number) => {
-      const value = parseFloat(temp);
-      if (!isNaN(value)) {
-        points.push(
-          new Point("snmp_sensor")
-            .tag("serviceId", serviceId)
-            .tag("ip", data.ip)
-            .tag("sysName", data.sysName || "unknown")
-            .tag("type", "temperature")
-            .tag("index", String(idx))
-            .floatField("value", value)
-            .timestamp(new Date(data.timestamp))
-        );
-      }
-    });
-  }
-
-  if (Array.isArray(data.metrics.fanStatus)) {
-    data.metrics.fanStatus.forEach((status: string, idx: number) => {
-      points.push(
-        new Point("snmp_sensor")
-          .tag("serviceId", serviceId)
-          .tag("ip", data.ip)
-          .tag("sysName", data.sysName || "unknown")
-          .tag("type", "fan")
-          .tag("index", String(idx))
-          .stringField("status", status)
-          .timestamp(new Date(data.timestamp))
-      );
-    });
-  }
-
-  if (Array.isArray(data.metrics.psuStatus)) {
-    data.metrics.psuStatus.forEach((status: string, idx: number) => {
-      points.push(
-        new Point("snmp_sensor")
-          .tag("serviceId", serviceId)
-          .tag("ip", data.ip)
-          .tag("sysName", data.sysName || "unknown")
-          .tag("type", "psu")
-          .tag("index", String(idx))
-          .stringField("status", status)
-          .timestamp(new Date(data.timestamp))
-      );
-    });
-  }
-
-  if (Array.isArray(data.metrics.powerDraw)) {
-    data.metrics.powerDraw.forEach((pwr: string, idx: number) => {
-      const match = pwr.match(/^([\d.]+)\s*W/i);
-      const value = match ? parseFloat(match[1]) : null;
-      if (value !== null && !isNaN(value)) {
-        points.push(
-          new Point("snmp_sensor")
-            .tag("serviceId", serviceId)
-            .tag("ip", data.ip)
-            .tag("sysName", data.sysName || "unknown")
-            .tag("type", "power")
-            .tag("index", String(idx))
-            .floatField("watts", value)
-            .timestamp(new Date(data.timestamp))
-        );
-      }
-    });
-  }
-
-  for (const point of points) {
+  
+  for (const point of points)
+  {
     writeApi.writePoint(point);
   }
   await writeApi.flush();
 }
 
-function convertToBytes(value: number, unit: string): number | null {
+function convertToBytes(value: number, unit: string): number | null
+{
   const units: Record<string, number> = {
-    B: 1,
-    KB: 1024,
-    MB: 1024 * 1024,
-    GB: 1024 * 1024 * 1024,
-    TB: 1024 * 1024 * 1024 * 1024,
+    'B': 1,
+    'KB': 1024,
+    'MB': 1024 * 1024,
+    'GB': 1024 * 1024 * 1024,
+    'TB': 1024 * 1024 * 1024 * 1024,
   };
-
+  
   const multiplier = units[unit.toUpperCase()];
-  if (multiplier) {
+  if (multiplier)
+  {
     return Math.round(value * multiplier);
   }
   return null;
 }
 
-function parseBytes(bytesStr: string): number | null {
+function parseBytes(bytesStr: string): number | null
+{
   if (!bytesStr || bytesStr === "N/A") return null;
-
+  
   const directParse = parseInt(bytesStr);
   if (!isNaN(directParse)) return directParse;
-
+  
   const match = bytesStr.match(/^([\d.]+)\s*(\w+)/);
-  if (match) {
+  if (match)
+  {
     const value = parseFloat(match[1]);
     const unit = match[2];
     return convertToBytes(value, unit);
@@ -264,22 +223,24 @@ function parseBytes(bytesStr: string): number | null {
   return null;
 }
 
-function parseSpeed(speedStr: string): number | null {
+function parseSpeed(speedStr: string): number | null
+{
   if (!speedStr || speedStr === "N/A") return null;
-
+  
   const directParse = parseInt(speedStr);
   if (!isNaN(directParse)) return directParse;
-
+  
   const match = speedStr.match(/^([\d.]+)\s*(\w+)/);
-  if (match) {
+  if (match)
+  {
     const value = parseFloat(match[1]);
     const unit = match[2].toLowerCase();
-
+    
     const multipliers: Record<string, number> = {
-      bps: 1,
-      kbps: 1000,
-      mbps: 1000000,
-      gbps: 1000000000,
+      'bps': 1,
+      'kbps': 1000,
+      'mbps': 1000000,
+      'gbps': 1000000000,
     };
     const multiplier = multipliers[unit];
     if (multiplier) {
diff --git a/src/Influxdb/WriteMetrics/WriteWebhookEvent.ts b/src/Influxdb/WriteMetrics/WriteWebhookEvent.ts
new file mode 100644
index 0000000..b770ae2
--- /dev/null
+++ b/src/Influxdb/WriteMetrics/WriteWebhookEvent.ts
@@ -0,0 +1,36 @@
+import { Point } from "@influxdata/influxdb-client";
+import { writeApi } from "../influxdb";
+
+interface WebhookEventPoint
+{
+  serviceId: string;
+  status?: string;   
+  sourceIp?: string;
+  userAgent?: string;
+  signature?: string;
+  note?: string;
+  payload?: any;  
+}
+
+export async function writeWebhookEvent(event: WebhookEventPoint)
+{
+  const point = new Point("webhook_events")
+    .tag("serviceId", event.serviceId);
+
+  if (event.status) point.tag("status", event.status);
+  if (event.sourceIp) point.tag("sourceIp", event.sourceIp);
+
+  if (event.userAgent) point.stringField("userAgent", event.userAgent);
+  if (event.signature) point.stringField("signature", event.signature);
+  if (event.note) point.stringField("note", event.note);
+
+  if (event.payload)
+  {
+    point.stringField("payload", JSON.stringify(event.payload));
+  }
+
+  point.timestamp(new Date());
+
+  writeApi.writePoint(point);
+  await writeApi.flush();
+}
diff --git a/src/Influxdb/WriteMetrics/WriteWebhookMetrics.ts b/src/Influxdb/WriteMetrics/WriteWebhookMetrics.ts
new file mode 100644
index 0000000..2837488
--- /dev/null
+++ b/src/Influxdb/WriteMetrics/WriteWebhookMetrics.ts
@@ -0,0 +1,34 @@
+import { Point } from '@influxdata/influxdb-client';
+import { writeApi } from "../influxdb"
+
+export function writeWebhookMetrics(serviceId: string, data: any)
+{
+  const point = new Point('webhook_metrics')
+    .tag('serviceId', serviceId)
+    .stringField('status', data.status ?? '')
+    .intField('httpStatus', data.httpStatus ?? 0)
+    .stringField('ip', data.ip ?? '')
+    .intField('sizeBytes', data.sizeBytes ?? 0)
+    .floatField('dnsMs', data.dnsMs ?? 0)
+    .floatField('connectAndDownloadMs', data.connectAndDownloadMs ?? 0)
+    .floatField('totalMs', data.totalMs ?? 0)
+    .stringField('payloadSent', JSON.stringify(data.payloadSent ?? {}))
+    .stringField('responseBody', data.responseBody ? String(data.responseBody) : '')
+    .timestamp(new Date());
+
+  if (data.headers)
+  {
+    Object.entries(data.headers).forEach(([key, value]) => {
+      const headerPoint = new Point('service_webhook_header')
+        .tag('serviceId', serviceId)
+        .tag('header', key)
+        .stringField('value', String(value))
+        .timestamp(new Date());
+
+      writeApi.writePoint(headerPoint);
+    });
+  }
+
+  writeApi.writePoint(point);
+  writeApi.flush();
+}
\ No newline at end of file
diff --git a/src/Integrations/GLPI/glpiClient.ts b/src/Integrations/GLPI/glpiClient.ts
new file mode 100644
index 0000000..1f875c2
--- /dev/null
+++ b/src/Integrations/GLPI/glpiClient.ts
@@ -0,0 +1,277 @@
+
+import { GLPIClient } from '@atno/ts-glpi-client';
+import dotenv from 'dotenv';
+import { PrismaClient, ServiceType, Role } from '@prisma/client';
+import axios from 'axios';
+import 'dotenv/config';
+
+dotenv.config();
+
+const prisma = new PrismaClient();
+
+// Cria o cliente GLPI
+const client = new GLPIClient(
+  process.env.GLPI_URL!,
+  process.env.GLPI_APP_TOKEN!
+);
+
+// Mantém o apiClient globalmente se quiser evitar múltiplas autenticações
+let apiClient: any;
+
+async function initGlpiSession() {
+  try {
+    apiClient = await client.authenticateWithToken(process.env.GLPI_USER_TOKEN!);
+    console.log('Sessão GLPI iniciada.');
+  } catch (error: any) {
+    console.error('Erro ao iniciar sessão GLPI:', error);
+    throw new Error(`Falha na autenticação GLPI: ${error.message}`);
+  }
+}
+
+// Função para garantir um usuário default
+async function getOrCreateDefaultUser() {
+  let defaultUser = await prisma.user.findUnique({
+    where: { id: 'default' }, // Ou use um ID existente, ex: '1'
+  });
+
+  if (!defaultUser) {
+    defaultUser = await prisma.user.create({
+      data: {
+        id: 'default', // Ou use autoincrement se id for Int
+        name: 'Default User',
+        email: 'default@example.com',
+        password: 'defaultpassword', // Hash isso em produção
+        role: Role.USER, // Use enum Role do schema
+      },
+    });
+    console.log('Usuário default criado:', defaultUser.id);
+  }
+  return defaultUser.id;
+}
+
+// export async function syncGlpiInventory() {
+//   try {
+//     if (!apiClient) {
+//       await initGlpiSession();
+//     }
+
+//     const response = await apiClient.actives.getAll('Computer') ; // ou outro tipo de item
+//     const items = response.data;
+//     const defaultOwnerId = await getOrCreateDefaultUser();
+//     console.log('Itens recebidos do GLPI:', items);
+
+//     if (!Array.isArray(items)) {
+//       throw new Error('GLPI não retornou uma lista de computadores.');
+//     }
+
+//     for (const item of items) {
+//       await prisma.service.upsert({
+//         where: { id: item.id.toString() },
+//         update: {
+//           name: item.name,
+//           target: item.ip || item.name,
+//           type: ServiceType.PING,
+//           criticality: item.criticality || 'medium',
+//         },
+//         create: {
+//           id: item.id.toString(),
+//           name: item.name,
+//           target: item.ip || item.name,
+//           type: ServiceType.PING,
+//           ownerId: defaultOwnerId,
+//           criticality: item.criticality || 'medium',
+//           createdAt: new Date(),
+//           updatedAt: new Date(),
+//         },
+//       });
+//     }
+
+//     console.log('Inventário GLPI sincronizado com sucesso.');
+//   } catch (error: any) {
+//     console.error('Erro ao sincronizar inventário GLPI:', error);
+//     throw new Error(`Falha na sincronização: ${error.message}`);
+//   }
+// }
+
+const GLPI_INVENTORY_URL = process.env.GLPI_INVENTORY_URL || 'http://localhost:8080/front/inventory.php';
+const GLPI_AGENT_TOKEN = process.env.GLPI_AGENT_TOKEN;
+const INFRAWATCH_API_URL = 'http://localhost:3002/api';
+
+export async function syncGlpiInventory() {
+  // Validate environment variables
+  if (!GLPI_INVENTORY_URL || !GLPI_AGENT_TOKEN) {
+    console.error('GLPI inventory configuration is incomplete');
+    return;
+  }
+
+  try {
+    // Fetch all services
+    const servicesResponse = await axios.get(`${INFRAWATCH_API_URL}/services`, {
+      headers: { accept: 'application/json' },
+    });
+    const services = servicesResponse.data;
+
+    for (const service of services) {
+      // Fetch metrics for HTTP services
+      let metrics = {};
+      if (service.type === 'HTTP') {
+        try {
+          const metricsResponse = await axios.get(`${INFRAWATCH_API_URL}/services/${service.id}/metrics/http`, {
+            headers: { accept: 'application/json' },
+          });
+          metrics = metricsResponse.data[0] || {};
+        } catch (error) {
+          console.error(`Failed to fetch metrics for service ${service.id}:`, error.message);
+        }
+      }
+      if (service.type === 'SNMP') {
+        try {
+          const snmpMetrics = await axios.get(`${INFRAWATCH_API_URL}/services/${service.id}/metrics/snmp`);
+          metrics = { ...metrics, ...snmpMetrics.data[0] };
+        } catch (error) {
+          console.error(`Falha ao buscar métricas SNMP para ${service.id}:`, error.message);
+        }
+      }
+
+      // Map service type to GLPI asset type
+      const assetTypeMap: { [key: string]: string } = {
+        HTTP: 'Computer',
+        PING: 'Computer',
+        SNMP: 'NetworkEquipment',
+      };
+      const glpiAssetType = assetTypeMap[service.type] || 'Computer';
+
+      // Função para validar IPv4
+    const isIpAddress = (str: string) => {
+      const ipRegex = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;
+      return ipRegex.test(str);
+    };
+
+    // Extrair possível IP de service.target
+    let ipAddress: string | undefined;
+    if (service.target) {
+      const target = service.target.includes('://') ? service.target.split('://')[1].split('/')[0] : service.target;
+      if (isIpAddress(target)) {
+        ipAddress = target;
+      }
+    }
+      
+      // Generate GLPI inventory JSON
+      const inventoryJson = {
+        //_tracking_inventory: 1,
+        deviceid: `infrawatch-${service.id}`,
+        content: {
+          versionclient: '1.0',
+          hardware: {
+            name: service.name || 'Unknown Asset',
+            uuid: `infrawatch-${service.id}`,
+            memory_size: metrics.memory || 0,
+            cpu_names: metrics.cpu || "Desconhecido",
+            serial: `INFRAWATCH-${service.id}`, // Adicionado para unicidade
+            entities_id: 0, // Ajuste conforme a entidade do GLPI
+            // Add more hardware fields if metrics provide them (e.g., memory_size, cpu_name)
+          },
+          os: {
+            full_name: service.type === 'SNMP' ? 'Network OS' : 'Unknown OS',
+            version: 'N/A',
+          },
+          networks: [
+            {
+              description: `${service.name}`,
+              ipaddress: ipAddress,
+              mac: metrics.mac || '', // Add if available from metrics
+            },
+          ],
+          softwares: [
+            {
+              name: service.name,
+              version: metrics.packageVersion ||'N/A',
+              comment: `Service Type: ${service.type}, Status: ${metrics.status || 'Unknown'}`,
+            },
+          ],
+          // Add virtualmachines if your services include VMs/containers
+          "virtualmachines": [
+            {
+              "name": service.name,
+              "uuid": `vm-${service.id}`,
+              "comment": `Tipo de Serviço: ${service.type}`
+            }
+          ],
+        },
+        deviceid: `infrawatch-${service.id}`,
+        tag: 'infrawatch-auto',
+      };
+
+      // Push to GLPI
+      try {
+        const response = await axios.post(GLPI_INVENTORY_URL, inventoryJson, {
+          headers: {
+            'Content-Type': 'application/json',
+            'Authorization': `Bearer ${GLPI_AGENT_TOKEN}`,
+          },
+        });
+
+        if (response.status !== 200) {
+          console.error(`Failed to push service ${service.id} to GLPI:`, response.data);
+        } else {
+          console.log(`Synced service ${service.id} to GLPI`);
+        }
+      } catch (error) {
+        console.error(`Erro ao enviar serviço ${service.id} para o GLPI:`, error.message);
+        // Corrigir verificação de erro
+        const errorMessage = error.response?.data
+          ? typeof error.response.data === 'string'
+            ? error.response.data
+            : JSON.stringify(error.response.data)
+          : 'Sem detalhes de erro';
+        if (errorMessage.includes('Inventory is disabled')) {
+          console.error('Inventário do GLPI está desabilitado. Habilite em Administração > Inventário.');
+        } else {
+          console.error('Detalhes do erro do GLPI:', errorMessage);
+        }
+      }
+    }
+  } catch (error) {
+    console.error('Error syncing assets to GLPI:', error.message);
+  }
+}
+
+// export async function createGlpiTicket(serviceName: string, description: string, criticality: string) {
+//   try {
+//     const sessionToken = await initGlpiSession();
+//     const ticketData = {
+//       name: `Falha no serviço: ${serviceName}`,
+//       content: description,
+//       urgency: criticality === 'high' ? 5 : criticality === 'medium' ? 3 : 1, // Mapeia criticidade
+//       impact: criticality === 'high' ? 5 : criticality === 'medium' ? 3 : 1,
+//       priority: criticality === 'high' ? 5 : criticality === 'medium' ? 3 : 1,
+//       entities_id: 0, // Ajuste para a entidade desejada no GLPI
+//       type: 1, // 1 = Incidente, 2 = Requisição
+//     };
+//     const ticket = await apiClient.assistance.add('Ticket', ticketData, { sessionToken });
+//     //console.log('Resposta completa do GLPI:', JSON.stringify(ticket, null, 2));
+//     const ticketId = ticket.id || ticket.data?.id || ticket.input?.id; // Tenta diferentes propriedades
+//     if (!ticketId) {
+//       throw new Error('ID do ticket não encontrado na resposta do GLPI');
+//     }
+//     console.log('Ticket criado no GLPI:', ticketId);
+//     return ticketId;
+//   } catch (error) {
+//     console.error('Erro ao criar ticket no GLPI:', error);
+//     throw new Error(`Falha ao criar ticket: ${error.message}`);
+//   }
+// }
+
+// export async function updateGlpiTicket(ticketId: number, updateData: { content: string }) {
+//   try {
+//     const sessionToken = await initGlpiSession();
+//     const updatedTicket = await apiClient.updateItem('Ticket', ticketId, updateData, { sessionToken });
+//     console.log('Ticket atualizado no GLPI:', ticketId);
+//     return updatedTicket;
+//   } catch (error) {
+//     console.error('Erro ao atualizar ticket no GLPI:', error);
+//     throw new Error(`Falha ao atualizar ticket: ${error.message}`);
+//   }
+// }
+
+export { apiClient }; // Exporta o cliente para uso em outros módulos
\ No newline at end of file
diff --git a/src/Integrations/GLPI/syncServices.ts b/src/Integrations/GLPI/syncServices.ts
new file mode 100644
index 0000000..29dc0a3
--- /dev/null
+++ b/src/Integrations/GLPI/syncServices.ts
@@ -0,0 +1,146 @@
+import axios from 'axios';
+import { PrismaClient } from '@prisma/client';
+import 'dotenv/config';
+
+const prisma = new PrismaClient();
+const GLPI_API_URL = process.env.GLPI_API_URL || 'http://localhost:8080/apirest.php';
+const GLPI_API_TOKEN = process.env.GLPI_APP_TOKEN;
+const GLPI_USER_TOKEN = process.env.GLPI_USER_TOKEN;
+const GLPI_ENTITY_ID = process.env.GLPI_ENTITY_ID || '0';
+
+let sessionToken: string | null = null;
+
+async function initGlpiSession() {
+  if (!GLPI_API_URL || !GLPI_API_TOKEN || !GLPI_USER_TOKEN) {
+    console.error('Configuração do GLPI incompleta:', {
+      GLPI_API_URL,
+      GLPI_API_TOKEN: GLPI_API_TOKEN ? 'Definido' : 'Ausente',
+      GLPI_USER_TOKEN: GLPI_USER_TOKEN ? 'Definido' : 'Ausente',
+    });
+    return null;
+  }
+  try {
+    const response = await axios.get(`${GLPI_API_URL}/initSession`, {
+      headers: {
+        'Content-Type': 'application/json',
+        'App-Token': GLPI_API_TOKEN,
+        'Authorization': `user_token ${GLPI_USER_TOKEN}`,
+      },
+    });
+    sessionToken = response.data.session_token;
+    console.log(`Sessão GLPI iniciada: Session-Token ${sessionToken}`);
+    return sessionToken;
+  } catch (error) {
+    console.error('Erro ao iniciar sessão GLPI:', error.message);
+    return null;
+  }
+}
+
+export async function syncServiceToGLPI(serviceId: string) {
+  if (!sessionToken) {
+    const token = await initGlpiSession();
+    if (!token) {
+      console.error('Falha ao iniciar sessão GLPI, sincronização abortada');
+      return;
+    }
+  }
+
+  const service = await prisma.service.findUnique({ where: { id: serviceId } });
+  if (!service) {
+    console.error(`Serviço ${serviceId} não encontrado`);
+    return;
+  }
+  // Validate service data
+  if (!service.name || !service.type) {
+    console.error(`Dados inválidos para serviço ${serviceId}:`, {
+      name: service.name,
+      type: service.type,
+      target: service.target,
+      criticality: service.criticality,
+    });
+    return;
+  }
+  
+  try {
+    const itemType = service.type === 'SNMP' ? 'NetworkEquipment' : 'Computer';
+    const serviceData = {
+      input: {
+        entities_id: GLPI_ENTITY_ID,
+        name: service.name,
+        serial: `infrawatch-${service.id}`,
+        otherserial: service.id,
+        comment: `Serviço monitorado pelo InfraWatch\nTipo: ${service.type}\nAlvo: ${service.target}\nCriticidade: ${service.criticality || 'medium'}`,
+        status: service.status === 'UP' ? 1 : 2, // 1 = Active, 2 = Inactive
+      },
+    };
+
+    // Check if service exists in GLPI
+    const searchResponse = await axios.get(`${GLPI_API_URL}/search/${itemType}`, {
+      headers: {
+        'Content-Type': 'application/json',
+        'App-Token': GLPI_API_TOKEN,
+        'Session-Token': sessionToken,
+      },
+      params: {
+        criteria: [{ field: 40, searchtype: 'equals', value: service.id }],
+      },
+    });
+
+    if (searchResponse.data.data && searchResponse.data.data.length > 0) {
+      // Update existing service
+      const glpiId = searchResponse.data.data[0][1];
+      await axios.put(`${GLPI_API_URL}/${itemType}/${glpiId}`, serviceData, {
+        headers: {
+          'Content-Type': 'application/json',
+          'App-Token': GLPI_API_TOKEN,
+          'Session-Token': sessionToken,
+        },
+      });
+      console.log(`Updated service ${service.id} in GLPI: ${itemType}/${glpiId}`);
+    } else {
+      // Create new service
+      const response = await axios.post(`${GLPI_API_URL}/${itemType}`, serviceData, {
+        headers: {
+          'Content-Type': 'application/json',
+          'App-Token': GLPI_API_TOKEN,
+          'Session-Token': sessionToken,
+        },
+      });
+      console.log(`Synced service ${service.id} to GLPI: ${itemType}/${response.data.id}`);
+    }
+  } catch (error) {
+    console.error(`Erro ao sincronizar serviço ${serviceId} com GLPI:`, {
+        message: error.message,
+        response: error.response?.data,
+        status: error.response?.status,
+      });
+  }
+}
+
+export async function syncAllServicesToGLPI() {
+  console.log('Sincronizando inventário com GLPI...');
+  const services = await prisma.service.findMany();
+  for (const service of services) {
+    await syncServiceToGLPI(service.id);
+  }
+}
+
+export async function killGlpiSession() {
+  if (!sessionToken) {
+    console.log('Nenhuma sessão GLPI ativa para encerrar');
+    return;
+  }
+  try {
+    await axios.get(`${GLPI_API_URL}/killSession`, {
+      headers: {
+        'Content-Type': 'application/json',
+        'App-Token': GLPI_API_TOKEN,
+        'Session-Token': sessionToken,
+      },
+    });
+    console.log('Sessão GLPI encerrada com sucesso');
+    sessionToken = null;
+  } catch (error) {
+    console.error('Erro ao encerrar sessão GLPI:', error.message);
+  }
+}
\ No newline at end of file
diff --git a/src/Integrations/GLPI/ticketManager.ts b/src/Integrations/GLPI/ticketManager.ts
new file mode 100644
index 0000000..2ed6fb1
--- /dev/null
+++ b/src/Integrations/GLPI/ticketManager.ts
@@ -0,0 +1,244 @@
+import axios from 'axios';
+import 'dotenv/config';
+
+const GLPI_API_URL = process.env.GLPI_API_URL || 'http://localhost:8080/apirest.php';
+const GLPI_API_TOKEN = process.env.GLPI_APP_TOKEN;
+const GLPI_ENTITY_ID = process.env.GLPI_ENTITY_ID || '0';
+const GLPI_USER_TOKEN = process.env.GLPI_USER_TOKEN;
+
+let sessionToken: string | null = null;
+
+async function initGlpiSession() {
+  if (!GLPI_API_URL || !GLPI_API_TOKEN || !GLPI_USER_TOKEN) {
+    console.error('Configuração do GLPI incompleta:');
+    console.error(`GLPI_API_URL: ${GLPI_API_URL}, GLPI_API_TOKEN: ${GLPI_API_TOKEN ? 'Definido' : 'Ausente'}, GLPI_USER_TOKEN: ${GLPI_USER_TOKEN ? 'Definido' : 'Ausente'}`);
+    return null;
+  }
+
+  try {
+    const response = await axios.get(`${GLPI_API_URL}/initSession`, {
+      headers: {
+        'Content-Type': 'application/json',
+        'App-Token': GLPI_API_TOKEN,
+        'Authorization': `user_token ${GLPI_USER_TOKEN}`,
+      },
+    });
+    sessionToken = response.data.session_token;
+    console.log(`Sessão GLPI iniciada: Session-Token ${sessionToken}`);
+    return sessionToken;
+  } catch (error) {
+    console.error('Erro ao iniciar sessão GLPI:', error.message);
+    console.error('Detalhes do erro:', error.response?.data || 'Sem detalhes');
+    return null;
+  }
+}
+
+export async function createGlpiTicket(serviceId: string, serviceName: string, serviceType: string, reason: string) {
+  if (!GLPI_API_URL || !GLPI_API_TOKEN) {
+    console.error('Configuração do GLPI incompleta: GLPI_API_URL ou GLPI_API_TOKEN ausente');
+    return null;
+  }
+
+  if (!sessionToken) {
+    const token = await initGlpiSession();
+    if (!token) {
+      console.error('Falha ao iniciar sessão GLPI, ticket não será criado');
+      return null;
+    }
+  }
+
+  // Definir severidade com base no motivo
+  const urgency = reason.includes('DOWN') || reason.includes('crítico') || reason.includes('CPU') ? 5 : 3; // 5 = Muito Alta, 3 = Média
+  const impact = reason.includes('DOWN') || reason.includes('crítico') || reason.includes('CPU') ? 5 : 3; // 5 = Alto, 3 = Médio
+  const priority = urgency === 5 && impact === 5 ? 5 : 3; // 5 = Crítico, 3 = Médio
+
+  const ticketData = {
+    input: {
+      entities_id: GLPI_ENTITY_ID,
+      name: `Incidente: ${serviceName} - ${reason}`,
+      content: `Alerta do InfraWatch\nServiço: ${serviceName}\nID: ${serviceId}s\nMotivo: ${reason}\nTipo: ${serviceType}`,
+      urgency,
+      impact,
+      priority,
+      type: 1, // 1 = Incidente
+      itilcategories_id: 0, // Ajuste para categoria específica
+      _link: {
+        items_id: `infrawatch-${serviceId}`,
+        itemtype: serviceType === 'SNMP' ? 'NetworkEquipment' : 'Computer',
+      },
+    },
+  };
+
+  try {
+    const response = await axios.post(`${GLPI_API_URL}/Ticket`, ticketData, {
+      headers: {
+        'Content-Type': 'application/json',
+        'App-Token': GLPI_API_TOKEN,
+        'Session-Token': sessionToken, // Obtenha via /initSession se necessário
+      },
+    });
+
+    if (response.status === 201) {
+      const ticketId = response.data.id;
+      const ticketUrl = `${GLPI_API_URL}/Ticket/${ticketId}`;
+      console.log(`Ticket criado para serviço ${serviceId}: ID ${ticketId}, URL ${ticketUrl}`);
+      return { ticketId, ticketUrl };
+    } else {
+      console.error(`Falha ao criar ticket para serviço ${serviceId}:`, response.data);
+      return null;
+    }
+  } catch (error) {
+    console.error(`Erro ao criar ticket para serviço ${serviceId}:`, error.message);
+    console.error('Detalhes do erro:', error.response?.data || 'Sem detalhes');
+    return null;
+  }
+}
+
+export async function closeGlpiTicket(ticketId: number) {
+  if (!GLPI_API_URL || !GLPI_API_TOKEN) {
+    console.error('Configuração do GLPI incompleta');
+    return;
+  }
+
+  if (!sessionToken) {
+    const token = await initGlpiSession();
+    if (!token) {
+      console.error('Falha ao iniciar sessão GLPI, ticket não será fechado');
+      return;
+    }
+  }
+
+  try {
+    const response = await axios.put(`${GLPI_API_URL}/Ticket/${ticketId}`, {
+      input: {
+        id: ticketId,
+        status: 6, // 6 = Fechado
+      },
+    }, {
+      headers: {
+        'Content-Type': 'application/json',
+        'App-Token': GLPI_API_TOKEN,
+        'Session-Token': sessionToken,
+      },
+    });
+
+    if (response.status === 200) {
+      console.log(`Ticket ${ticketId} fechado com sucesso`);
+    } else {
+      console.error(`Falha ao fechar ticket ${ticketId}:`, response.data);
+    }
+  } catch (error) {
+    console.error(`Erro ao fechar ticket ${ticketId}:`, error.message);
+  }
+}
+
+export async function killGlpiSession() {
+    if (!sessionToken) {
+      console.log('Nenhuma sessão GLPI ativa para encerrar');
+      return;
+    }
+  
+    try {
+      await axios.get(`${GLPI_API_URL}/killSession`, {
+        headers: {
+          'Content-Type': 'application/json',
+          'App-Token': GLPI_API_TOKEN,
+          'Session-Token': sessionToken,
+        },
+      });
+      console.log('Sessão GLPI encerrada com sucesso');
+      sessionToken = null;
+    } catch (error) {
+      console.error('Erro ao encerrar sessão GLPI:', error.message);
+    }
+  }
+
+
+// import axios from 'axios';
+// import 'dotenv/config';
+
+// const GLPI_API_URL = process.env.GLPI_API_URL || 'http://localhost:8080/apirest.php';
+// const GLPI_API_TOKEN = process.env.GLPI_API_TOKEN;
+// const GLPI_ENTITY_ID = process.env.GLPI_ENTITY_ID || '0';
+
+// export async function createGlpiTicket(serviceId: string, serviceName: string, serviceType: string, reason: string, criticality: string = 'medium') {
+//   if (!GLPI_API_URL || !GLPI_API_TOKEN) {
+//     console.error('Configuração do GLPI incompleta: GLPI_API_URL ou GLPI_API_TOKEN ausente');
+//     return null;
+//   }
+
+//   const urgency = criticality === 'critical' || reason.includes('DOWN') || reason.includes('CPU') ? 5 : 3;
+//   const impact = criticality === 'critical' || reason.includes('DOWN') || reason.includes('CPU') ? 5 : 3;
+//   const priority = urgency === 5 && impact === 5 ? 5 : 3;
+
+//   const ticketData = {
+//     input: {
+//       entities_id: GLPI_ENTITY_ID,
+//       name: `Incidente: ${serviceName} - ${reason}`,
+//       content: `Alerta do InfraWatch\nServiço: ${serviceName}\nID: ${serviceId}\nMotivo: ${reason}\nTipo: ${serviceType}\nCriticidade: ${criticality}`,
+//       urgency,
+//       impact,
+//       priority,
+//       type: 1, // 1 = Incidente
+//       itilcategories_id: 0,
+//       _link: {
+//         items_id: `infrawatch-${serviceId}`,
+//         itemtype: serviceType === 'SNMP' ? 'NetworkEquipment' : 'Computer',
+//       },
+//     },
+//   };
+
+//   try {
+//     const response = await axios.post(`${GLPI_API_URL}/Ticket`, ticketData, {
+//       headers: {
+//         'Content-Type': 'application/json',
+//         'App-Token': GLPI_API_TOKEN,
+//         'Session-Token': '',
+//       },
+//     });
+
+//     if (response.status === 201) {
+//       const ticketId = response.data.id;
+//       const ticketUrl = `${GLPI_API_URL}/Ticket/${ticketId}`;
+//       console.log(`Ticket criado para serviço ${serviceId}: ID ${ticketId}, URL ${ticketUrl}`);
+//       return { ticketId, ticketUrl };
+//     } else {
+//       console.error(`Falha ao criar ticket para serviço ${serviceId}:`, response.data);
+//       return null;
+//     }
+//   } catch (error) {
+//     console.error(`Erro ao criar ticket para serviço ${serviceId}:`, error.message);
+//     console.error('Detalhes do erro:', error.response?.data || 'Sem detalhes');
+//     return null;
+//   }
+// }
+
+// export async function closeGlpiTicket(ticketId: number) {
+//   if (!GLPI_API_URL || !GLPI_API_TOKEN) {
+//     console.error('Configuração do GLPI incompleta');
+//     return;
+//   }
+
+//   try {
+//     const response = await axios.put(`${GLPI_API_URL}/Ticket/${ticketId}`, {
+//       input: {
+//         id: ticketId,
+//         status: 6, // 6 = Fechado
+//       },
+//     }, {
+//       headers: {
+//         'Content-Type': 'application/json',
+//         'App-Token': GLPI_API_TOKEN,
+//         'Session-Token': '',
+//       },
+//     });
+
+//     if (response.status === 200) {
+//       console.log(`Ticket ${ticketId} fechado com sucesso`);
+//     } else {
+//       console.error(`Falha ao fechar ticket ${ticketId}:`, response.data);
+//     }
+//   } catch (error) {
+//     console.error(`Erro ao fechar ticket ${ticketId}:`, error.message);
+//   }
+// }
\ No newline at end of file
diff --git a/src/Monitoring/Checkers/.nfs00000001c1686fb20000003b b/src/Monitoring/Checkers/.nfs00000001c1686fb20000003b
new file mode 100644
index 0000000..b3027e9
--- /dev/null
+++ b/src/Monitoring/Checkers/.nfs00000001c1686fb20000003b
@@ -0,0 +1,45 @@
+import ping from 'ping';
+
+export async function CheckPING(target: string, count: number = 4, timeout: number = 5)
+{
+  const times: number[] = [];
+  let transmitted = 0;
+  let received = 0;
+
+  for (let i = 0; i < count; i++)
+  {
+    transmitted++;
+    const start = Date.now();
+    const res = await ping.promise.probe(target, { timeout });
+
+    if (res.alive)
+    {
+      received++;
+      times.push(Date.now() - start);
+    }
+    await new Promise(resolve => setTimeout(resolve, 1000));
+  }
+
+  const loss = ((transmitted - received) / transmitted) * 100;
+
+  const min = times.length > 0 ? Math.min(...times) : 0;
+  const max = times.length > 0 ? Math.max(...times) : 0;
+  const avg = times.length > 0 ? times.reduce((a, b) => a + b, 0) / times.length : 0;
+
+  const mdev = times.length > 0
+    ? Math.sqrt(times.map(t => Math.pow(t - avg, 2)).reduce((a, b) => a + b, 0) / times.length)
+    : 0;
+
+  return {
+    target,
+    packets_transmitted: transmitted,    
+    packets_received: received,          
+    percent_packet_loss: loss,           
+    minimum_response_ms: min,           
+    maximum_response_ms: max,
+    average_response_ms: avg,
+    standard_deviation_ms: mdev,
+    ttl: null,
+    status: received > 0 ? 'UP' : 'DOWN'
+  };
+}
diff --git a/src/Monitoring/Checkers/CheckWEBHOOK.ts b/src/Monitoring/Checkers/CheckWEBHOOK.ts
new file mode 100644
index 0000000..70d594d
--- /dev/null
+++ b/src/Monitoring/Checkers/CheckWEBHOOK.ts
@@ -0,0 +1,65 @@
+import axios from 'axios';
+import { performance } from 'perf_hooks';
+import dns from 'dns';
+import { promisify } from 'util';
+
+const lookup = promisify(dns.lookup);
+
+interface WebhookCheckResult {
+  status: 'UP' | 'DOWN';
+  httpStatus?: number;
+  ip?: string;
+  sizeBytes?: number;
+  dnsMs?: number;
+  connectAndDownloadMs?: number;
+  totalMs: number;
+  headers?: Record<string, any>;
+  reason?: string;
+  payloadSent?: any;
+  responseBody?: string;
+}
+
+export async function CheckWebhook( url: string, payload: any = { ping: true }, timeout: number = 5000 ): Promise<WebhookCheckResult>
+{
+  const timings: Record<string, number> = {};
+  const startTotal = performance.now();
+
+  try
+  {
+    const startDNS = performance.now();
+    const { address } = await lookup(new URL(url).hostname);
+    timings.dnsMs = performance.now() - startDNS;
+
+    const startHTTP = performance.now();
+    const res = await axios.post(url, payload, {
+      timeout,
+      responseType: 'arraybuffer'
+    });
+    timings.httpMs = performance.now() - startHTTP;
+
+    const totalTime = performance.now() - startTotal;
+
+    return {
+      status: res.status >= 200 && res.status < 300 ? 'UP' : 'DOWN',
+      httpStatus: res.status,
+      ip: address,
+      sizeBytes: res.data.length,
+      dnsMs: timings.dnsMs,
+      connectAndDownloadMs: timings.httpMs,
+      totalMs: totalTime,
+      headers: res.headers,
+      payloadSent: payload,
+      responseBody: res.data.toString()
+    };
+  }
+  catch (err: any)
+  {
+    const totalTime = performance.now() - startTotal;
+    return {
+      status: 'DOWN',
+      reason: err.code || err.message,
+      totalMs: totalTime,
+      payloadSent: payload
+    };
+  }
+}
diff --git a/src/Monitoring/Checkers/CheckWEBHOOKPASSIVE.ts.ts b/src/Monitoring/Checkers/CheckWEBHOOKPASSIVE.ts.ts
new file mode 100644
index 0000000..8d44474
--- /dev/null
+++ b/src/Monitoring/Checkers/CheckWEBHOOKPASSIVE.ts.ts
@@ -0,0 +1,39 @@
+export interface WebhookPassiveResult
+{
+    status: string;
+    totalMs: number;
+    httpStatus: number | null;
+    description: string;
+  
+    ip?: string;
+    sizeBytes?: number;
+    dnsMs?: number;
+    connectAndDownloadMs?: number;
+    headers?: Record<string, string | number | boolean>;
+    payloadSent?: any;
+    responseBody?: any;
+  }
+  
+  export function CheckWebhookPassive(payload: any): WebhookPassiveResult
+  {
+    const status =
+      payload?.status === "UP" || payload?.status === "DOWN"
+        ? payload.status
+        : "UNKNOWN";
+  
+    return {
+      status,
+      totalMs: payload?.durationMs ?? payload?.totalMs ?? 0,
+      httpStatus: payload?.httpStatus ?? null,
+      description: payload?.msg ?? "",
+      ip: payload?.ip ?? "",
+      sizeBytes: payload?.sizeBytes ?? 0,
+      dnsMs: payload?.dnsMs ?? 0,
+      connectAndDownloadMs: payload?.connectAndDownloadMs ?? 0,
+      headers: payload?.headers ?? {},
+      payloadSent: payload?.payloadSent ?? payload ?? {},
+      responseBody: payload?.responseBody ?? "",
+    };
+  }
+  
+  
\ No newline at end of file
diff --git a/src/Monitoring/Incidents/incidentManager.ts b/src/Monitoring/Incidents/incidentManager.ts
index 06e40a1..2beaf80 100644
--- a/src/Monitoring/Incidents/incidentManager.ts
+++ b/src/Monitoring/Incidents/incidentManager.ts
@@ -1,53 +1,270 @@
-import { PrismaClient } from "@prisma/client";
-import { countRecentUps } from "../../Influxdb/WriteMetrics/WriteServiceStatus";
+// import { PrismaClient } from "@prisma/client";
+// import { countRecentUps } from "../../Influxdb/WriteMetrics/WriteServiceStatus";
+// import axios from 'axios';
+// import { closeGlpiTicket, createGlpiTicket } from "../../Integrations/GLPI/ticketManager";
+
+// const prisma = new PrismaClient();
+// const INFRAWATCH_API_URL = 'http://localhost:3002/api';
+
+// export async function findOrOpenIncident(serviceId: string, reason?: string)
+// {
+//   try {
+//     // Fetch service details
+//     const service = await prisma.service.findUnique({
+//       where: { id: serviceId },
+//     });
+//     if (!service) {
+//       console.error(`Serviço ${serviceId} não encontrado`);
+//       return null;
+//     }
+
+//     // Determine metrics endpoint based on service type
+//     const metricsEndpoint = {
+//       HTTP: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/http`,
+//       PING: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/ping`,
+//       SNMP: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/snmp`,
+//       WEBHOOK: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/webhook`,
+//     }[service.type] || `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/http`;
+
+//     // Fetch metrics
+//     let status = 'UNKNOWN';
+//     let metrics: any = {};
+//     try {
+//       const metricsResponse = await axios.get(metricsEndpoint, {
+//         headers: { accept: 'application/json' },
+//       });
+//       metrics = metricsResponse.data[0] || {};
+//       status = metrics.status || (await countRecentUps(serviceId, 5) >= 3 ? 'UP' : 'DOWN');
+//     } catch (error) {
+//       console.error(`Falha ao buscar métricas para serviço ${serviceId}:`, error.message);
+//       status = (await countRecentUps(serviceId, 5) >= 3) ? 'UP' : 'DOWN';
+//     }
+
+//     // Determine reason for alert
+//     let reason = 'auto-open';
+//     if (status === 'DOWN') {
+//       reason = 'Serviço caiu';
+//     } else if (service.type === 'HTTP' && metrics.httpStatus >= 400) {
+//       reason = `Erro HTTP ${metrics.httpStatus}`;
+//     } else if (service.type === 'PING' && metrics.percent_packet_loss > 50) {
+//       reason = `Perda de pacotes alta (${metrics.percent_packet_loss}%)`;
+//     } else if (service.type === 'SNMP' && metrics.cpuUsage && metrics.cpuUsage > 90) {
+//       reason = `CPU acima de 90% (${metrics.cpuUsage}%)`;
+//     } else if (service.type === 'SNMP' && metrics.diskUsage && metrics.diskUsage > 90) {
+//       reason = `Disco cheio (${metrics.diskUsage}%)`;
+//     }
+
+//     // Check for open incident
+//     let incident = await prisma.incident.findFirst({
+//       where: { serviceId, closedAt: null },
+//     });
+
+//     if (!incident && (status === 'DOWN' || reason !== 'auto-open')) {
+//       // Create GLPI ticket
+//       const ticketResult = await createGlpiTicket(serviceId, service.name, service.type, reason);
+//       if (ticketResult) {
+//         incident = await prisma.incident.create({
+//           data: {
+//             id: undefined, // Let Prisma generate UUID
+//             serviceId,
+//             reason,
+//             openedAt: new Date(),
+//             glpiTicketId: ticketResult.ticketId,
+//             glpiTicketUrl: ticketResult.ticketUrl,
+//           },
+//         });
+//         console.log(`Incidente criado para serviço ${serviceId}, Ticket GLPI: ${ticketResult.ticketId}`);
+//       }
+//     }
+//     return incident;
+//   } catch (error) {
+//     console.error(`Erro em findOrOpenIncident para serviço ${serviceId}:`, error.message);
+//     throw error;
+//   }
+// }
+
+// export async function closeIncidentIfRecovered(serviceId: string, recoveryConfirmations: number) {
+//   try {
+//     const ups = await countRecentUps(serviceId, 5);
+//     const openIncidents = await prisma.incident.findMany({
+//       where: { serviceId, closedAt: null },
+//     });
+
+//     if (openIncidents.length > 0 && ups >= recoveryConfirmations) {
+//       for (const incident of openIncidents) {
+//         if (incident.glpiTicketId) {
+//           await closeGlpiTicket(incident.glpiTicketId);
+//         }
+//         await prisma.incident.update({
+//           where: { id: incident.id },
+//           data: { closedAt: new Date(), reason: 'auto-recovery' },
+//         });
+//         console.log(`Incidente fechado para serviço ${serviceId}, Ticket GLPI: ${incident.glpiTicketId}`);
+//       }
+//     }
+//   } catch (error) {
+//     console.error(`Erro ao verificar recuperação do serviço ${serviceId}:`, error.message);
+//   }
+// }
+
+// export async function updateIncidentNotification(incidentId: string, retryCount: number) {
+//   console.log(`Chamando updateIncidentNotification com incidentId: ${incidentId}, retryCount: ${retryCount}`);
+//   try {
+//     const incident = await prisma.incident.findUnique({
+//       where: { id: incidentId },
+//     });
+//     if (!incident) {
+//       console.error(`Incidente ${incidentId} não encontrado`);
+//       return;
+//     }
+//     await prisma.incident.update({
+//       where: { id: incidentId },
+//       data: { lastNotificationAt: new Date(), retryCount },
+//     });
+//     console.log(`Notificação atualizada para incidente ${incidentId}, retryCount: ${retryCount}`);
+//   } catch (error) {
+//     console.error(`Erro ao atualizar notificação do incidente ${incidentId}:`, error.message);
+//   }
+// }
+
+import { PrismaClient } from '@prisma/client';
+import axios from 'axios';
+import { countRecentUps } from '../../Influxdb/WriteMetrics/WriteServiceStatus';
+import { createGlpiTicket, closeGlpiTicket } from '../../Integrations/GLPI/ticketManager';
 
 const prisma = new PrismaClient();
+const INFRAWATCH_API_URL = 'http://localhost:3002/api';
+
+export async function findOrOpenIncident(serviceId: string) {
+  try {
+    const service = await prisma.service.findUnique({
+      where: { id: serviceId },
+    });
+    if (!service) {
+      console.error(`Serviço ${serviceId} não encontrado`);
+      return null;
+    }
+
+    const metricsEndpoint = {
+      HTTP: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/http`,
+      PING: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/ping`,
+      SNMP: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/snmp`,
+      WEBHOOK: `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/webhook`,
+    }[service.type] || `${INFRAWATCH_API_URL}/services/${serviceId}/metrics/http`;
 
-export async function findOrOpenIncident(serviceId: string, reason?: string)
-{
-  let incident = await prisma.incident.findFirst(
-  {
-    where: { serviceId, closedAt: null },
-  });
-
-  if (!incident)
-  {
-    incident = await prisma.incident.create({
-      data: { serviceId, reason: reason ?? "auto-open" },
+    let status = 'UNKNOWN';
+    let metrics: any = {};
+    try {
+      const metricsResponse = await axios.get(metricsEndpoint, {
+        headers: { accept: 'application/json' },
+      });
+      metrics = metricsResponse.data[0] || {};
+      status = metrics.status || (await countRecentUps(serviceId, 5) >= 3 ? 'UP' : 'DOWN');
+    } catch (error) {
+      console.error(`Falha ao buscar métricas para serviço ${serviceId}:`, error.message);
+      status = (await countRecentUps(serviceId, 5) >= 3) ? 'UP' : 'DOWN';
+    }
+
+    let reason = 'No issues detected';
+    let criticality = service.criticality || 'medium';
+    if (status === 'DOWN') {
+      reason = 'Serviço caiu';
+      criticality = 'critical';
+    } else if (service.type === 'HTTP' && metrics.httpStatus >= 400) {
+      reason = `Erro HTTP ${metrics.httpStatus}`;
+      criticality = metrics.httpStatus >= 500 ? 'critical' : 'high';
+    } else if (service.type === 'PING' && metrics.percent_packet_loss > 50) {
+      reason = `Perda de pacotes alta (${metrics.percent_packet_loss}%)`;
+      criticality = metrics.percent_packet_loss === 100 ? 'critical' : 'high';
+    } else if (service.type === 'SNMP' && metrics.cpuUsage && metrics.cpuUsage > 90) {
+      reason = `CPU acima de 90% (${metrics.cpuUsage}%)`;
+      criticality = 'critical';
+    } else if (service.type === 'SNMP' && metrics.diskUsage && metrics.diskUsage > 90) {
+      reason = `Disco cheio (${metrics.diskUsage}%)`;
+      criticality = 'critical';
+    }
+
+    // Verificar incidente aberto
+    const incident = await prisma.incident.findFirst({
+      where: { serviceId, closedAt: null },
     });
+
+    // Só criar incidente se houver um problema real
+    if (!incident && (status === 'DOWN' || reason !== 'No issues detected')) {
+      const ticketResult = await createGlpiTicket(serviceId, service.name, service.type, reason, criticality);
+      if (ticketResult) {
+        const newIncident = await prisma.incident.create({
+          data: {
+            id: undefined, // Deixa o Prisma gerar UUID
+            serviceId,
+            reason,
+            openedAt: new Date(),
+            glpiTicketId: String(ticketResult.ticketId),
+            glpiTicketUrl: ticketResult.ticketUrl,
+          },
+        });
+        console.log(`Incidente criado para serviço ${serviceId}, Ticket GLPI: ${ticketResult.ticketId}`);
+        return newIncident;
+      } else {
+        console.error(`Falha ao criar ticket para serviço ${serviceId}, incidente não criado`);
+        return null;
+      }
+    } else if (incident && status === 'UP' && reason === 'No issues detected') {
+      await closeIncidentIfRecovered(serviceId, 3);
+      return null; // Não retornar incidente fechado
+    }
+
+    return incident;
+  } catch (error) {
+    console.error(`Erro em findOrOpenIncident para serviço ${serviceId}:`, error.message);
+    return null;
   }
-  return incident;
 }
 
-export async function closeIncidentIfRecovered( serviceId: string, recoveryConfirmations: number)
-{
-  try
-  {
+export async function closeIncidentIfRecovered(serviceId: string, recoveryConfirmations: number) {
+  try {
     const ups = await countRecentUps(serviceId, 5);
-    const openIncidents = await prisma.incident.findMany(
-    {
+    const openIncidents = await prisma.incident.findMany({
       where: { serviceId, closedAt: null },
     });
 
-    if (openIncidents.length > 0 && ups >= recoveryConfirmations)
-    {
-      await prisma.incident.updateMany({
-        where: { serviceId, closedAt: null },
-        data: { closedAt: new Date(), reason: "auto-recovery" },
-      });
+    if (openIncidents.length > 0 && ups >= recoveryConfirmations) {
+      for (const incident of openIncidents) {
+        if (incident.glpiTicketId) {
+          await closeGlpiTicket(Number(incident.glpiTicketId));
+        } else {
+          console.warn(`Incidente ${incident.id} para serviço ${serviceId} não tem ticket GLPI associado`);
+        }
+        await prisma.incident.update({
+          where: { id: incident.id },
+          data: { closedAt: new Date(), reason: 'auto-recovery' },
+        });
+        console.log(`Incidente fechado para serviço ${serviceId}, Ticket GLPI: ${incident.glpiTicketId || 'null'}`);
+      }
+    } else if (openIncidents.length > 0) {
+      console.log(`Serviço ${serviceId} ainda não recuperado. Incidente(s) mantido(s) aberto(s).`);
     }
-  }
-  catch (err)
-  {
-    console.error( `Erro ao verificar recuperação do serviço ${serviceId}:`, err);
+  } catch (error) {
+    console.error(`Erro ao verificar recuperação do serviço ${serviceId}:`, error.message);
   }
 }
 
-export async function updateIncidentNotification( incidentId: string, retryCount: number)
-{
-  await prisma.incident.update(
-  {
-    where: { id: incidentId },
-    data: { lastNotificationAt: new Date(), retryCount },
-  });
+export async function updateIncidentNotification(incidentId: string, retryCount: number) {
+  console.log(`Chamando updateIncidentNotification com incidentId: ${incidentId}, retryCount: ${retryCount}`);
+  try {
+    const incident = await prisma.incident.findUnique({
+      where: { id: incidentId },
+    });
+    if (!incident) {
+      console.error(`Incidente ${incidentId} não encontrado`);
+      return;
+    }
+    await prisma.incident.update({
+      where: { id: incidentId },
+      data: { lastNotificationAt: new Date(), retryCount },
+    });
+    console.log(`Notificação atualizada para incidente ${incidentId}, retryCount: ${retryCount}`);
+  } catch (error) {
+    console.error(`Erro ao atualizar notificação do incidente ${incidentId}:`, error.message);
+  }
 }
\ No newline at end of file
diff --git "a/src/Monitoring/Integra\303\247\303\265esExternas/GLPI/GlpiClients.ts" "b/src/Monitoring/Integra\303\247\303\265esExternas/GLPI/GlpiClients.ts"
new file mode 100644
index 0000000..6be9779
--- /dev/null
+++ "b/src/Monitoring/Integra\303\247\303\265esExternas/GLPI/GlpiClients.ts"
@@ -0,0 +1,263 @@
+
+import { GLPIClient } from '@atno/ts-glpi-client';
+import dotenv from 'dotenv';
+import { PrismaClient, ServiceType, Role } from '@prisma/client';
+import axios from 'axios';
+import 'dotenv/config';
+
+dotenv.config();
+
+const prisma = new PrismaClient();
+
+// Cria o cliente GLPI
+const client = new GLPIClient(
+  process.env.GLPI_URL!,
+  process.env.GLPI_APP_TOKEN!
+);
+
+// Mantém o apiClient globalmente se quiser evitar múltiplas autenticações
+let apiClient: any;
+
+async function initGlpiSession() {
+  try {
+    apiClient = await client.authenticateWithToken(process.env.GLPI_USER_TOKEN!);
+    console.log('Sessão GLPI iniciada.');
+  } catch (error: any) {
+    console.error('Erro ao iniciar sessão GLPI:', error);
+    throw new Error(`Falha na autenticação GLPI: ${error.message}`);
+  }
+}
+
+// Função para garantir um usuário default
+async function getOrCreateDefaultUser() {
+  let defaultUser = await prisma.user.findUnique({
+    where: { id: 'default' }, // Ou use um ID existente, ex: '1'
+  });
+
+  if (!defaultUser) {
+    defaultUser = await prisma.user.create({
+      data: {
+        id: 'default', // Ou use autoincrement se id for Int
+        name: 'Default User',
+        email: 'default@example.com',
+        password: 'defaultpassword', // Hash isso em produção
+        role: Role.USER, // Use enum Role do schema
+      },
+    });
+    console.log('Usuário default criado:', defaultUser.id);
+  }
+  return defaultUser.id;
+}
+
+// export async function syncGlpiInventory() {
+//   try {
+//     if (!apiClient) {
+//       await initGlpiSession();
+//     }
+
+//     const response = await apiClient.actives.getAll('Computer') ; // ou outro tipo de item
+//     const items = response.data;
+//     const defaultOwnerId = await getOrCreateDefaultUser();
+//     console.log('Itens recebidos do GLPI:', items);
+
+//     if (!Array.isArray(items)) {
+//       throw new Error('GLPI não retornou uma lista de computadores.');
+//     }
+
+//     for (const item of items) {
+//       await prisma.service.upsert({
+//         where: { id: item.id.toString() },
+//         update: {
+//           name: item.name,
+//           target: item.ip || item.name,
+//           type: ServiceType.PING,
+//           criticality: item.criticality || 'medium',
+//         },
+//         create: {
+//           id: item.id.toString(),
+//           name: item.name,
+//           target: item.ip || item.name,
+//           type: ServiceType.PING,
+//           ownerId: defaultOwnerId,
+//           criticality: item.criticality || 'medium',
+//           createdAt: new Date(),
+//           updatedAt: new Date(),
+//         },
+//       });
+//     }
+
+//     console.log('Inventário GLPI sincronizado com sucesso.');
+//   } catch (error: any) {
+//     console.error('Erro ao sincronizar inventário GLPI:', error);
+//     throw new Error(`Falha na sincronização: ${error.message}`);
+//   }
+// }
+
+const GLPI_INVENTORY_URL = process.env.GLPI_INVENTORY_URL || 'http://localhost:8080/front/inventory.php';
+const GLPI_AGENT_TOKEN = process.env.GLPI_AGENT_TOKEN;
+const INFRAWATCH_API_URL = 'http://localhost:3002/api';
+
+export async function syncGlpiInventory() {
+  // Validate environment variables
+  if (!GLPI_INVENTORY_URL || !GLPI_AGENT_TOKEN) {
+    console.error('GLPI inventory configuration is incomplete');
+    return;
+  }
+
+  try {
+    // Fetch all services
+    const servicesResponse = await axios.get(`${INFRAWATCH_API_URL}/services`, {
+      headers: { accept: 'application/json' },
+    });
+    const services = servicesResponse.data;
+
+    for (const service of services) {
+      // Fetch metrics for HTTP services
+      let metrics = {};
+      if (service.type === 'HTTP') {
+        try {
+          const metricsResponse = await axios.get(`${INFRAWATCH_API_URL}/services/${service.id}/metrics/http`, {
+            headers: { accept: 'application/json' },
+          });
+          metrics = metricsResponse.data[0] || {};
+        } catch (error) {
+          console.error(`Failed to fetch metrics for service ${service.id}:`, error.message);
+        }
+      }
+      if (service.type === 'SNMP') {
+        try {
+          const snmpMetrics = await axios.get(`${INFRAWATCH_API_URL}/services/${service.id}/metrics/snmp`);
+          metrics = { ...metrics, ...snmpMetrics.data[0] };
+        } catch (error) {
+          console.error(`Falha ao buscar métricas SNMP para ${service.id}:`, error.message);
+        }
+      }
+
+      // Map service type to GLPI asset type
+      const assetTypeMap: { [key: string]: string } = {
+        HTTP: 'Computer',
+        PING: 'Computer',
+        SNMP: 'NetworkEquipment',
+      };
+      const glpiAssetType = assetTypeMap[service.type] || 'Computer';
+
+      
+      // Generate GLPI inventory JSON
+      const inventoryJson = {
+        //_tracking_inventory: 1,
+        deviceid: `infrawatch-${service.id}`,
+        content: {
+          versionclient: '1.0',
+          hardware: {
+            name: service.name || 'Unknown Asset',
+            uuid: `infrawatch-${service.id}`,
+            memory_size: metrics.memory || 0,
+            cpu_names: metrics.cpu || "Desconhecido",
+            serial: `INFRAWATCH-${service.id}`, // Adicionado para unicidade
+            entities_id: 0, // Ajuste conforme a entidade do GLPI
+            // Add more hardware fields if metrics provide them (e.g., memory_size, cpu_name)
+          },
+          os: {
+            full_name: service.type === 'SNMP' ? 'Network OS' : 'Unknown OS',
+            version: 'N/A',
+          },
+          networks: [
+            {
+              description: `Service Target: ${service.name}`,
+              //ipaddress: metrics.ip || (service.target.includes('://') ? service.target.split('://')[1].split('/')[0] : service.target),
+              mac: metrics.mac || '', // Add if available from metrics
+            },
+          ],
+          softwares: [
+            {
+              name: service.name,
+              version: metrics.packageVersion ||'N/A',
+              comment: `Service Type: ${service.type}, Status: ${metrics.status || 'Unknown'}`,
+            },
+          ],
+          // Add virtualmachines if your services include VMs/containers
+          "virtualmachines": [
+            {
+              "name": service.name,
+              "uuid": `vm-${service.id}`,
+              "comment": `Tipo de Serviço: ${service.type}`
+            }
+          ],
+        },
+        deviceid: `infrawatch-${service.id}`,
+        tag: 'infrawatch-auto',
+      };
+
+      // Push to GLPI
+      try {
+        const response = await axios.post(GLPI_INVENTORY_URL, inventoryJson, {
+          headers: {
+            'Content-Type': 'application/json',
+            'Authorization': `Bearer ${GLPI_AGENT_TOKEN}`,
+          },
+        });
+
+        if (response.status !== 200) {
+          console.error(`Failed to push service ${service.id} to GLPI:`, response.data);
+        } else {
+          console.log(`Synced service ${service.id} to GLPI`);
+        }
+      } catch (error) {
+        console.error(`Erro ao enviar serviço ${service.id} para o GLPI:`, error.message);
+        // Corrigir verificação de erro
+        const errorMessage = error.response?.data
+          ? typeof error.response.data === 'string'
+            ? error.response.data
+            : JSON.stringify(error.response.data)
+          : 'Sem detalhes de erro';
+        if (errorMessage.includes('Inventory is disabled')) {
+          console.error('Inventário do GLPI está desabilitado. Habilite em Administração > Inventário.');
+        } else {
+          console.error('Detalhes do erro do GLPI:', errorMessage);
+        }
+      }
+    }
+  } catch (error) {
+    console.error('Error syncing assets to GLPI:', error.message);
+  }
+}
+
+// export async function createGlpiTicket(serviceName: string, description: string, criticality: string) {
+//   try {
+//     const sessionToken = await initGlpiSession();
+//     const ticketData = {
+//       name: `Falha no serviço: ${serviceName}`,
+//       content: description,
+//       urgency: criticality === 'high' ? 5 : criticality === 'medium' ? 3 : 1, // Mapeia criticidade
+//       impact: criticality === 'high' ? 5 : criticality === 'medium' ? 3 : 1,
+//       priority: criticality === 'high' ? 5 : criticality === 'medium' ? 3 : 1,
+//       entities_id: 0, // Ajuste para a entidade desejada no GLPI
+//       type: 1, // 1 = Incidente, 2 = Requisição
+//     };
+//     const ticket = await apiClient.assistance.add('Ticket', ticketData, { sessionToken });
+//     //console.log('Resposta completa do GLPI:', JSON.stringify(ticket, null, 2));
+//     const ticketId = ticket.id || ticket.data?.id || ticket.input?.id; // Tenta diferentes propriedades
+//     if (!ticketId) {
+//       throw new Error('ID do ticket não encontrado na resposta do GLPI');
+//     }
+//     console.log('Ticket criado no GLPI:', ticketId);
+//     return ticketId;
+//   } catch (error) {
+//     console.error('Erro ao criar ticket no GLPI:', error);
+//     throw new Error(`Falha ao criar ticket: ${error.message}`);
+//   }
+// }
+
+// export async function updateGlpiTicket(ticketId: number, updateData: { content: string }) {
+//   try {
+//     const sessionToken = await initGlpiSession();
+//     const updatedTicket = await apiClient.updateItem('Ticket', ticketId, updateData, { sessionToken });
+//     console.log('Ticket atualizado no GLPI:', ticketId);
+//     return updatedTicket;
+//   } catch (error) {
+//     console.error('Erro ao atualizar ticket no GLPI:', error);
+//     throw new Error(`Falha ao atualizar ticket: ${error.message}`);
+//   }
+// }
+
+export { apiClient }; // Exporta o cliente para uso em outros módulos
\ No newline at end of file
diff --git a/src/Monitoring/SlaTracking/slaCalculator.ts b/src/Monitoring/SlaTracking/slaCalculator.ts
index e7aab9f..36ac1d5 100644
--- a/src/Monitoring/SlaTracking/slaCalculator.ts
+++ b/src/Monitoring/SlaTracking/slaCalculator.ts
@@ -4,161 +4,46 @@ export interface SlaResult {
   totalChecks: number;
   upChecks: number;
   downChecks: number;
-  uptimePercentage: number | null;
-
-  serviceId: string;
-  start: Date;
-  end: Date;
-
-  upDurationMs?: number;
-  downDurationMs?: number;
-  unknownDurationMs?: number;
-  uptimePercentageByTime?: number | null;
-  inferredSampleIntervalMs?: number;
-}
-
-function assertEnvBucket() {
-  const bucket = process.env.INFLUX_BUCKET?.trim();
-  if (!bucket) throw new Error("INFLUX_BUCKET não definido.");
-  return bucket;
-}
-
-function sanitizeServiceId(id: string): string {
-  return id.replace(/"/g, '\\"');
-}
-
-function isUpValue(v: unknown): boolean {
-  if (typeof v === "string") {
-    const s = v.trim().toLowerCase();
-    if (s === "up" || s === "1" || s === "true") return true;
-    if (s === "down" || s === "0" || s === "false") return false;
-    return false;
-  }
-  if (typeof v === "number") return v === 1;
-  if (typeof v === "boolean") return v;
-  return false;
-}
-
-type StatusRow = { _time: string; _value: unknown };
-type LastBeforeRow = { _time: string; _value: unknown };
-
-async function queryRows<T = any>(flux: string): Promise<T[]> {
-  return new Promise<T[]>((resolve, reject) => {
-    const rows: T[] = [];
-    queryApi.queryRows(flux, {
-      next: (row, tableMeta) => { rows.push(tableMeta.toObject(row) as unknown as T); },
-      error: reject,
-      complete: () => resolve(rows),
-    });
-  });
-}
-
-export function inferSampleIntervalMs(points: Date[]): number {
-  if (points.length < 2) return 300_000;
-  const deltas: number[] = [];
-  for (let i = 1; i < points.length; i++) deltas.push(points[i].getTime() - points[i - 1].getTime());
-  deltas.sort((a, b) => a - b);
-  const mid = Math.floor(deltas.length / 2);
-  return deltas.length % 2 ? deltas[mid] : Math.floor((deltas[mid - 1] + deltas[mid]) / 2);
-}
-
-export function computeDurations(
-  start: Date,
-  end: Date,
-  rows: Array<{ time: Date; state: "UP" | "DOWN" }>,
-  lastBefore: { time: Date; state: "UP" | "DOWN" } | null,
-  inferredMs: number
-) {
-  const maxGap = 3 * inferredMs;
-  let upMs = 0, downMs = 0, unknownMs = 0;
-
-  let prevTime = start;
-  let currState: "UP" | "DOWN" | "UNKNOWN" = lastBefore ? lastBefore.state : "UNKNOWN";
-
-  const addSpan = (ms: number) => {
-    if (currState === "UP") upMs += ms;
-    else if (currState === "DOWN") downMs += ms;
-    else unknownMs += ms;
-  };
-
-  for (const r of rows) {
-    const t = r.time;
-    if (t <= prevTime) { currState = r.state; continue; }
-    const dt = t.getTime() - prevTime.getTime();
-    if (dt <= maxGap) addSpan(dt);
-    else { addSpan(maxGap); unknownMs += dt - maxGap; }
-    prevTime = t;
-    currState = r.state;
-  }
-
-  if (end > prevTime) {
-    const dt = end.getTime() - prevTime.getTime();
-    if (dt <= maxGap) addSpan(dt);
-    else { addSpan(maxGap); unknownMs += dt - maxGap; }
-  }
-
-  const denom = upMs + downMs;
-  const pctByTime = denom > 0 ? (upMs / denom) * 100 : null;
-
-  return { upDurationMs: upMs, downDurationMs: downMs, unknownDurationMs: unknownMs, uptimePercentageByTime: pctByTime };
+  uptimePercentage: number;
 }
 
 export class SlaCalculator {
-  static async calculate(serviceId: string, start: Date, end: Date): Promise<SlaResult> {
-    if (!(start instanceof Date) || isNaN(start.getTime())) throw new Error("Parâmetro 'start' inválido.");
-    if (!(end instanceof Date) || isNaN(end.getTime())) throw new Error("Parâmetro 'end' inválido.");
-    if (start >= end) throw new Error("Intervalo inválido: 'start' deve ser anterior a 'end'.");
-
-    const bucket = assertEnvBucket();
-    const sid = sanitizeServiceId(serviceId);
-    const startIso = start.toISOString();
-    const endIso = end.toISOString();
-
-    const fluxRange = `
-      from(bucket: "${bucket}")
-        |> range(start: ${startIso}, stop: ${endIso})
-        |> filter(fn: (r) => r._measurement == "service_status")
-        |> filter(fn: (r) => r._field == "status")
-        |> filter(fn: (r) => r.serviceId == "${sid}")
-        |> keep(columns: ["_time", "_value"])
-        |> sort(columns: ["_time"], desc: false)
-    `;
-    const rowsRange = await queryRows<StatusRow>(fluxRange);
-  const points: Array<{ time: Date; state: "UP" | "DOWN" }> = rowsRange.map(r => ({ time: new Date(r._time), state: isUpValue(r._value) ? "UP" : "DOWN" }));
-
-    const fluxLastBefore = `
-      from(bucket: "${bucket}")
-        |> range(start: ${new Date(0).toISOString()}, stop: ${startIso})
+  static async calculate(serviceId: string, start: Date, end: Date): Promise<SlaResult>
+  {
+    const query = `
+      from(bucket: "${process.env.INFLUX_BUCKET}")
+        |> range(start: ${start.toISOString()}, stop: ${end.toISOString()})
         |> filter(fn: (r) => r._measurement == "service_status")
+        |> filter(fn: (r) => r.serviceId == "${serviceId}")
         |> filter(fn: (r) => r._field == "status")
-        |> filter(fn: (r) => r.serviceId == "${sid}")
-        |> keep(columns: ["_time", "_value"])
-        |> last()
     `;
-    const lastRows = await queryRows<LastBeforeRow>(fluxLastBefore);
-  const lastBefore: { time: Date; state: "UP" | "DOWN" } | null = lastRows.length ? { time: new Date(lastRows[0]._time), state: isUpValue(lastRows[0]._value) ? "UP" : "DOWN" } : null;
 
-    const totalChecks = rowsRange.length;
-    const upChecks = rowsRange.filter(r => isUpValue(r._value)).length;
-    const downChecks = totalChecks - upChecks;
-    const uptimePercentage = totalChecks > 0 ? (upChecks / totalChecks) * 100 : null;
+    let total = 0;
+    let up = 0;
+    let down = 0;
+
+    await new Promise<void>((resolve, reject) => {
+      queryApi.queryRows(query, {
+        next: (row, tableMeta) => {
+          const o = tableMeta.toObject(row);
+          total++;
+          if (o._value === "UP")
+            up++;
+          else
+            down++;
+        },
+        error: (err) => reject(err),
+        complete: () => resolve(),
+      });
+    });
 
-    const inferredSampleIntervalMs = inferSampleIntervalMs(points.map(p => p.time));
-    const byTime = computeDurations(start, end, points, lastBefore, inferredSampleIntervalMs);
+    const uptime = total > 0 ? (up / total) * 100 : 0;
 
     return {
-      serviceId,
-      start,
-      end,
-      totalChecks,
-      upChecks,
-      downChecks,
-      uptimePercentage,
-      upDurationMs: byTime.upDurationMs,
-      downDurationMs: byTime.downDurationMs,
-      unknownDurationMs: byTime.unknownDurationMs,
-      uptimePercentageByTime: byTime.uptimePercentageByTime,
-      inferredSampleIntervalMs,
+      totalChecks: total,
+      upChecks: up,
+      downChecks: down,
+      uptimePercentage: uptime,
     };
   }
 }
diff --git a/src/Monitoring/SlaTracking/slaReportGenerator.ts b/src/Monitoring/SlaTracking/slaReportGenerator.ts
index 9418970..631c85f 100644
--- a/src/Monitoring/SlaTracking/slaReportGenerator.ts
+++ b/src/Monitoring/SlaTracking/slaReportGenerator.ts
@@ -1,66 +1,35 @@
 import PDFDocument from "pdfkit";
-import { SlaResult } from "./slaCalculator";
 
 export class SlaReportGenerator {
-  static async generatePDF(
-    serviceName: string,
-    sla: SlaResult,
-    start: Date,
-    end: Date
-  ): Promise<Buffer> {
+  static async generatePDF(serviceName: string, sla: any, start: Date, end: Date): Promise<Buffer> {
     return new Promise((resolve, reject) => {
       const doc = new PDFDocument({ margin: 50 });
       const buffers: Buffer[] = [];
 
       doc.on("data", buffers.push.bind(buffers));
-      doc.on("end", () => resolve(Buffer.concat(buffers)));
+      doc.on("end", () => {
+        const pdfBuffer = Buffer.concat(buffers);
+        resolve(pdfBuffer);
+      });
       doc.on("error", reject);
 
       doc.fontSize(20).text(`Relatório de SLA - ${serviceName}`, { align: "center" });
       doc.moveDown();
 
-      doc.fontSize(12).text(`Período: ${start.toISOString()}  —  ${end.toISOString()} (UTC)`);
+      doc.fontSize(12).text(`Período: ${start.toISOString()} até ${end.toISOString()}`);
       doc.moveDown();
 
-      const uptimeSamples =
-        sla.uptimePercentage == null ? "Sem dados" : `${sla.uptimePercentage.toFixed(2)}%`;
-
+      doc.fontSize(14).text("Resumo do SLA:");
       doc.fontSize(12).list([
         `Total de checks: ${sla.totalChecks}`,
         `Checks UP: ${sla.upChecks}`,
         `Checks DOWN: ${sla.downChecks}`,
-        `Uptime (por amostras): ${uptimeSamples}`,
+        `Uptime: ${sla.uptimePercentage.toFixed(2)}%`,
       ]);
       doc.moveDown();
 
-      if (typeof sla.uptimePercentageByTime === "number") {
-        doc.fontSize(11).text(
-          `Uptime (por tempo, excl. "desconhecido"): ${sla.uptimePercentageByTime.toFixed(2)}%`
-        );
-        doc.moveDown(0.5);
-      }
-
-      if (
-        typeof sla.upDurationMs === "number" &&
-        typeof sla.downDurationMs === "number" &&
-        typeof sla.unknownDurationMs === "number"
-      ) {
-        const fmt = (ms: number) => {
-          const s = Math.floor(ms / 1000);
-          const h = Math.floor(s / 3600);
-          const m = Math.floor((s % 3600) / 60);
-          const ss = s % 60;
-          return `${h}h ${m}m ${ss}s`;
-        };
-        doc.fontSize(10).fillColor("gray").text(
-          `Duração UP: ${fmt(sla.upDurationMs)}  •  Duração DOWN: ${fmt(
-            sla.downDurationMs
-          )}  •  Desconhecido: ${fmt(sla.unknownDurationMs)}`
-        );
-        doc.moveDown();
-      }
+      doc.fontSize(10).fillColor("gray").text("Gerado automaticamente pelo sistema de monitoramento.");
 
-      doc.fontSize(10).fillColor("gray").text("Gerado automaticamente pelo sistema de monitorização.");
       doc.end();
     });
   }
diff --git a/src/Monitoring/SlaTracking/slaService.ts b/src/Monitoring/SlaTracking/slaService.ts
index a5b1ac4..308071d 100644
--- a/src/Monitoring/SlaTracking/slaService.ts
+++ b/src/Monitoring/SlaTracking/slaService.ts
@@ -1,98 +1,47 @@
 import { SlaCalculator, SlaResult } from "./slaCalculator";
 
-type Unit = "m" | "h" | "d" | "w" | "mo" | "y";
+export class SlaService
+{
+  private static parsePeriod(period: string): { start: Date; end: Date }
+  {
+    const now = new Date();
+    let start: Date;
 
-function subtractComposite(now: Date, parts: Array<{ value: number; unit: Unit }>): Date {
-  let t = new Date(now);
-  for (const { value, unit } of parts) {
-    if (value <= 0) continue;
-    switch (unit) {
-      case "y":  { const d = new Date(t); d.setFullYear(d.getFullYear() - value); t = d; break; }
-      case "mo": { const d = new Date(t); d.setMonth(d.getMonth() - value); t = d; break; }
-      case "w":  t = new Date(t.getTime() - value * 604_800_000); break;
-      case "d":  t = new Date(t.getTime() - value * 86_400_000);  break;
-      case "h":  t = new Date(t.getTime() - value * 3_600_000);   break;
-      case "m":  t = new Date(t.getTime() - value * 60_000);      break;
+    if (period.endsWith("m"))
+    {
+      const minutes = parseInt(period.slice(0, -1));
+      start = new Date(now.getTime() - minutes * 60 * 1000);
     }
-  }
-  return t;
-}
-
-function parseCompositePeriodString(period: string): Array<{ value: number; unit: Unit }> {
-  if (typeof period !== "string" || !period.trim()) throw new Error("Período inválido: vazio.");
-  const p = period.trim().toLowerCase();
-
-  const re = /(\d+)\s*(mo|y|w|d|h|m)\b/gi;
-  const parts: Array<{ value: number; unit: Unit }> = [];
-
-  let match: RegExpExecArray | null;
-  while ((match = re.exec(p)) !== null) {
-    const value = parseInt(match[1], 10);
-    const unit = match[2] as Unit;
-    if (!Number.isFinite(value) || value <= 0) throw new Error("Período inválido: valores devem ser inteiros positivos.");
-    parts.push({ value, unit });
-  }
-
-  if (parts.length === 0) {
-    throw new Error("Período inválido. Exemplos: 15m, 6h, 7d, 2mo, 1h30m, 2w3d, 1y2mo.");
-  }
-
-  const cleaned = p.replace(re, "").trim();
-  if (cleaned.length > 0) {
-    throw new Error(`Período inválido: token não reconhecido perto de "${cleaned}".`);
-  }
-
-  return parts;
-}
-
-export class SlaService {
-  /**
-   * Recebe um período e devolve { start, end }.
-   * Formatos aceites:
-   *  - Composite: "15m", "6h", "7d", "2w3d", "1h30m", "1y2mo", etc.
-   *  - Prefixados legacy: "last-7d", "last-24h", etc. (equivalente a remover "last-").
-   *  - Mês específico: YYYY-MM (ex: 2025-01) => mês civil inteiro.
-   *  - Dia específico: YYYY-MM-DD => dia civil inteiro.
-   */
-  static parsePeriod(period: string): { start: Date; end: Date } {
-    if (typeof period !== 'string') throw new Error('Período inválido.');
-    let p = period.trim();
-    if (!p) throw new Error('Período vazio.');
-
-    // legacy prefix "last-"
-    if (p.startsWith('last-')) p = p.substring(5);
-
-    // YYYY-MM (mês)
-    if (/^\d{4}-\d{2}$/.test(p)) {
-      const [y, m] = p.split('-').map(Number);
-      const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0, 0));
-      const end = new Date(Date.UTC(y, m, 1, 0, 0, 0, 0));
-      return { start, end };
+    else if (period.endsWith("h"))
+    {
+      const hours = parseInt(period.slice(0, -1));
+      start = new Date(now.getTime() - hours * 60 * 60 * 1000);
     }
-    // YYYY-MM-DD (dia)
-    if (/^\d{4}-\d{2}-\d{2}$/.test(p)) {
-      const [y, m, d] = p.split('-').map(Number);
-      const start = new Date(Date.UTC(y, m - 1, d, 0, 0, 0, 0));
-      const end = new Date(Date.UTC(y, m - 1, d + 1, 0, 0, 0, 0));
-      return { start, end };
+    else if (period.endsWith("d"))
+    {
+      const days = parseInt(period.slice(0, -1));
+      start = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
+    }
+    else if (period.endsWith("mo"))
+    {
+      const months = parseInt(period.slice(0, -2));
+      start = new Date(now);
+      start.setMonth(start.getMonth() - months);
+    }
+    else
+    {
+      throw new Error("Período inválido. Use m, h, d ou mo.");
     }
-
-    // composite relativo
-    const parts = parseCompositePeriodString(p);
-    const now = new Date();
-    const start = subtractComposite(now, parts);
-    if (start >= now) throw new Error('Período inválido: início no futuro.');
     return { start, end: now };
   }
 
-  static async getSlaReport(serviceId: string, start: Date, end: Date): Promise<SlaResult> {
-    const now = new Date();
-    const safeEnd = end > now ? now : end;
-    if (start >= safeEnd) throw new Error("Intervalo inválido: 'start' deve ser anterior a 'end'.");
-    return await SlaCalculator.calculate(serviceId, start, safeEnd);
+  static async getSlaReport(serviceId: string, start: Date, end: Date): Promise<SlaResult>
+  {
+    return await SlaCalculator.calculate(serviceId, start, end);
   }
 
-  static async getSlaReportByPeriod(serviceId: string, period: string): Promise<SlaResult> {
+  static async getSlaReportByPeriod(serviceId: string, period: string): Promise<SlaResult>
+  {
     const { start, end } = this.parsePeriod(period);
     return await this.getSlaReport(serviceId, start, end);
   }
diff --git a/src/Monitoring/Workers/slaWorker.ts b/src/Monitoring/Workers/slaWorker.ts
index f6229e8..17b192a 100644
--- a/src/Monitoring/Workers/slaWorker.ts
+++ b/src/Monitoring/Workers/slaWorker.ts
@@ -44,7 +44,7 @@ export async function processSlaAndAlerts(serviceId: string, issues: any[] = [])
       const incident = await findOrOpenIncident(issue.serviceId);
       if (!incident) {
         console.error(`Falha ao criar ou obter incidente para serviço ${issue.serviceId}`);
-        continue;
+        continue; // Skip if incident creation failed
       }
 
       await writeSlaRecordToInflux({
@@ -86,4 +86,4 @@ export async function processSlaAndAlerts(serviceId: string, issues: any[] = [])
     await closeIncidentIfRecovered(serviceId, policy.recoveryConfirmations);
 
   }
-}
\ No newline at end of file
+}
diff --git a/src/Monitoring/Workers/worker2.ts b/src/Monitoring/Workers/worker2.ts
index 0afd20a..9e2cdc7 100644
--- a/src/Monitoring/Workers/worker2.ts
+++ b/src/Monitoring/Workers/worker2.ts
@@ -1,3 +1,47 @@
+// <<<<<<< HEAD
+
+// import { getIO } from '../../socket';
+// import { CheckSNMP } from '../Checkers/CheckSNMP';
+// import { CheckHTTP } from '../Checkers/CheckHTTP';
+// import { CheckPING } from '../Checkers/CheckPING';
+// import { CheckWebhook } from '../Checkers/CheckWEBHOOK';
+// import { PrismaClient, Service, ServiceType } from '@prisma/client';
+// import { writeSnmpMetrics } from '../../Influxdb/WriteMetrics/WriteSnmpMetrics';
+// import { writePingMetrics } from '../../Influxdb/WriteMetrics/WritePingMetrics';
+// import { writeHttpMetrics } from '../../Influxdb/WriteMetrics/WriteHttpMetrics';
+// import { writeWebhookMetrics } from '../../Influxdb/WriteMetrics/WriteWebhookMetrics';
+// import { findOrOpenIncident, closeIncidentIfRecovered, updateIncidentNotification } from '../Incidents/incidentManager';
+
+// const prisma = new PrismaClient();
+
+// async function getServiceResult(service: Service) {
+//   switch (service.type) {
+//     case ServiceType.HTTP:
+//       return CheckHTTP(service.target);
+//     case ServiceType.PING:
+//       return CheckPING(service.target);
+//     case ServiceType.SNMP:
+//       return CheckSNMP(service.target);
+//     case ServiceType.WEBHOOK:
+//       return CheckWebhook(service.target);
+//     default:
+//       return null;
+//   }
+// }
+
+// async function processServiceResult(service: Service, result: any) {
+//   const problems: Array<any> = [];
+
+//   if (!result) {
+//     problems.push({
+//       serviceId: service.id,
+//       serviceName: service.name,
+//       metric: 'unknown',
+//       value: 0,
+//       status: 'DOWN',
+//       description: 'Sem resposta ou resultado inválido',
+//       criticality: 'high',
+// =======
 import { getIO } from "../../socket";
 import { Problem } from "../../types/Problem";
 import { analyzePingIssue } from "../../Analyzers/PingIssueAnalyzer";
@@ -6,15 +50,19 @@ import { analyzeSnmpIssue } from "../../Analyzers/analyzeSnmpIssue";
 import { writeSnmpMetrics } from "../../Influxdb/WriteMetrics/WriteSnmpMetrics";
 import { writePingMetrics } from "../../Influxdb/WriteMetrics/WritePingMetrics";
 import { writeHttpMetrics } from "../../Influxdb/WriteMetrics/WriteHttpMetrics";
+import { PrismaClient } from "@prisma/client";
+import { findOrOpenIncident, closeIncidentIfRecovered, updateIncidentNotification } from '../Incidents/incidentManager';
+
+const prisma = new PrismaClient();
 
-export async function processProxyData(data: any): Promise<Problem[]>
-{
+export async function processProxyData(data: any): Promise<Problem[]> {
   const io = getIO();
   const problems: Problem[] = [];
-  
+
   console.log(data)
-  
-  if (!data || !data.type) {
+
+  if (!data || !data.type)
+  {
     problems.push({
       serviceId: data?.id || "unknown",
       serviceName: data?.target || "unknown",
@@ -26,41 +74,189 @@ export async function processProxyData(data: any): Promise<Problem[]>
       priority: 2,
       severity: "WARNING",
       timestamp: new Date().toISOString(),
+// >>>>>>> origin/main
     });
+    const incident = await findOrOpenIncident(service.id);
+    if (incident && incident.id) {
+      await updateIncidentNotification(incident.id, (incident.retryCount || 0) + 1);
+    } else {
+      console.error(`Falha ao criar ou obter incidente para serviço ${service.id}`);
+    }
+    // await findOrOpenIncident(service.id);
     return problems;
   }
-  
+
+// <<<<<<< HEAD
+//   const io = getIO();
+
+//   switch (service.type) {
+//     case ServiceType.SNMP: {
+//       io.emit('snmpService', result);
+//       writeSnmpMetrics(service.id, result);
+//       const isDown = !result.sysName;
+//       if (isDown) {
+//         problems.push({
+//           serviceId: service.id,
+//           serviceName: service.name,
+//           metric: 'SNMP',
+//           value: 0,
+//           status: 'DOWN',
+//           description: 'SNMP não retornou nome do sistema',
+//           criticality: 'high',
+//         });
+//       }
+//       await prisma.service.update({
+//         where: { id: service.id },
+//         data: {
+//           status: isDown ? 'DOWN' : 'UP',
+//           sysName: result.sysName || null,
+//           sysDescr: result.sysDescr || null,
+//         },
+//       });
+//       break;
+//     }
+//     case ServiceType.PING: {
+//       io.emit('pingService', { ...result, service });
+//       writePingMetrics(service.id, result);
+//       const isDown = result.status !== 'UP';
+//       if (isDown) {
+//         problems.push({
+//           serviceId: service.id,
+//           serviceName: service.name,
+//           metric: 'PING',
+//           value: result.avgMs ?? 0,
+//           status: 'DOWN',
+//           description: `Status: ${result.status}, perda de pacotes: ${result.lossPercent}%`,
+//           lossPercent: result.lossPercent,
+//           criticality: result.lossPercent === 100 ? 'critical' : 'high',
+//         });
+//       } else {
+//         console.log(`Status UP para ${service.name}. Nenhum ticket criado.`);
+//       }
+//       await prisma.service.update({
+//         where: { id: service.id },
+//         data: {
+//           status: isDown ? 'DOWN' : 'UP',
+//           lastResponseMs: result.avgMs ?? null,
+//         },
+//       });
+//       break;
+//     }
+//     case ServiceType.HTTP: {
+//       io.emit('httpService', { ...result, service });
+//       writeHttpMetrics(service.id, result);
+//       const isDown = result.status !== 'UP';
+//       if (isDown) {
+//         problems.push({
+//           serviceId: service.id,
+//           serviceName: service.name,
+//           metric: 'HTTP',
+//           value: result.totalMs ?? 0,
+//           status: 'DOWN',
+//           description: `Status: ${result.status}, HTTP: ${result.httpStatus}, tempo total: ${result.totalMs}ms`,
+//           criticality: result.httpStatus >= 500 ? 'critical' : 'high',
+//         });
+//       } else {
+//         console.log(`Status UP para ${service.name}. Nenhum ticket criado.`);
+//       }
+//       await prisma.service.update({
+//         where: { id: service.id },
+//         data: {
+//           status: isDown ? 'DOWN' : 'UP',
+//           lastResponseMs: result.totalMs ?? null,
+//         },
+//       });
+//       break;
+//     }
+//     case ServiceType.WEBHOOK: {
+//       io.emit('webhookService', result);
+//       writeWebhookMetrics(service.id, result);
+//       const isDown = result.status !== 'UP';
+//       if (isDown) {
+//         problems.push({
+//           serviceId: service.id,
+//           serviceName: service.name,
+//           metric: 'WEBHOOK',
+//           value: result.totalMs ?? 0,
+//           status: 'DOWN',
+//           description: `Status: ${result.status}, HTTP: ${result.httpStatus}, tempo total: ${result.totalMs}ms`,
+//           criticality: 'high',
+//         });
+//       }
+//       await prisma.service.update({
+//         where: { id: service.id },
+//         data: {
+//           status: isDown ? 'DOWN' : 'UP',
+//           sysName: result.sysName || null,
+//           sysDescr: result.sysDescr || null,
+//         },
+//       });
+// =======
   switch (data.type)
   {
     case "SNMP":
       io.emit("snmpService", data);
-      await writeSnmpMetrics(data.serviceId, data);
-      const snmpAnalysis = await analyzeSnmpIssue({ id: data.serviceId, name: data.target }, data);
+      writeSnmpMetrics(data.id, data);
+      const snmpAnalysis = analyzeSnmpIssue({ id: data.id, name: data.target }, data);
       if (snmpAnalysis)
         problems.push(snmpAnalysis);
       break;
-      
-      case "PING":
-        io.emit("pingService", data);
-        await writePingMetrics(data.serviceId, data);
-        const pingAnalysis = analyzePingIssue({ id: data.serviceId, name: data.target }, data);
-        if (pingAnalysis)
-          problems.push(pingAnalysis);
+
+    case "PING":
+      io.emit("pingService", data);
+      writePingMetrics(data.id, data);
+      const pingAnalysis = analyzePingIssue({ id: data.id, name: data.target }, data);
+      if (pingAnalysis)
+        problems.push(pingAnalysis);
       break;
 
-      case "HTTP":
+    case "HTTP":
       io.emit("httpService", data);
-      await writeHttpMetrics(data.serviceId, data);
-      const httpAnalysis = analyzeHttpIssue({ id: data.serviceId, name: data.target }, data);
+      writeHttpMetrics(data.id, data);
+      const httpAnalysis = analyzeHttpIssue({ id: data.id, name: data.target }, data);
       if (httpAnalysis)
         problems.push(httpAnalysis);
+// >>>>>>> origin/main
       break;
-    
     default:
+      break;
+      return [];
+  }
+
+  // Verificar incidentes abertos antes de processar
+  const existingIncident = await prisma.incident.findFirst({
+    where: { serviceId: service.id, closedAt: null },
+  });
+
+  if (problems.length > 0 && !existingIncident) {
+    const incident = await findOrOpenIncident(service.id);
+    if (incident && incident.id) {
+      await updateIncidentNotification(incident.id, (incident.retryCount || 0) + 1);
+    }
+  } else if (service.status === 'UP' && existingIncident) {
+    await closeIncidentIfRecovered(service.id, 3);
+  }
+
+  return problems;
+}
+
+export async function detectIssues(serviceId?: string): Promise<Array<any>> {
+  const problems: Array<any> = [];
+
+  const services: Service[] = serviceId
+    ? [await prisma.service.findUniqueOrThrow({ where: { id: serviceId } })]
+    : await prisma.service.findMany();
+
+  for (const service of services) {
+    try {
+      const result = await getServiceResult(service);
+      const serviceProblems = await processServiceResult(service, result);
+      problems.push(...serviceProblems);
+    } catch (error) {
       problems.push({
-        serviceId: data.serviceId,
-        serviceName: data.target,
-        metric: "unknown",
+        serviceId: service.id,
+        serviceName: service.name,
+        metric: 'unknown',
         value: 0,
         status: "UNKNOWN",
         description: `Tipo de serviço desconhecido: ${data.type}`,
@@ -69,7 +265,20 @@ export async function processProxyData(data: any): Promise<Problem[]>
         severity: "WARNING",
         timestamp: new Date().toISOString(),
       });
+      const incident = await findOrOpenIncident(service.id);
+      if (incident && incident.id) {
+        await updateIncidentNotification(incident.id, 1);
+      }
+    }
   }
   return problems;
 }
 
+function processServiceResult(service: Service, result: any) {
+  throw new Error("Function not implemented.");
+}
+
+function getServiceResult(service: Service) {
+  throw new Error("Function not implemented.");
+}
+
diff --git a/src/Notifications/Email/EmailProvider.ts b/src/Notifications/Email/EmailProvider.ts
index 4d71be3..0a2dac0 100644
--- a/src/Notifications/Email/EmailProvider.ts
+++ b/src/Notifications/Email/EmailProvider.ts
@@ -1,55 +1,89 @@
-/// <reference types="node" />
 import nodemailer from 'nodemailer';
-import { INotificationProvider, NotificationOptions } from '../INotificationProvider';
-import { buildAlertEmailHtml } from '../HTML/alertTemplate';
-import { buildResetCodeEmailHtml } from '../HTML/resetCodeTemplate';
+import { INotificationProvider } from '../INotificationProvider';
 
 export class EmailProvider implements INotificationProvider {
   private transporter;
 
   constructor() {
-    const user = process.env.EMAIL_USER;
-    const pass = process.env.EMAIL_PASS;
-
-    if (!user || !pass) {
-      console.warn('[EmailProvider] Variáveis EMAIL_USER / EMAIL_PASS ausentes. Envios irão falhar.');
-    }
-
     this.transporter = nodemailer.createTransport({
-      service: process.env.EMAIL_SERVICE || 'gmail',
-      host: process.env.EMAIL_HOST,
-      port: process.env.EMAIL_PORT ? Number(process.env.EMAIL_PORT) : undefined,
-      secure: process.env.EMAIL_SECURE === 'true',
-      auth: user && pass ? { user, pass } : undefined,
+      service: 'gmail',
+      auth: {
+        user: process.env.EMAIL_USER,
+        pass: process.env.EMAIL_PASS,
+      },
     });
   }
 
-  async sendNotification(to: string, message: string, options?: NotificationOptions): Promise<string | undefined> {
-    if (!to || !/\S+@\S+\.\S+/.test(to)) {
-      throw new Error('Email inválido');
-    }
-    if (!this.transporter) {
-      throw new Error('Transporter de email não inicializado');
-    }
+  async sendNotification(to: string, message: string): Promise<void> {
+    const htmlContent = `
+      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
+        <div style="background-color: #0056b3; padding: 20px; text-align: center;">
+          <img src="https://cdn-icons-png.flaticon.com/512/565/565547.png" alt="InfraWatch Logo" width="60" style="display: block; margin: 0 auto 10px auto;" />
+          <h1 style="color: white; margin: 0; font-size: 24px;">InfraWatch</h1>
+        </div>
+  
+        <div style="padding: 20px; color: #333;">
+          <h2 style="color: #0056b3;">🚨 Alerta Importante</h2>
+          <p style="font-size: 16px; line-height: 1.5;">
+            ${message}
+          </p>
+  
+          <a href="#" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background-color: #0056b3; color: white; text-decoration: none; border-radius: 5px; font-weight: 600;">
+            Ver detalhes
+          </a>
+        </div>
+  
+        <div style="background-color: #f5f5f5; padding: 15px; font-size: 12px; color: #777; text-align: center;">
+          <p>Este é um alerta automático enviado pelo sistema InfraWatch. Por favor, não responda este e-mail.</p>
+        </div>
+      </div>
+    `;
+  
+    await this.transporter.sendMail({
+      from: process.env.EMAIL_USER,
+      to,
+      subject: 'InfraWatch - Alerta',
+      text: message,
+      html: htmlContent,
+    });
+  }
 
-    const templateType = options?.metadata?.templateType || 'alert';
-    const subject = templateType === 'reset-code'
-      ? 'InfraWatch - Código de Redefinição de Senha'
-      : (options?.metadata?.subject || 'InfraWatch - Alerta');
+  async sendNotification2(to: string, code: string): Promise<void>
+  {
+      const htmlContent = `
+      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
+        <div style="background-color: #0056b3; padding: 20px; text-align: center;">
+          <img src="https://cdn-icons-png.flaticon.com/512/565/565547.png" alt="InfraWatch Logo" width="60" style="display: block; margin: 0 auto 10px auto;" />
+          <h1 style="color: white; margin: 0; font-size: 24px;">InfraWatch</h1>
+        </div>
 
-    const html = templateType === 'reset-code'
-      ? buildResetCodeEmailHtml(message)
-      : buildAlertEmailHtml(message);
+        <div style="padding: 20px; color: #333;">
+          <h2 style="color: #0056b3;">🔒 Código de Redefinição de Senha</h2>
+          <p style="font-size: 16px; line-height: 1.5;">
+            Você solicitou a redefinição de senha. Use o código abaixo para continuar:
+          </p>
+          <p style="font-size: 24px; font-weight: bold; color: #e63946; text-align: center; margin: 20px 0;">
+            ${code}
+          </p>
+          <p style="font-size: 14px; color: #555;">
+            Este código é válido por 15 minutos. Se você não solicitou essa alteração, ignore este e-mail.
+          </p>
+        </div>
 
-    const info = await this.transporter.sendMail({
-      from: process.env.EMAIL_FROM || process.env.EMAIL_USER,
+        <div style="background-color: #f5f5f5; padding: 15px; font-size: 12px; color: #777; text-align: center;">
+          <p>Este é um e-mail automático enviado pelo sistema InfraWatch. Por favor, não responda este e-mail.</p>
+        </div>
+      </div>
+    `;
+
+    await this.transporter.sendMail(
+    {
+      from: process.env.EMAIL_USER,
       to,
-      subject,
-      text: message,
-      html,
+      subject: 'InfraWatch - Código de Redefinição de Senha',
+      text: `Seu código de redefinição de senha é: ${code}`,
+      html: htmlContent,
     });
-    return info?.messageId;
   }
-
   
 }
diff --git a/src/Notifications/HTML/alertTemplate.ts b/src/Notifications/HTML/alertTemplate.ts
deleted file mode 100644
index ef31a63..0000000
--- a/src/Notifications/HTML/alertTemplate.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-export function buildAlertEmailHtml(message: string)
-{
-  return `
-  <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
-    <div style="background-color: #0056b3; padding: 20px; text-align: center;">
-      <img src="https://cdn-icons-png.flaticon.com/512/565/565547.png" alt="InfraWatch Logo" width="60" style="display: block; margin: 0 auto 10px auto;" />
-      <h1 style="color: white; margin: 0; font-size: 24px;">InfraWatch</h1>
-    </div>
-
-    <div style="padding: 20px; color: #333;">
-      <h2 style="color: #0056b3;">🚨 Alerta Importante</h2>
-      <p style="font-size: 16px; line-height: 1.5;">
-        ${message}
-      </p>
-
-      <a href="#" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background-color: #0056b3; color: white; text-decoration: none; border-radius: 5px; font-weight: 600;">
-        Ver detalhes
-      </a>
-    </div>
-
-    <div style="background-color: #f5f5f5; padding: 15px; font-size: 12px; color: #777; text-align: center;">
-      <p>Este é um alerta automático enviado pelo sistema InfraWatch. Por favor, não responda este e-mail.</p>
-    </div>
-  </div>`;
-}
diff --git a/src/Notifications/HTML/resetCodeTemplate.ts b/src/Notifications/HTML/resetCodeTemplate.ts
deleted file mode 100644
index 11846f2..0000000
--- a/src/Notifications/HTML/resetCodeTemplate.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-export function buildResetCodeEmailHtml(code: string)
-{
-  return `
-  <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: auto; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
-    <div style="background-color: #0056b3; padding: 20px; text-align: center;">
-      <img src="https://cdn-icons-png.flaticon.com/512/565/565547.png" alt="InfraWatch Logo" width="60" style="display: block; margin: 0 auto 10px auto;" />
-      <h1 style="color: white; margin: 0; font-size: 24px;">InfraWatch</h1>
-    </div>
-
-    <div style="padding: 20px; color: #333;">
-      <h2 style="color: #0056b3;">🔒 Código de Redefinição de Senha</h2>
-      <p style="font-size: 16px; line-height: 1.5;">
-        Você solicitou a redefinição de senha. Use o código abaixo para continuar:
-      </p>
-      <p style="font-size: 24px; font-weight: bold; color: #e63946; text-align: center; margin: 20px 0;">
-        ${code}
-      </p>
-      <p style="font-size: 14px; color: #555;">
-        Este código é válido por 15 minutos. Se você não solicitou essa alteração, ignore este e-mail.
-      </p>
-    </div>
-
-    <div style="background-color: #f5f5f5; padding: 15px; font-size: 12px; color: #777; text-align: center;">
-      <p>Este é um e-mail automático enviado pelo sistema InfraWatch. Por favor, não responda este e-mail.</p>
-    </div>
-  </div>`;
-}
diff --git a/src/Notifications/INotificationProvider.ts b/src/Notifications/INotificationProvider.ts
index 14b8496..00a7c3b 100644
--- a/src/Notifications/INotificationProvider.ts
+++ b/src/Notifications/INotificationProvider.ts
@@ -1,17 +1,5 @@
-export interface NotificationOptions {
-  retry?: number;
-  timeout?: number;
-  metadata?: Record<string, any>; // ex.: { subject, channel, serviceName }
-}
-
-export interface INotificationProvider {
-  /**
-   * Envia uma notificação para o destino especificado.
-   * Deve retornar um identificador de mensagem quando disponível (ex: messageId, sid, etc.).
-   */
-  sendNotification(
-    to: string,
-    message: string,
-    options?: NotificationOptions
-  ): Promise<string | undefined>;
+export interface INotificationProvider
+{
+    sendNotification(to: string, message: string): Promise<void>;
 }
+  
\ No newline at end of file
diff --git a/src/Notifications/Notification.ts b/src/Notifications/Notification.ts
index e46cc70..16edcdb 100644
--- a/src/Notifications/Notification.ts
+++ b/src/Notifications/Notification.ts
@@ -2,131 +2,47 @@ import { EmailProvider } from './Email/EmailProvider';
 import { SlackProvider } from './Slack/SlackProvider';
 import { TelegramProvider } from './Telegram/TelegramProvider';
 import { TwilioProvider } from './Twilio/TwilioProvider';
-import { INotificationProvider, NotificationOptions } from './INotificationProvider';
-
-export type Channel = 'email' | 'slack' | 'telegram' | 'twilio';
-
-export type NotificationResult = {
-  channel: Channel;
-  to: string;
-  success: boolean;
-  messageId?: string;
-  error?: Error;
-  timestamp: string;
-};
-
-type Metrics = {
-  sent: number;
-  failed: number;
-  lastSuccess?: string;
-  lastFailure?: string;
-  lastError?: string;
-};
-
-export class NotificationController {
-  private providers: Partial<Record<Channel, INotificationProvider>> = {};
-  private factories: Record<Channel, () => INotificationProvider> = {
-    email: () => new EmailProvider(),
-    slack: () => new SlackProvider(),
-    telegram: () => new TelegramProvider(),
-    twilio: () => new TwilioProvider(),
-  };
-  private metrics: Record<Channel, Metrics>;
-
-  constructor() {
-    this.metrics = {
-      email: { sent: 0, failed: 0 },
-      slack: { sent: 0, failed: 0 },
-      telegram: { sent: 0, failed: 0 },
-      twilio: { sent: 0, failed: 0 },
+import { INotificationProvider } from './INotificationProvider';
+
+type Channel = 'email' | 'slack' | 'telegram' | 'twilio';
+
+export class NotificationController
+{
+  private providers: Record<Channel, INotificationProvider>;
+
+  constructor()
+  {
+    this.providers =
+    {
+      email: new EmailProvider(),
+      slack: new SlackProvider(),
+      telegram: new TelegramProvider(),
+      twilio: new TwilioProvider(),
     };
   }
 
-  private getProvider(channel: Channel): INotificationProvider {
-    if (!this.providers[channel]) {
-      this.providers[channel] = this.factories[channel]();
-    }
-    return this.providers[channel]!;
+  async send(channel: Channel, to: string, message: string)
+  {
+    const provider = this.providers[channel];
+    if (!provider) throw new Error(`Canal ${channel} não suportado`);
+    await provider.sendNotification(to, message);
   }
+}
 
-  private updateSuccess(channel: Channel) {
-    const now = new Date().toISOString();
-    this.metrics[channel].sent += 1;
-    this.metrics[channel].lastSuccess = now;
-  }
-
-  private updateFailure(channel: Channel, err: Error) {
-    const now = new Date().toISOString();
-    this.metrics[channel].failed += 1;
-    this.metrics[channel].lastFailure = now;
-    this.metrics[channel].lastError = err.message;
-  }
-
-  async send(channel: Channel, to: string, message: string, options: NotificationOptions = {}): Promise<NotificationResult> {
-    const provider = this.getProvider(channel);
-    const retry = Math.max(0, options.retry ?? 0);
-    const timeoutMs = options.timeout && options.timeout > 0 ? options.timeout : undefined;
-
-    const attemptOnce = async (): Promise<string | undefined> => {
-      if (!timeoutMs) return provider.sendNotification(to, message, options);
-      return await Promise.race([
-        provider.sendNotification(to, message, options),
-        new Promise<string | undefined>((_, reject) => setTimeout(() => reject(new Error('Timeout ao enviar notificação')), timeoutMs)),
-      ]);
-    };
+const notificationController = new NotificationController();
 
-    let lastError: Error | undefined;
-    for (let attempt = 0; attempt <= retry; attempt++) {
-      try {
-        const messageId = await attemptOnce();
-        this.updateSuccess(channel);
-        return { channel, to, success: true, messageId, timestamp: new Date().toISOString() };
-      } catch (err) {
-        lastError = err as Error;
-        if (attempt < retry) await new Promise((r) => setTimeout(r, 200 * (attempt + 1)));
-      }
+export async function sendAlert(channel: 'email' | 'slack' | 'telegram' | 'twilio', to: string, message: string)
+{
+    try
+    {
+      await notificationController.send(channel, to, message);
+      console.log(`Alerta enviado via ${channel} para ${to}`);
     }
-
-    this.updateFailure(channel, lastError ?? new Error('Falha desconhecida'));
-    return { channel, to, success: false, error: lastError, timestamp: new Date().toISOString() };
-  }
-
-  async sendWithFallback(
-    channels: Channel[],
-    to: string | Partial<Record<Channel, string>>,
-    message: string,
-    options?: NotificationOptions,
-  ): Promise<NotificationResult[]> {
-    const results: NotificationResult[] = [];
-    for (const channel of channels) {
-      const destination = typeof to === 'string' ? to : (to[channel] ?? '');
-      if (!destination) {
-        results.push({ channel, to: destination, success: false, error: new Error('Destino não fornecido'), timestamp: new Date().toISOString() });
-        continue;
-      }
-      const result = await this.send(channel, destination, message, options);
-      results.push(result);
-      if (result.success) break;
+    catch (error)
+    {
+      console.error(`Erro ao enviar alerta via ${channel} para ${to}:`, error);
     }
-    return results;
-  }
-
-  getMetrics() { return this.metrics; }
-  reset() {
-    (Object.keys(this.metrics) as Channel[]).forEach((c) => {
-      this.metrics[c] = { sent: 0, failed: 0 };
-    });
-  }
 }
 
-export const notificationController = new NotificationController();
 
-export async function sendAlert(channel: Channel, to: string, message: string) {
-  try {
-    const result = await notificationController.send(channel, to, message);
-    if (result.success) console.log(`Alerta enviado via ${channel} para ${to}`);
-    else console.error(`Falha ao enviar alerta via ${channel} para ${to}: ${result.error?.message}`);
-  } catch (error) {
-    console.error(`Erro ao enviar alerta via ${channel} para ${to}:`, error);
-  }
-}
+
diff --git a/src/Notifications/Slack/SlackProvider.ts b/src/Notifications/Slack/SlackProvider.ts
index dc7ffe6..a3dd4a6 100644
--- a/src/Notifications/Slack/SlackProvider.ts
+++ b/src/Notifications/Slack/SlackProvider.ts
@@ -1,31 +1,20 @@
 import axios from 'axios';
-import { INotificationProvider, NotificationOptions } from '../INotificationProvider';
+import { INotificationProvider } from '../INotificationProvider';
 
-export class SlackProvider implements INotificationProvider {
-  private webhookUrl: string | undefined;
-  private enabled = false;
+export class SlackProvider implements INotificationProvider
+{
+  private webhookUrl: string;
 
-  constructor() {
-    this.webhookUrl = process.env.SLACK_WEBHOOK_URL;
-    if (!this.webhookUrl) {
-      console.warn('[SlackProvider] SLACK_WEBHOOK_URL ausente: Slack desabilitado.');
-    } else {
-      this.enabled = true;
-    }
+  constructor()
+  {
+    this.webhookUrl = process.env.SLACK_WEBHOOK_URL || '';
   }
 
-  async sendNotification(to: string, message: string, _options?: NotificationOptions): Promise<string | undefined> {
-    if (!this.enabled || !this.webhookUrl) {
-      throw new Error('Slack não configurado');
-    }
-    if (!to || !to.startsWith('#')) {
-      // Permite também canal direto? Poderia validar @user, aqui exigimos canal #
-      console.warn('[SlackProvider] Destino não começa com #, prosseguindo mesmo assim.');
-    }
+  async sendNotification(to: string, message: string): Promise<void>
+  {
     await axios.post(this.webhookUrl, {
       channel: to,
       text: message,
     });
-    return undefined;
   }
 }
diff --git a/src/Notifications/Telegram/TelegramProvider.ts b/src/Notifications/Telegram/TelegramProvider.ts
index 0659a18..ac3b85c 100644
--- a/src/Notifications/Telegram/TelegramProvider.ts
+++ b/src/Notifications/Telegram/TelegramProvider.ts
@@ -1,32 +1,22 @@
 import axios from 'axios';
-import { INotificationProvider, NotificationOptions } from '../INotificationProvider';
+import { INotificationProvider } from '../INotificationProvider';
 
-export class TelegramProvider implements INotificationProvider {
-  private botToken: string | undefined;
-  private enabled = false;
+export class TelegramProvider implements INotificationProvider
+{
+  private botToken: string;
 
   constructor() {
-    this.botToken = process.env.TELEGRAM_BOT_TOKEN;
-    if (!this.botToken) {
-      console.warn('[TelegramProvider] TELEGRAM_BOT_TOKEN ausente: Telegram desabilitado.');
-    } else {
-      this.enabled = true;
-    }
+    this.botToken = process.env.TELEGRAM_BOT_TOKEN || '';
   }
 
-  async sendNotification(to: string, message: string, options?: NotificationOptions): Promise<string | undefined> {
-    if (!this.enabled || !this.botToken) {
-      throw new Error('Telegram não configurado');
-    }
-    if (!to) {
-      throw new Error('Chat ID vazio');
-    }
+  async sendNotification(to: string, message: string): Promise<void>
+  {
+    // 'to' aqui é o chat_id (pode ser id do usuário ou grupo)
     const url = `https://api.telegram.org/bot${this.botToken}/sendMessage`;
-    const res = await axios.post(url, {
+
+    await axios.post(url, {
       chat_id: to,
       text: message,
-      parse_mode: options?.metadata?.parseMode,
     });
-    return res?.data?.result?.message_id?.toString();
   }
 }
diff --git a/src/Notifications/Twilio/TwilioProvider.ts b/src/Notifications/Twilio/TwilioProvider.ts
index 385e53f..714ec6e 100644
--- a/src/Notifications/Twilio/TwilioProvider.ts
+++ b/src/Notifications/Twilio/TwilioProvider.ts
@@ -1,38 +1,31 @@
 import { Twilio } from 'twilio';
-import { INotificationProvider, NotificationOptions } from '../INotificationProvider';
+import { INotificationProvider } from '../INotificationProvider';
 
-export class TwilioProvider implements INotificationProvider {
-  private client: Twilio | undefined;
-  private fromNumber: string = '';
-  private enabled = false;
+export class TwilioProvider implements INotificationProvider
+{
+  private client: Twilio;
+  private fromNumber: string;
 
-  constructor() {
+  constructor()
+  {
     const accountSid = process.env.TWILIO_SID;
     const authToken = process.env.TWILIO_AUTH_TOKEN;
-    const from = process.env.TWILIO_PHONE_NUMBER;
-    if (accountSid && authToken && from) {
-      this.client = new Twilio(accountSid, authToken);
-      this.fromNumber = from;
-      this.enabled = true;
-    } else {
-      console.warn('[TwilioProvider] Credenciais ausentes: SMS desabilitado.');
+    this.fromNumber = process.env.TWILIO_PHONE_NUMBER || '';
+
+    if (!accountSid || !authToken || !this.fromNumber)
+    {
+      throw new Error('Twilio credentials or phone number not set in environment variables.');
     }
+
+    this.client = new Twilio(accountSid, authToken);
   }
 
-  async sendNotification(to: string, message: string, options?: NotificationOptions): Promise<string | undefined> {
-    if (!this.enabled || !this.client) {
-      throw new Error('Twilio não configurado');
-    }
-    if (!/^\+?[1-9]\d{6,14}$/.test(to)) {
-      throw new Error('Número de telefone inválido (esperado formato E.164)');
-    }
-    const statusCallback = process.env.TWILIO_STATUS_CALLBACK || options?.metadata?.statusCallback;
-    const res = await this.client.messages.create({
+  async sendNotification(to: string, message: string): Promise<void>
+  {
+    await this.client.messages.create({
       body: message,
       from: this.fromNumber,
       to,
-      statusCallback,
     });
-    return res?.sid;
   }
 }
diff --git a/src/RegisterRoutes/RegisterRoutes.ts b/src/RegisterRoutes/RegisterRoutes.ts
index 232ec59..2c5c88d 100644
--- a/src/RegisterRoutes/RegisterRoutes.ts
+++ b/src/RegisterRoutes/RegisterRoutes.ts
@@ -1,10 +1,17 @@
 import jwtPlugin from '../plugins/jwt';
 import prisma from "../plugins/prisma.js";
 import { FastifyInstance } from "fastify";
+import { LoginRoutes } from "../routes/Auth/loginRoutes.js";
 import { servicesRoutes } from '../routes/APIs/servicesRoutes';
+import { RegisterRoutes } from "../routes/Auth/RegisterRoutes.js";
+import { VerifyOTProutes } from "../routes/Auth/VerifyOTPRoutes.js";
 import { notificationRoutes } from '../routes/APIs/notificationRoutes';
 import { serviceMetricsRoutes } from '../routes/APIs/serviceMetricsRoutes';
+import { resetarSenhaRoutes } from "../routes/Auth/ResetPasswordRoutes.js";
+import { addServiceRoutes } from "../routes/APIs/addServiceRoutes";
 import { alertContactRoutes } from '../routes/APIs/alertContactRoutes';
+import { webhookReceiverRoutes } from '../routes/APIs/webhookReceiver';
+import { solicitarResetSenhaRoutes } from "../routes/Auth/SolicitarResetPasswordRoutes.js";
 import { notificationPolicyRoutes } from '../routes/APIs/notificationPolicy';
 import { incidentRoutes } from '../routes/APIs/IncidentsRoutes';
 import { slaRoutes } from "../routes/APIs/slaRoutes";
@@ -15,11 +22,18 @@ export async function RegisterAllRoutes(app: FastifyInstance)
     app.register(prisma);
     app.register(jwtPlugin);
     app.register(proxyReceiverRoutes);
+    app.register(webhookReceiverRoutes);
     app.register(slaRoutes, { prefix: "/api" });
     app.register(servicesRoutes);
     app.register(alertContactRoutes);
     app.register(notificationRoutes);
     app.register(serviceMetricsRoutes);
+    app.register(addServiceRoutes);
     app.register(notificationPolicyRoutes);
     app.register(incidentRoutes, { prefix: '/api/incidents' });
+    app.register(LoginRoutes, { prefix: "/auth" });
+    app.register(RegisterRoutes, { prefix: "/auth" });
+    app.register(VerifyOTProutes, { prefix: "/auth" });
+    app.register(resetarSenhaRoutes, { prefix: "/auth" });
+    app.register(solicitarResetSenhaRoutes, { prefix: "/auth" });
 }
diff --git a/src/config/snmpConfig.ts b/src/config/snmpConfig.ts
new file mode 100644
index 0000000..aa36e3f
--- /dev/null
+++ b/src/config/snmpConfig.ts
@@ -0,0 +1,23 @@
+export const SNMP_OIDS = {
+  sysName: "1.3.6.1.2.1.1.5.0",       // Nome do dispositivo
+  sysDescr: "1.3.6.1.2.1.1.1.0",      // Descrição do dispositivo
+  sysUpTime: "1.3.6.1.2.1.1.3.0",     // Uptime
+  cpuLoad5sec: "1.3.6.1.4.1.9.2.1.56.0", // Carga CPU 5 sec
+  cpuLoad5min: "1.3.6.1.4.1.9.2.1.58.0", // Carga CPU 5 min
+  memTotal: "1.3.6.1.4.1.9.2.1.9.0", // Memória usada
+  memAvail: "1.3.6.1.4.1.9.2.1.8.0", // Memória disponível
+
+  ifIndex: "1.3.6.1.2.1.2.2.1.1",      // Índice da interface
+  ifDescr: "1.3.6.1.2.1.2.2.1.2",      // Nome da interface
+  ifType: "1.3.6.1.2.1.2.2.1.3",       // Tipo da interface (ethernet, loopback, etc)
+  ifMtu: "1.3.6.1.2.1.2.2.1.4",        // MTU
+  ifSpeed: "1.3.6.1.2.1.2.2.1.5",      // Velocidade
+  ifPhysAddress: "1.3.6.1.2.1.2.2.1.6",// MAC
+  ifAdminStatus: "1.3.6.1.2.1.2.2.1.7",// Status administrativo (up/down)
+  ifOperStatus: "1.3.6.1.2.1.2.2.1.8", // Status operacional (up/down)
+  ifInOctets: "1.3.6.1.2.1.2.2.1.10",  // Bytes recebidos
+  ifOutOctets: "1.3.6.1.2.1.2.2.1.16", // Bytes enviados
+
+  ipAddrTable: "1.3.6.1.2.1.4.20.1.2", // ipAdEntIfIndex -> mapeia IP para índice da interface
+};
+
diff --git a/src/routes/APIs/IncidentsRoutes.ts b/src/routes/APIs/IncidentsRoutes.ts
index 978d269..4ba25ca 100644
--- a/src/routes/APIs/IncidentsRoutes.ts
+++ b/src/routes/APIs/IncidentsRoutes.ts
@@ -88,4 +88,4 @@ export async function incidentRoutes(app: FastifyInstance)
       });
     },
   });
-}
\ No newline at end of file
+}
diff --git a/src/routes/APIs/addServiceRoutes.ts b/src/routes/APIs/addServiceRoutes.ts
new file mode 100644
index 0000000..6e8bc8a
--- /dev/null
+++ b/src/routes/APIs/addServiceRoutes.ts
@@ -0,0 +1,52 @@
+import { FastifyInstance } from 'fastify';
+import { addService } from '../../Controllers/APIs/addServices';
+import { syncServiceToGLPI } from '../../Integrations/GLPI/syncServices';
+
+export async function addServiceRoutes(fastify: FastifyInstance)
+{
+  fastify.post('/api/addServices', {
+    schema: {
+      description: 'Adicionar novo serviço',
+      tags: ['Services'],
+      body: {
+        type: 'object',
+        required: ['name', 'type', 'target', 'ownerId'],
+        properties: {
+          name: { type: 'string' },
+          type: { type: 'string', enum: ['HTTP', 'PING', 'SNMP', 'WEBHOOK'] },
+          target: { type: 'string' },
+          ownerId: { type: 'string' },
+          criticality: { type: 'string', enum: ['low', 'medium', 'high', 'critical'], default: 'medium' },
+        }
+      },
+      response: {
+        201: {
+          type: 'object',
+          properties: {
+            id: { type: 'string' },
+            name: { type: 'string' },
+            type: { type: 'string' },
+            target: { type: 'string' },
+            ownerId: { type: 'string' },
+            criticality: { type: 'string' },
+            status: { type: 'string' },
+            createdAt: { type: 'string' },
+            updatedAt: { type: 'string' },
+          },
+          400: {
+            type: 'object',
+            properties: {
+              message: { type: 'string' },
+            },
+          },
+          500: {
+            type: 'object',
+            properties: {
+              message: { type: 'string' },
+            },
+          },
+        }
+      }
+    }
+  }, addService);
+}
diff --git a/src/routes/APIs/alertContactRoutes.ts b/src/routes/APIs/alertContactRoutes.ts
index 17a9a75..c7a1eab 100644
--- a/src/routes/APIs/alertContactRoutes.ts
+++ b/src/routes/APIs/alertContactRoutes.ts
@@ -92,4 +92,4 @@ export async function alertContactRoutes(fastify: FastifyInstance)
       reply.status(500).send({ error: 'Erro ao remover contato' });
     }
   });
-}
\ No newline at end of file
+}
diff --git a/src/routes/APIs/proxyReceiverRoutes.ts b/src/routes/APIs/proxyReceiverRoutes.ts
index a2fedea..348750a 100644
--- a/src/routes/APIs/proxyReceiverRoutes.ts
+++ b/src/routes/APIs/proxyReceiverRoutes.ts
@@ -13,7 +13,7 @@ export async function proxyReceiverRoutes(fastify: FastifyInstance)
 
       for (const issue of issues)
       {
-        await processSlaAndAlerts(data.serviceId, [issue]);
+        await processSlaAndAlerts(issue.serviceId);
       }
       return { status: "ok", issues };
     }
diff --git a/src/routes/APIs/serviceMetricsRoutes.ts b/src/routes/APIs/serviceMetricsRoutes.ts
index 2751e65..d4691a3 100644
--- a/src/routes/APIs/serviceMetricsRoutes.ts
+++ b/src/routes/APIs/serviceMetricsRoutes.ts
@@ -3,9 +3,10 @@ import { getSnmpMetrics, getHttpMetrics, getWebhookMetrics, getPingMetrics } fro
 
 export async function serviceMetricsRoutes(fastify: FastifyInstance)
 {
+  // SNMP
   fastify.get('/api/services/:id/metrics/snmp', {
     schema: {
-      description: 'Obter métricas SNMP do serviço (última hora: system, interfaces, summary e sensores)',
+      description: 'Obter métricas SNMP do serviço pela última hora',
       tags: ['Services'],
       params: {
         type: 'object',
@@ -16,16 +17,14 @@ export async function serviceMetricsRoutes(fastify: FastifyInstance)
   }, async (request, reply) => {
     try {
       const { id } = request.params as { id: string };
-
-      const metrics = await getSnmpMetrics(id);
-
-      return reply.send(metrics);
+      return await getSnmpMetrics(id);
     } catch (error) {
       request.log.error(error);
-      return reply.status(500).send({ error: 'Erro ao buscar métricas SNMP' });
+      reply.status(500).send({ error: 'Erro ao buscar métricas SNMP' });
     }
   });
 
+  // HTTP
   fastify.get('/api/services/:id/metrics/http', {
     schema: {
       description: 'Obter métricas HTTP do serviço pela última hora',
@@ -46,6 +45,7 @@ export async function serviceMetricsRoutes(fastify: FastifyInstance)
     }
   });
 
+  // Webhook
   fastify.get('/api/services/:id/metrics/webhook', {
     schema: {
       description: 'Obter métricas Webhook do serviço pela última hora',
@@ -66,6 +66,7 @@ export async function serviceMetricsRoutes(fastify: FastifyInstance)
     }
   });
 
+  // Ping
   fastify.get('/api/services/:id/metrics/ping', {
     schema: {
       description: 'Obter métricas de PING do serviço pela última hora',
diff --git a/src/routes/APIs/servicesRoutes.ts b/src/routes/APIs/servicesRoutes.ts
index 6df23e2..28eca1a 100644
--- a/src/routes/APIs/servicesRoutes.ts
+++ b/src/routes/APIs/servicesRoutes.ts
@@ -1,10 +1,9 @@
 import { FastifyInstance } from 'fastify';
 import { getAllServices } from '../../Controllers/APIs/services';
-import { addService } from '../../Controllers/APIs/addServices';
-import { deleteService } from '../../Controllers/APIs/deleteServices';
+import { syncServiceToGLPI } from '../../Integrations/GLPI/syncServices';
 
-export async function servicesRoutes(fastify: FastifyInstance) {
-  // 📌 ROTA: GET /api/services - Listar todos os serviços
+export async function servicesRoutes(fastify: FastifyInstance)
+{
   fastify.get('/api/services', {
     schema: {
       description: 'Lista todos os serviços',
@@ -33,99 +32,4 @@ export async function servicesRoutes(fastify: FastifyInstance) {
       reply.status(500).send({ error: 'Erro ao listar serviços' });
     }
   });
-
-  // 📌 ROTA: POST /api/addServices/:ownerId - Criar novo serviço
-  fastify.post('/api/addServices/:ownerId', {
-    schema: {
-      description: 'Adicionar novo serviço',
-      tags: ['Services'],
-      params: {
-        type: 'object',
-        properties: {
-          ownerId: { type: 'string', description: 'ID do usuário dono do serviço' }
-        },
-        required: ['ownerId']
-      },
-      body: {
-        type: 'object',
-        required: ['name', 'type', 'target'],
-        properties: {
-          name: { type: 'string', description: 'Nome do serviço' },
-          type: { 
-            type: 'string', 
-            enum: ['HTTP', 'PING', 'SNMP', 'WEBHOOK'], 
-            description: 'Tipo de serviço a ser monitorado' 
-          },
-          target: { type: 'string', description: 'Endereço ou destino do serviço' }
-        }
-      },
-      response: {
-        201: {
-          description: 'Serviço criado com sucesso',
-          type: 'object',
-          properties: {
-            id: { type: 'string' },
-            name: { type: 'string' },
-            type: { type: 'string' },
-            target: { type: 'string' },
-            ownerId: { type: 'string' },
-            createdAt: { type: 'string', format: 'date-time' },
-            updatedAt: { type: 'string', format: 'date-time' },
-          }
-        },
-        400: {
-          description: 'Erro ao criar serviço',
-          type: 'object',
-          properties: {
-            message: { type: 'string' }
-          }
-        }
-      }
-    }
-  }, addService);
-
-  // 📌 ROTA: DELETE /api/deleteService/:ownerId/:serviceId - Deletar um serviço
-  fastify.delete('/api/deleteService/:ownerId/:serviceId', {
-    schema: {
-      description: 'Deleta um serviço pertencente a um usuário',
-      tags: ['Services'],
-      params: {
-        type: 'object',
-        required: ['ownerId', 'serviceId'],
-        properties: {
-          ownerId: { type: 'string', description: 'ID do dono do serviço' },
-          serviceId: { type: 'string', description: 'ID do serviço a ser deletado' }
-        }
-      },
-      response: {
-        200: {
-          description: 'Serviço deletado com sucesso',
-          type: 'object',
-          properties: {
-            id: { type: 'string' },
-            name: { type: 'string' },
-            type: { type: 'string' },
-            target: { type: 'string' },
-            ownerId: { type: 'string' },
-            createdAt: { type: 'string', format: 'date-time' },
-            updatedAt: { type: 'string', format: 'date-time' }
-          }
-        },
-        404: {
-          description: 'Serviço não encontrado ou não pertence ao usuário',
-          type: 'object',
-          properties: {
-            message: { type: 'string' }
-          }
-        },
-        500: {
-          description: 'Erro interno ao tentar deletar o serviço',
-          type: 'object',
-          properties: {
-            message: { type: 'string' }
-          }
-        }
-      }
-    }
-  }, deleteService);
 }
diff --git a/src/routes/APIs/slaRoutes.ts b/src/routes/APIs/slaRoutes.ts
index e054f2d..496d6b0 100644
--- a/src/routes/APIs/slaRoutes.ts
+++ b/src/routes/APIs/slaRoutes.ts
@@ -1,3 +1,4 @@
+// src/routes/APIs/slaRoutes.ts
 import { FastifyInstance } from "fastify";
 import { SlaService } from "../../Monitoring/SlaTracking/slaService";
 import { SlaReportGenerator } from "../../Monitoring/SlaTracking/slaReportGenerator";
diff --git a/src/routes/APIs/webhookReceiver.ts b/src/routes/APIs/webhookReceiver.ts
new file mode 100644
index 0000000..c0feb2f
--- /dev/null
+++ b/src/routes/APIs/webhookReceiver.ts
@@ -0,0 +1,103 @@
+import { FastifyInstance } from "fastify";
+import { PrismaClient } from "@prisma/client";
+import { writeWebhookMetrics } from "../../Influxdb/WriteMetrics/WriteWebhookMetrics";
+import { CheckWebhookPassive } from "../../Monitoring/Checkers/CheckWEBHOOKPASSIVE.ts";
+import { writeWebhookEvent } from "../../Influxdb/WriteMetrics/WriteWebhookEvent";
+
+const prisma = new PrismaClient();
+
+export async function webhookReceiverRoutes(app: FastifyInstance) {
+  app.post("/api/webhooks/:serviceId", {
+    schema: {
+      tags: ["Webhooks"],
+      summary: "Recebe eventos de serviços via Webhook",
+      description: "Recebe payloads externos, grava eventos e métricas no InfluxDB.",
+      params: {
+        type: "object",
+        properties: {
+          serviceId: { type: "string", format: "uuid" }
+        },
+        required: ["serviceId"]
+      },
+      body: {
+        type: "object",
+        properties: {
+          status: { type: "string", enum: ["UP", "DOWN", "UNKNOWN"], description: "Status do serviço" },
+          durationMs: { type: "integer", minimum: 0, description: "Tempo de resposta em ms" },
+          httpStatus: { type: "integer", description: "Código de status HTTP" },
+          msg: { type: "string", description: "Mensagem descritiva ou nota" },
+          ip: { type: "string", description: "Endereço IP do serviço monitorado" },
+          sizeBytes: { type: "integer", description: "Tamanho da resposta em bytes" },
+          dnsMs: { type: "integer", description: "Tempo de resolução DNS em ms" },
+          connectAndDownloadMs: { type: "integer", description: "Tempo total de conexão e download em ms" },
+          headers: { type: "object", additionalProperties: { type: "string" }, description: "Cabeçalhos HTTP recebidos" },
+          responseBody: { type: "string", description: "Corpo da resposta recebida" }
+        },
+        required: ["status"]
+      },
+      response: {
+        200: {
+          description: "Evento processado com sucesso",
+          type: "object",
+          properties: {
+            ok: { type: "boolean" },
+            processed: {
+              type: "object",
+              properties: {
+                status: { type: "string" },
+                totalMs: { type: "integer" },
+                httpStatus: { type: "integer" },
+                description: { type: "string" },
+                ip: { type: "string" },
+                sizeBytes: { type: "integer" },
+                dnsMs: { type: "integer" },
+                connectAndDownloadMs: { type: "integer" },
+                headers: { type: "object" },
+                payloadSent: { type: "object" },
+                responseBody: { type: "string" }
+              }
+            }
+          }
+        },
+        404: {
+          description: "Serviço não encontrado",
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        },
+        500: {
+          description: "Erro interno",
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        }
+      }
+    }
+  }, async (request, reply) => {
+    const { serviceId } = request.params as { serviceId: string };
+    const payload = request.body as any;
+
+    const service = await prisma.service.findUnique({
+      where: { id: serviceId },
+    });
+
+    if (!service) {
+      return reply.code(404).send({ error: "Service not found" });
+    }
+
+    await writeWebhookEvent({
+      serviceId,
+      payload,
+      sourceIp: request.ip,
+      userAgent: request.headers["user-agent"],
+      status: payload.status,
+      note: payload.msg,
+    });
+
+    const result = CheckWebhookPassive(payload);
+
+    return { ok: true, processed: result };
+  });
+}
diff --git a/src/routes/Auth/RegisterRoutes.ts b/src/routes/Auth/RegisterRoutes.ts
new file mode 100644
index 0000000..19e5bfc
--- /dev/null
+++ b/src/routes/Auth/RegisterRoutes.ts
@@ -0,0 +1,30 @@
+import { FastifyInstance } from 'fastify';
+import { Register } from '../../Controllers/Auth/Register';
+
+export async function RegisterRoutes(fastify: FastifyInstance)
+{
+  fastify.post('/register', {
+    schema: {
+      description: 'Registrar novo usuário',
+      tags: ['Auth'],
+      body: {
+        type: 'object',
+        required: ['name', 'email', 'password'],
+        properties: {
+          name: { type: 'string' },
+          email: { type: 'string', format: 'email' },
+          password: { type: 'string', minLength: 6 }
+        }
+      },
+      response: {
+        200: {
+          type: 'object',
+          properties: {
+            id: { type: 'string' },
+            email: { type: 'string' }
+          }
+        }
+      }
+    }
+  }, Register);
+}
diff --git a/src/routes/Auth/ResetPasswordRoutes.ts b/src/routes/Auth/ResetPasswordRoutes.ts
new file mode 100644
index 0000000..8371977
--- /dev/null
+++ b/src/routes/Auth/ResetPasswordRoutes.ts
@@ -0,0 +1,49 @@
+import { FastifyInstance } from "fastify";
+import { resetarSenha } from "../../Controllers/Auth/ResetPassword";
+
+export async function resetarSenhaRoutes(app: FastifyInstance)
+{
+  app.post("/resetarSenha", {
+    schema: {
+      description: "Resetar senha do usuário com token de redefinição",
+      tags: ["Auth"],
+      body: {
+        type: "object",
+        required: ["user", "token", "novaSenha", "confirmnovaSenha"],
+        properties: {
+          user: { type: "string", description: "Email ou telefone do usuário" },
+          token: { type: "string", description: "Token de redefinição recebido" },
+          novaSenha: { type: "string", description: "Nova senha" },
+          confirmnovaSenha: { type: "string", description: "Confirmação da nova senha" }
+        },
+      },
+      response: {
+        200: {
+          type: "object",
+          properties: {
+            message: { type: "string" }
+          }
+        },
+        400: {
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        },
+        401: {
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        },
+        403: {
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        }
+      }
+    },
+    handler: resetarSenha
+  });
+}
diff --git a/src/routes/Auth/SolicitarResetPasswordRoutes.ts b/src/routes/Auth/SolicitarResetPasswordRoutes.ts
new file mode 100644
index 0000000..3295b09
--- /dev/null
+++ b/src/routes/Auth/SolicitarResetPasswordRoutes.ts
@@ -0,0 +1,40 @@
+import { FastifyInstance } from "fastify";
+import { solicitarResetSenha } from "../../Controllers/Auth/SolicitarResetPassword";
+
+export async function solicitarResetSenhaRoutes(app: FastifyInstance)
+{
+  app.post("/solicitarResetSenha", {
+    schema: {
+      description: "Solicitar token para redefinição de senha",
+      tags: ["Auth"],
+      body: {
+        type: "object",
+        required: ["user"],
+        properties: {
+          user: { type: "string", description: "Email ou telefone do usuário" }
+        },
+      },
+      response: {
+        200: {
+          type: "object",
+          properties: {
+            message: { type: "string" }
+          }
+        },
+        400: {
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        },
+        404: {
+          type: "object",
+          properties: {
+            error: { type: "string" }
+          }
+        }
+      }
+    },
+    handler: solicitarResetSenha
+  });
+}
diff --git a/src/routes/Auth/VerifyOTPRoutes.ts b/src/routes/Auth/VerifyOTPRoutes.ts
new file mode 100644
index 0000000..7bbc620
--- /dev/null
+++ b/src/routes/Auth/VerifyOTPRoutes.ts
@@ -0,0 +1,51 @@
+import { FastifyInstance } from "fastify";
+import { VerifyOTP } from "../../Controllers/Auth/VerifyOTP";
+
+export async function VerifyOTProutes(app: FastifyInstance)
+{
+  app.post("/VerifyOTP", {
+    schema: {
+      description: "Verifica se o token OTP para resetar senha é válido",
+      tags: ["Auth"],
+      body: {
+        type: "object",
+        required: ["user", "token"],
+        properties: {
+          user: { type: "string", description: "Email do usuário" },
+          token: { type: "string", description: "Token OTP enviado para o usuário" },
+        },
+      },
+      response: {
+        200: {
+          description: "Token válido",
+          type: "object",
+          properties: {
+            message: { type: "string" },
+          },
+        },
+        400: {
+          description: "Email inválido",
+          type: "object",
+          properties: {
+            error: { type: "string" },
+          },
+        },
+        401: {
+          description: "OTP inválido",
+          type: "object",
+          properties: {
+            error: { type: "string" },
+          },
+        },
+        403: {
+          description: "Token expirado",
+          type: "object",
+          properties: {
+            error: { type: "string" },
+          },
+        },
+      },
+    },
+    handler: VerifyOTP,
+  });
+}
diff --git a/src/routes/Auth/loginRoutes.ts b/src/routes/Auth/loginRoutes.ts
new file mode 100644
index 0000000..a1bdf08
--- /dev/null
+++ b/src/routes/Auth/loginRoutes.ts
@@ -0,0 +1,28 @@
+import { FastifyInstance } from 'fastify';
+import { Login } from '../../Controllers/Auth/login';
+
+export async function LoginRoutes(fastify: FastifyInstance)
+{
+  fastify.post('/login', {
+    schema: {
+      description: 'Login do usuário',
+      tags: ['Auth'],
+      body: {
+        type: 'object',
+        required: ['email', 'password'],
+        properties: {
+          email: { type: 'string', format: 'email' },
+          password: { type: 'string' }
+        }
+      },
+      response: {
+        200: {
+          type: 'object',
+          properties: {
+            token: { type: 'string' }
+          }
+        }
+      }
+    }
+  }, Login);
+}
diff --git a/src/server.ts b/src/server.ts
index 42e64c2..00d848f 100644
--- a/src/server.ts
+++ b/src/server.ts
@@ -1,20 +1,100 @@
+// import Fastify from 'fastify';
+// import { initSocket } from './socket';
+// import fastifySwagger from 'fastify-swagger';
+// import { startMonitoring } from './Monitoring/Workers/worker';
+// import { RegisterAllRoutes } from "./RegisterRoutes/RegisterRoutes";
+// import cron from 'node-cron';
+// import { syncGlpiInventory } from './Integrations/GLPI/glpiClient'
+
+// const server = Fastify(
+// {
+//   logger: false,
+// });
+
+// server.register(fastifySwagger,
+// {
+//   routePrefix: '/docs',
+//   swagger: {
+//     info: {
+//       title: 'InfraWatch API',
+//       description: 'API do sistema InfraWatch',
+//       version: '0.1.0',
+//     },
+//     host: 'localhost:3002',
+//     schemes: ['http'],
+//     consumes: ['application/json'],
+//     produces: ['application/json'],
+//   },
+//   exposeRoute: true,
+// });
+
+// const start = async () =>
+// {
+//   try
+//   {
+//     RegisterAllRoutes(server);
+//     server.get('/sync-glpi', async (request, reply) => {
+//       await syncGlpiInventory();
+//       return { message: 'Sincronização com GLPI concluída.' };
+//     });
+//     // Sincroniza a cada hora
+//     cron.schedule('0 * * * *', async () => {
+//       console.log('Sincronizando inventário com GLPI...');
+//       await syncGlpiInventory();
+//     });
+
+//     initSocket(server.server);
+    
+//     await startMonitoring();
+
+//     await server.listen(3002, '0.0.0.0');
+//     console.log('Servidor Fastify rodando em http://localhost:3002');
+//     console.log(`Documentação disponível em http://localhost:3002/docs`);
+//   }
+//   catch (err)
+//   {
+//     server.log.error(err);
+//     process.exit(1);
+//   }
+// };
+
+// start();
+
 import Fastify from 'fastify';
-import localtunnel from 'localtunnel';
 import { initSocket } from './socket';
 import fastifySwagger from 'fastify-swagger';
 import { startMonitoring } from './Monitoring/Workers/worker';
-import { RegisterAllRoutes } from "./RegisterRoutes/RegisterRoutes";
-
-const PORT = Number(process.env.PORT) || 3000;
-const SUBDOMAIN = process.env.LOCALTUNNEL_SUBDOMAIN;
+import localtunnel from 'localtunnel';
+import { RegisterAllRoutes } from './RegisterRoutes/RegisterRoutes';
+import cron from 'node-cron';
+import { syncGlpiInventory } from './Integrations/GLPI/glpiClient';
 
-const server = Fastify({ logger: false });
+const server = Fastify({
+  logger: false,
+});
 
+// Load environment variables
+server.register(require('fastify-env'), {
+  confKey: 'config',
+  schema: {
+    type: 'object',
+    required: ['GLPI_INVENTORY_URL', 'GLPI_AGENT_TOKEN'],
+    properties: {
+      GLPI_INVENTORY_URL: { type: 'string' },
+      GLPI_AGENT_TOKEN: { type: 'string' },
+    },
+  },
+  dotenv: true,
+});
 server.register(fastifySwagger, {
   routePrefix: '/docs',
   swagger: {
-    info: { title: 'InfraWatch API', description: 'API do InfraWatch', version: '0.1.0' },
-    host: `localhost:${PORT}`,
+    info: {
+      title: 'InfraWatch API',
+      description: 'API do sistema InfraWatch',
+      version: '0.1.0',
+    },
+    host: `localhost:${3002}`,
     schemes: ['http'],
     consumes: ['application/json'],
     produces: ['application/json'],
@@ -23,27 +103,42 @@ server.register(fastifySwagger, {
 });
 
 const start = async () => {
-  try
-  {
+  try {
     RegisterAllRoutes(server);
+
+    // Manual GLPI sync endpoint
+    server.get('/sync-glpi', async (request, reply) => {
+      try {
+        await syncGlpiInventory();
+        return reply.code(200).send({ message: 'Sincronização com GLPI concluída.' });
+      } catch (error) {
+        console.error('Error during manual GLPI sync:', error.message);
+        return reply.code(500).send({ message: 'Erro durante sincronização com GLPI', error: error.message });
+      }
+    });
+
+    // Schedule hourly GLPI sync
+    cron.schedule('*/5 * * * *', async () => {
+      console.log('Sincronizando inventário com GLPI...');
+      await syncGlpiInventory();
+    });
+
     initSocket(server.server);
     await startMonitoring();
 
-    await server.listen(PORT, '0.0.0.0');
-    console.log(`Servidor Fastify rodando em http://localhost:${PORT}`);
-    console.log(`Documentação disponível em http://localhost:${PORT}/docs`);
-
-    const tunnel = await localtunnel({ port: PORT, subdomain: SUBDOMAIN });
-    console.log(`Servidor exposto publicamente em ${tunnel.url}`);
+    await server.listen(3002, '0.0.0.0');
+    console.log('Servidor Fastify rodando em http://localhost:3002');
+    console.log(`Documentação disponível em http://localhost:3002/docs`);
+    const tunnel = await localtunnel({ port: Number(3002), subdomain: 'infrawatch' });
+    
+    console.log(`Servidor Fastify exposto publicamente em ${tunnel.url}`);
     console.log(`Documentação disponível em ${tunnel.url}/docs`);
 
     tunnel.on('close', () => {
-      console.log('Túnel Localtunnel fechado');
+      console.log('Túnel localtunnel encerrado.');
     });
-  }
-  catch (err)
-  {
-    server.log.error(err);
+  } catch (err) {
+    console.error(err);
     process.exit(1);
   }
 };
diff --git a/src/types/net-snmp.d.ts b/src/types/net-snmp.d.ts
new file mode 100644
index 0000000..2582f00
--- /dev/null
+++ b/src/types/net-snmp.d.ts
@@ -0,0 +1,30 @@
+declare module "net-snmp" {
+  export interface SessionOptions {
+    port?: number;
+    retries?: number;
+    timeout?: number;
+    transport?: string;
+    trapPort?: number;
+    version?: number;
+    backwardsGetNexts?: boolean;
+    idBitsSize?: number;
+  }
+
+  export interface VarBind {
+    oid: string;
+    type: number;
+    value: any;
+  }
+
+  export function createSession(
+    target: string,
+    community: string,
+    options?: SessionOptions
+  ): any;
+
+  export function isVarbindError(vb: VarBind): boolean;
+
+  export function varbindError(vb: any) {
+    throw new Error("Function not implemented.");
+  }
+}
diff --git a/src/types/node-cron.d.ts b/src/types/node-cron.d.ts
new file mode 100644
index 0000000..87fbccd
--- /dev/null
+++ b/src/types/node-cron.d.ts
@@ -0,0 +1 @@
+declare module 'node-cron';
diff --git a/tsconfig.json b/tsconfig.json
index 66f724f..bfdf2ec 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,6 +1,7 @@
 {
   "compilerOptions":
   {
+    "types": ["node"],
     "typeRoots": ["./src/types", "./node_modules/@types"],
     "target": "ES2020",
     "module": "commonjs",
nuno
